<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[k-近邻算法]]></title>
    <url>%2F2018%2F04%2F12%2Fk-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0、概述 1、介绍 1.1、工作原理 1.2、优点，缺点，适用范围 1.3、一般流程 2、实现 2.1、伪代码 2.2、python实现 3、总结 0、概述简单的说，k-近邻算法是一种分类算法，采用测量测试用例与样本用例不同特征值之间的距离，选取距离最小的样本所属的分类作为测试用例的分类。 1、介绍1.1、工作原理工作原理：存在一个样本数据集，也称作训练样本集，并且样本集中每个数据都存在标签，即我们都知道样本集中每个数据与所属分类的对应关系。 输入没有标签的新数据后，将新数据的每个特征与样本集中的数据对应的特征比较，然后算法提取样本集中特征最相似数据(最近邻)的分类标签。 一般来说，我们只选择样本数据集中前K个最相似的数据，这就是k-近邻算法中的k的出处，通常k是不大于20的整数。 最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类 1.2、优点，缺点，适用范围优点：精度高、对异常值不敏感、无数据输入假定。 缺点：计算复杂度高、空间复杂度高。（每个测试用例都要计算与所有样本用例的每个特征值的距离） 适用范围：数值型和标称型 1.3、一般流程收集数据：可以使用任何方法。 准备数据：距离计算所需要的数值，最好是结构化的数据格式。 分析数据：可以使用任何方法。 训练算法：N/A 测试算法：计算错误率。 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类， 最后应用对计算出的分类执行后续的处理。 2、实现2.1、伪代码N/A 2.2、python实现12345678910111213141516171819202122232425262728293031323334from numpy import *import operatorfrom os import listdirdef classify0(inX, dataSet, labels, k): ''' kNN: k Nearest Neighbors Input: inX: vector to compare to existing dataset (1xN) dataSet: size m data set of known vectors (NxM) labels: data set labels (1xM vector) k: number of neighbors to use for comparison (should be an odd number) Output: the most popular class label ''' # 获取样本数，即M dataSetSize = dataSet.shape[0] # 将单个样本拉成M行矩阵，矩阵相减，得到测试用例特征值与每个样本用例的特征值的差 diffMat = tile(inX, (dataSetSize,1)) - dataSet # 特征值差的平方。此处是array sqDiffMat = diffMat**2 # 每个样本所有特征值差和 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 # 排序，按照数组所在的编号输出 sortedDistIndicies = distances.argsort() classCount=&#123;&#125; for i in range(k): # 获取前k个的标签 voteIlabel = labels[sortedDistIndicies[i]] # 计算相同标签数 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 # 按照标签个数排序 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] 3、总结k-近邻算法是分类数据最简单最有效的算法。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习15之Animation动画]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A015%E4%B9%8BAnimation%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npfrom matplotlib import animationfig,ax = plt.subplots()# 数据是一个0~2π内的正弦曲线x = np.arange(0,2*np.pi,0.1)y= np.sin(x)line, = ax.plot(x,y)# 采用np.pi*i/30 方式更新，更流畅def animate(i): line.set_ydata(np.sin(x+np.pi*i/30)) return line,def init(): line.set_ydata(np.sin(x)) return line,# https://matplotlib.org/api/animation_api.htmlani = animation.FuncAnimation(fig=fig,func=animate,frames=30,init_func=init,blit=True)# https://stackoverflow.com/questions/25140952/matplotlib-save-animation-in-gif-errorani.save('/home/xuleilx/workspace/github/github_pages/public/images/animation.gif', writer='imagemagick', fps=30)plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习14之次坐标轴]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A014%E4%B9%8B%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npx = np.arange(0,10,0.1)y1 = 0.05*x**2y2 = -1*y1# 获取figure默认的坐标系 ax1# fig,ax1 = plt.subplots()ax1 = plt.subplot()# 对ax1调用twinx()方法，生成如同镜面效果后的ax2ax2 = ax1.twinx()ax1.plot(x,y1,'g-')ax2.plot(x,y2,'b--')ax1.set_xlabel('X data')ax1.set_ylabel('Y1',color='g')ax2.set_ylabel('Y2',color='b')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subaxes.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习13之图中图]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A013%E4%B9%8B%E5%9B%BE%E4%B8%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfig = plt.figure()x = [1,2,3,4,5,6,7]y = [1,3,4,2,5,8,6]# 4个值都是占整个figure坐标系的百分比。在这里，假设figure的大小是10x10，# 那么大图就被包含在由(1, 1)开始，宽8，高8的坐标系内。left,bottom,width,height=0.1,0.1,0.8,0.8ax1 = fig.add_axes([left,bottom,width,height])ax1.plot(x,y,'r')ax1.set_xlabel('X')ax1.set_ylabel('Y')ax1.set_title('title')left,bottom,width,height=0.2,0.6,0.25,0.25ax2 = fig.add_axes([left,bottom,width,height])ax2.plot(y,x,'b--')ax2.set_xlabel('X')ax2.set_ylabel('Y')ax2.set_title('title inside 1')# 采用一种更简单方法，即直接往plt里添加新的坐标系left,bottom,width,height=0.6,0.2,0.25,0.25plt.axes([left,bottom,width,height])plt.plot(y[::-1],x,'g-.') # 注意对y进行了逆序处理plt.xlabel('X')plt.ylabel('Y')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/plotinplot.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习12之Subplot多合一显示2]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A012%E4%B9%8BSubplot%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA2%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspec# method 1:subplot2grid#############################plt.figure()ax1 = plt.subplot2grid((3,3),(0,0),colspan=3,rowspan=1)ax1.plot([1,2],[1,2])ax1.set_title('ax1_title')ax2 = plt.subplot2grid((3,3),(1,0),colspan=2)ax3 = plt.subplot2grid((3,3),(1,2),rowspan=2)ax4 = plt.subplot2grid((3,3),(2,0))ax5 = plt.subplot2grid((3,3),(2,1))# method 2:gridspec############################## plt.figure()# gs = gridspec.GridSpec(3,3)# ax1 = plt.subplot(gs[0,:])# ax2 = plt.subplot(gs[1,:2])# ax3 = plt.subplot(gs[1:,2])# ax4 = plt.subplot(gs[2,0])# ax5 = plt.subplot(gs[2,1])# method 3:easy to define structure############################## f,axes = plt.subplots(2,2,sharex=True)# axes[0,0].scatter([1,2],[1,2])plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subplot_method1.png")plt.tight_layout()plt.show() 结果：Method1:Method2:Method3:]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习12之Subplot多合一显示]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A012%E4%B9%8BSubplot%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfig = plt.figure()# 使用plt.subplot(2,1,1)将整个图像窗口分为2行1列, 当前位置为1.# 使用plt.plot([0,1],[0,1])在第1个位置创建一个小图.plt.subplot(211)plt.plot([0,1],[0,1])# 使用plt.subplot(2,3,4)将整个图像窗口分为2行3列, 当前位置为4.# 使用plt.plot([0,1],[0,2])在第4个位置创建一个小图.## 这里需要解释一下为什么第4个位置放第2个小图. 上一步中使用plt.subplot(2,1,1)将整个图像窗口分为2行1列,# 第1个小图占用了第1个位置, 也就是整个第1行. 这一步中使用plt.subplot(2,3,4)将整个图像窗口分为2行3列,# 于是整个图像窗口的第1行就变成了3列, 也就是成了3个位置, 于是第2行的第1个位置是整个图像窗口的第4个位置.plt.subplot(234)plt.plot([0,1],[0,2])plt.subplot(235)plt.plot([0,1],[0,3])plt.subplot(236)plt.plot([0,1],[0,4])plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subplot.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习11之3D图像]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A011%E4%B9%8B3D%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)# X,Y valuex = np.arange(-4,4,0.25)y = np.arange(-4,4,0.25)X,Y = np.meshgrid(x,y)# x-y 平面的网格R = np.sqrt(X**2+Y**2)# height valueZ = np.sin(R)# rstride 和 cstride 分别代表 row 和 column 的跨度ax.plot_surface(X,Y,Z,rstride=1,cstride=1,cmap='rainbow',edgecolor='black')# 添加 XY 平面的等高线ax.contourf(X,Y,Z,zdir='z',offset=-2,cmap='rainbow')ax.set_zlim(-2,2)plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/3d_data.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习9之Image图片]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A010%E4%B9%8BImage%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npa = np.linspace(0,1,9).reshape(3,3)# 三行三列的格子，a代表每一个值，图像右边有一个注释，白色代表值最大的地方，颜色越深值越小。plt.imshow(a,interpolation='nearest',cmap='bone',origin='lower')# 添加一个colorbar ，其中我们添加一个shrink参数，使colorbar的长度变短为原来的92%plt.colorbar(shrink=.92)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/image.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习9Contours等高线图]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A09%E4%B9%8BContours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npdef f(x,y): # the height function return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)n = 256x = np.linspace(-3,3,n)y = np.linspace(-3,3,n)# 编织成栅格X,Y = np.meshgrid(x,y)# use plt.contourf to filling contours# X,Y and value for (X,Y) pointplt.contourf(X,Y,f(X,Y),8,alpha=.75,cmap=plt.cm.hot)C = plt.contour(X,Y,f(X,Y),8,colors='black',linewidth=.5)# 添加label，隐藏坐标轴plt.clabel(C,inline=True,fontsize=10)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/contours.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习8之bar柱状图]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A08%E4%B9%8Bbar%E6%9F%B1%E7%8A%B6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npn = 10X = np.arange(n)# 均匀分布Y1 = (1-X/float(n))*np.random.uniform(0.5,1,n)Y2 = (1-X/float(n))*np.random.uniform(0.5,1,n)plt.bar(X,+Y1,facecolor='#9999ff',edgecolor='white')plt.bar(X,-Y2,facecolor='#ff9999',edgecolor='white')for x,y in zip(X,Y1): # ha: horizontal alignment # va: vertical alignment plt.text(x,y,'%.2f'%y,ha='center',va='bottom')for x,y in zip(X,Y2): plt.text(x,-y,'%.2f'%y,ha='center',va='top')#设置显示范围plt.xlim(-.5,n)plt.ylim(-1.25,1.25)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/bar_map.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习7之散点图]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A07%E4%B9%8B%E6%95%A3%E7%82%B9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npn = 1024# 高斯分布 http://blog.csdn.net/lanchunhui/article/details/50163669X = np.random.normal(0,1,n)Y = np.random.normal(0,1,n)T = np.arctan2(Y,X)# for color valueplt.scatter(X,Y,s=75,c=T,alpha=0.5)#设置显示范围plt.xlim(-1.5,1.5)plt.ylim(-1.5,1.5)# 去坐标plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/dot_map.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习6之tick能见度]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A06%E4%B9%8Btick%E8%83%BD%E8%A7%81%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y = 0.1*xplt.figure(num=1,figsize=(8,5))# 单纯直线plt.plot(x,y,linewidth=10,zorder=1)plt.ylim(-2,2)# gca = 'get current axis'# 移动坐标轴位置ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))# 当坐标轴的数字被遮挡时，调整线的透明度for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.7, zorder=2))plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/tick.png")#显示plt.show()]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习5之标注annotate]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A05%E4%B9%8B%E6%A0%87%E6%B3%A8annotate%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y = 2*x + 1plt.figure(num=1,figsize=(8,5))# 单纯直线plt.plot(x,y)# gca = 'get current axis'# 移动坐标轴位置ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))x0 = 1y0 = 2*x0+1# x:[x0,x0],y:[0,y0] 矩阵运算plt.plot([x0,x0],[0,y0],'k--',linewidth=2.5)# set dot stylesplt.scatter([x0,],[y0,],s=50,color='b')# 添加标注# method1plt.annotate(r'$2x+1=%s$'%y0, xy=(x0,y0), xycoords='data', xytext=(+30,-30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle='-&gt;', connectionstyle='arc3,rad=.2'))# method2plt.text(-1,3, r'$\mu\ \sigma_i\ \alpha_t$', fontdict=&#123;'size':16,'color':'r'&#125;)plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/annotation.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习4之legend]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A04%E4%B9%8Blegend%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])# 单纯直线l1, = plt.plot(x,y2,label='up')# 指定线的颜色, 宽度和类型l2, = plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--',label='bottom')plt.legend(handles=[l1,l2],labels=['aaa','bbb'],loc='best')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/legend.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习3之axis2]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A03%E4%B9%8Baxis2%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 单纯直线plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--')# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])# gca = 'get current axis'ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/axis_2.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习3之axis]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A03%E4%B9%8Baxis%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 单纯直线plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--')# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])#显示plt.show() 输出结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习2之figure]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A02%E4%B9%8Bfigure%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2# figure 3，指定figure的编号并指定figure的大小plt.figure(num=3,figsize=(8,5))plt.plot(x,y1)plt.figure(&quot;f2&quot;)plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color=&apos;red&apos;,linewidth=5.0,linestyle=&apos;--&apos;)#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习1之直线曲线]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A01%E4%B9%8B%E7%9B%B4%E7%BA%BF%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[代码： 1234567891011121314151617# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-1,1,50)#绘制直线y = x + 1plt.plot(x,y)#绘制曲线y = x**2plt.plot(x,y)#显示plt.show() 显示结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow学习之二次曲线]]></title>
    <url>%2F2017%2F12%2F17%2Ftensorflow%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#coding:utf-8import tensorflow as tfimport numpy as npimport matplotlib.pyplot as plt# 构造添加神经层的函数def add_layer(inputs,in_size,out_size,activation_function=None): # 权重，in_size*out_size随机变量矩阵 Weights = tf.Variable(tf.random_normal([in_size,out_size])) # 偏差，1*out_size数组。 # 在机器学习中，biases的推荐值不为0，这里是在0向量的基础上+0.1 biases = tf.Variable(tf.zeros([1,out_size])+0.1) # y = Weights*x+biases 。 tf.matmul()是矩阵的乘法 Wx_plus_b = tf.matmul(inputs,Weights)+biases # 如果没有定义激励函数就是线性函数 if activation_function is None: outputs = Wx_plus_b else: outputs = activation_function(Wx_plus_b) return outputs# 生成x的值,类似# [[-1. ]# [-0.5]# [ 0. ]# [ 0.5]# [ 1. ]]x_data = np.linspace(-1,1,300)[:,np.newaxis]# 加了一个noise,这样看起来会更像真实情况.类型与x_data一样noise = np.random.normal(0,0.05,x_data.shape)# y = x**2 - 0.5 + noisey_data = np.square(x_data)-0.5+noise# 利用占位符定义我们所需的神经网络的输入。# tf.placeholder()就是代表占位符，这里的None代表无论输入有多少都可以，# 因为输入只有一个特征，所以这里是1xs=tf.placeholder(tf.float32,[None,1])ys=tf.placeholder(tf.float32,[None,1])# inputLayer hideLayer outputLayer# 1 10 1# hideLayerl1 = add_layer(xs,1,10,activation_function=tf.nn.relu)# outputLayerpredition = add_layer(l1,10,1,activation_function=None)# 误差的平方和，再求平均loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys-predition),reduction_indices=[1]))train_step=tf.train.GradientDescentOptimizer(0.1).minimize(loss)init = tf.global_variables_initializer()sess = tf.Session()sess.run(init)# 绘图fig = plt.figure()ax = fig.add_subplot(1,1,1)ax.scatter(x_data,y_data)plt.ion()plt.show()for i in range(1000): sess.run(train_step,feed_dict=&#123;xs:x_data,ys:y_data&#125;) if i % 50 == 0: #print sess.run(loss,feed_dict=&#123;xs:x_data,ys:y_data&#125;) predition_value= sess.run(predition,feed_dict=&#123;xs:x_data&#125;) lines =ax.plot(x_data,predition_value,'r-',lw=5) plt.pause(0.5) ax.lines.remove(lines[0])# input() 学习的结果：]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[stm32mp157-TFTP环境搭建]]></title>
    <url>%2F2022%2F02%2F11%2Fstm32mp157-TFTP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[目的嵌入式开发，免不了需要修改kernel代码和设备树。如果每次更新都要重新烧录，既费时又费力。通常我们不需要修改uboot的代码，可以让uboot通过tftp下载我们的kernel和设备树到指定的地址然后启动Linux。 开发板网络环境搭建准备工作 电脑 开发板 网线 USB转网口网络拓扑结构VMWare设置USB转网口设备的连接状态，让设备连接到虚拟机TFTP 环境搭建TFTP 简介TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。我们可以使用 TFTP 来加载内核 zImage、设备树和其他较小的文件到开发板 DDR 上，从而实现网络挂载。搭建 TFTP安装和配置 xinetd执行以下指令，安装 xinetd。123456789101112131415161718$ sudo apt-get install xinetd$ sudo vi /etc/xinetd.conf$ cat /etc/xinetd.conf# Simple configuration file for xinetd## Some defaults, and include /etc/xinetd.d/defaults&#123;# Please note that you need a log_type line to be able to use log_on_success# and log_on_failure. The default is the following :# log_type = SYSLOG daemon info&#125;includedir /etc/xinetd.d TFTP 目录123$ mkdir -p /home/alex/linux/tftpboot#$ chmod 777 /home/alex/study/stm32mp157/tftpboot$ cd /home/alex/linux/ tftp-hpa 和 tftpd-hpa 服务程序1234567891011121314151617181920212223242526272829$ sudo apt-get install tftp-hpa tftpd-hpa$ sudo vi /etc/default/tftpd-hpa$ cat /etc/default/tftpd-hpa# /etc/default/tftpd-hpaTFTP_USERNAME="tftp"TFTP_DIRECTORY="/home/alex/study/stm32mp157/tftpboot"TFTP_ADDRESS=":69"TFTP_OPTIONS="--secure"$ sudo vi /etc/xinetd.d/tftp -p$ cat /etc/xinetd.d/tftpservice tftp&#123;protocol = udpport = 69socket_type = dgramwait = yesuser = rootserver = /usr/sbin/in.tftpdserver_args = -s /home/alex/study/stm32mp157/tftpboot -cdisable = noper_source = 11cps =100 2flags =IPv4&#125;$ sudo service tftpd-hpa restart$ sudo service xinetd restart 网络环境确保网络环境正常， Ubuntu和开发板能相互 ping 通。 开发板 IP： 192.168.10.50 虚拟机 IP： 192.168.10.100 电脑网口的 IP： 192.168.10.200 TFTP 测试在开发板文件系统执行以下指令设置开发板 IP，将虚拟机（192.168.10.100） TFTP 工作目录下的 test.c 文件拷贝到开发板中。123ifconfig eth0 192.168.10.50tftp -g -r test.c 192.168.10.100cat test.c TFTP 挂载内核和设备树启动开发板，进入 uboot 命令行界面，设置网络相关信息。 这里笔者 Ubuntu 的 IP 是192.168.1.208，给开发板设置的 IP 是 192.168.1.250，使用的是交换机连接开发板和电脑。123456setenv ipaddr 192.168.1.250setenv ethaddr 00:04:9f:04:d2:35setenv gatewayip 192.168.1.1setenv netmask 255.255.255.0setenv serverip 192.168.1.208saveenv 设置完后测试开发板和虚拟机的连接。1ping 192.168.1.208 确保网络正常后，设置 uboot 环境变量来挂载 Ubuntu 里 TFTP 目录下的内核和设备树。注意 - 符号为英文的，两边各有一个空格。（以下排版中用绿色着重空格，红色着重符号）1234setenv bootcmd 'tftp c2000000 uImage;tftp c4000000 stm32mp157d-atk.dtb;bootm c2000000 - c4000000'setenv bootargs 'console=ttySTM0,115200 root=/dev/mmcblk2p3 rootwait rw'saveenvboot Uboot恢复默认设置12env default -asaveenv]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>stm32mp157</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32mp157-LED点灯实验]]></title>
    <url>%2F2022%2F02%2F09%2Fstm32mp157-LED%E7%82%B9%E7%81%AF%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[实验内容 内核态编写字符驱动，实现对GPIO输出高低电平控制 用户态实现对字符设备读写，完成最终的点灯实验环境正点原子stm32mp157开发板实验步骤硬件原理图 可以看出， LED0 接到了 PI0 上， PI0 就是 GPIOI 组的第 0 个引脚，当 PI0 输出低电平(0)的时候发光二极管 LED0 就会导通点亮，当 PI0 输出高电平(1)的时候发光二极管LED0 不会导通，因此 LED0 也就不会点亮。所以 LED0 的亮灭取决于 PI0 的输出电平，输出 0 就亮，输出 1 就灭。 注意：PI0不要看错了，这个是GPIOI0 实验程序编写目录结构tree . ├── ledApp.c ├── led.c └── Makefile 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244#include &lt;linux/types.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/ide.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;asm/mach/map.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/io.h&gt;/***************************************************************Copyright © ALIENTEK Co., Ltd. 1998-2029. All rights reserved.文件名 : led.c作者 : 正点原子版本 : V1.0描述 : LED驱动文件。其他 : 无论坛 : www.openedv.com日志 : 初版V1.0 2020/11/23 正点原子团队创建***************************************************************/#define LED_MAJOR 200 /* 主设备号 */#define LED_NAME "led" /* 设备名字 */#define LEDOFF 0 /* 关灯 */#define LEDON 1 /* 开灯 *//* 寄存器物理地址 */#define PERIPH_BASE (0x40000000)#define MPU_AHB4_PERIPH_BASE (PERIPH_BASE + 0x10000000)#define RCC_BASE (MPU_AHB4_PERIPH_BASE + 0x0000)#define RCC_MP_AHB4ENSETR (RCC_BASE + 0XA28)#define GPIOI_BASE (MPU_AHB4_PERIPH_BASE + 0xA000)#define GPIOI_MODER (GPIOI_BASE + 0x0000)#define GPIOI_OTYPER (GPIOI_BASE + 0x0004)#define GPIOI_OSPEEDR (GPIOI_BASE + 0x0008)#define GPIOI_PUPDR (GPIOI_BASE + 0x000C)#define GPIOI_BSRR (GPIOI_BASE + 0x0018)/* 映射后的寄存器虚拟地址指针 */static void __iomem *MPU_AHB4_PERIPH_RCC_PI;static void __iomem *GPIOI_MODER_PI;static void __iomem *GPIOI_OTYPER_PI;static void __iomem *GPIOI_OSPEEDR_PI;static void __iomem *GPIOI_PUPDR_PI;static void __iomem *GPIOI_BSRR_PI;/* * @description : LED打开/关闭 * @param - sta : LEDON(0) 打开LED，LEDOFF(1) 关闭LED * @return : 无 */void led_switch(u8 sta)&#123; u32 val = 0; if (sta - '0' == LEDON) &#123; printk("LEDON\n"); val = readl(GPIOI_BSRR_PI); val |= (1 &lt;&lt; 16); writel(val, GPIOI_BSRR_PI); &#125; else if (sta - '0' == LEDOFF) &#123; printk("LEDOFF\n"); val = readl(GPIOI_BSRR_PI); val |= (1 &lt;&lt; 0); writel(val, GPIOI_BSRR_PI); &#125;&#125;/* * @description : 取消映射 * @return : 无 */void led_unmap(void)&#123; /* 取消映射 */ iounmap(MPU_AHB4_PERIPH_RCC_PI); iounmap(GPIOI_MODER_PI); iounmap(GPIOI_OTYPER_PI); iounmap(GPIOI_OSPEEDR_PI); iounmap(GPIOI_PUPDR_PI); iounmap(GPIOI_BSRR_PI);&#125;/* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量 * 一般在open的时候将private_data指向设备结构体。 * @return : 0 成功;其他 失败 */static int led_open(struct inode *inode, struct file *filp)&#123; return 0;&#125;/* * @description : 从设备读取数据 * @param - filp : 要打开的设备文件(文件描述符) * @param - buf : 返回给用户空间的数据缓冲区 * @param - cnt : 要读取的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 读取的字节数，如果为负值，表示读取失败 */static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)&#123; return 0;&#125;/* * @description : 向设备写数据 * @param - filp : 设备文件，表示打开的文件描述符 * @param - buf : 要写给设备写入的数据 * @param - cnt : 要写入的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 写入的字节数，如果为负值，表示写入失败 */static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)&#123; int retvalue; unsigned char databuf[128]; unsigned char ledstat; retvalue = copy_from_user(databuf, buf, cnt); if (retvalue &lt; 0) &#123; printk("kernel write failed!\r\n"); return -EFAULT; &#125; ledstat = databuf[0]; /* 获取状态值 */ led_switch(ledstat); return retvalue;&#125;/* * @description : 关闭/释放设备 * @param - filp : 要关闭的设备文件(文件描述符) * @return : 0 成功;其他 失败 */static int led_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;/* 设备操作函数 */static struct file_operations led_fops = &#123; .owner = THIS_MODULE, .open = led_open, .read = led_read, .write = led_write, .release = led_release,&#125;;/* * @description : 驱动出口函数 * @param : 无 * @return : 无 */static int __init led_init(void)&#123; int retvalue = 0; u32 val = 0; /* 初始化LED */ /* 1、寄存器地址映射 */ MPU_AHB4_PERIPH_RCC_PI = ioremap(RCC_MP_AHB4ENSETR, 4); GPIOI_MODER_PI = ioremap(GPIOI_MODER, 4); GPIOI_OTYPER_PI = ioremap(GPIOI_OTYPER, 4); GPIOI_OSPEEDR_PI = ioremap(GPIOI_OSPEEDR, 4); GPIOI_PUPDR_PI = ioremap(GPIOI_PUPDR, 4); GPIOI_BSRR_PI = ioremap(GPIOI_BSRR, 4); /* 2、使能PI时钟 */ val = readl(MPU_AHB4_PERIPH_RCC_PI); val &amp;= ~(0X1 &lt;&lt; 8); /* 清除以前的设置 */ val |= (0X1 &lt;&lt; 8); /* 设置新值 */ writel(val, MPU_AHB4_PERIPH_RCC_PI); /* 3、设置PI0通用的输出模式。*/ val = readl(GPIOI_MODER_PI); val &amp;= ~(0X3 &lt;&lt; 0); /* bit0:1清零 */ val |= (0X1 &lt;&lt; 0); /* bit0:1设置01 */ writel(val, GPIOI_MODER_PI); /* 3、设置PI0为推挽模式。*/ val = readl(GPIOI_OTYPER_PI); val &amp;= ~(0X1 &lt;&lt; 0); /* bit0清零，设置为上拉*/ writel(val, GPIOI_OTYPER_PI); /* 4、设置PI0为高速。*/ val = readl(GPIOI_OSPEEDR_PI); val &amp;= ~(0X3 &lt;&lt; 0); /* bit0:1 清零 */ val |= (0x2 &lt;&lt; 0); /* bit0:1 设置为10*/ writel(val, GPIOI_OSPEEDR_PI); /* 5、设置PI0为上拉。*/ val = readl(GPIOI_PUPDR_PI); val &amp;= ~(0X3 &lt;&lt; 0); /* bit0:1 清零*/ val |= (0x1 &lt;&lt; 0); /*bit0:1 设置为01*/ writel(val, GPIOI_PUPDR_PI); /* 6、默认关闭LED */ val = readl(GPIOI_BSRR_PI); val |= (0x1 &lt;&lt; 0); writel(val, GPIOI_BSRR_PI); /* 6、注册字符设备驱动 */ retvalue = register_chrdev(LED_MAJOR, LED_NAME, &amp;led_fops); if (retvalue &lt; 0) &#123; printk("register chrdev failed!\r\n"); goto fail_map; &#125; return 0;fail_map: led_unmap(); return -EIO;&#125;/* * @description : 驱动出口函数 * @param : 无 * @return : 无 */static void __exit led_exit(void)&#123; /* 取消映射 */ led_unmap(); /* 注销字符设备驱动 */ unregister_chrdev(LED_MAJOR, LED_NAME);&#125;module_init(led_init);module_exit(led_exit);MODULE_LICENSE("GPL");MODULE_AUTHOR("ALIENTEK");MODULE_INFO(intree, "Y"); Makefile123456789101112KERNELDIR := /home/alex/study/stm32mp157/01_Source_Code/01、正点原子Linux出厂系统源码/linux-5.4.31CURRENT_PATH := $(shell pwd)obj-m := led.obuild: kernel_moduleskernel_modules: $(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modulesclean: $(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean 编译makemake clean 运行测试将上一小节编译出来的 led.ko和 ledApp这两个文件拷贝到 rootfs/lib/modules/5.4.31 目录中，重启开发板，进入到目录 lib/modules/5.4.31 中，输入如下命令加载 led.ko 驱动模块：12depmod //第一次加载驱动的时候需要运行此命令modprobe led //加载驱动 驱动加载成功以后创建”/dev/led”设备节点，命令如下：1mknod /dev/led c 200 0 驱动节点创建成功以后就可以使用 ledApp 软件来测试驱动是否工作正常，输入如下命令打开 LED 灯：1echo 1 &gt; /dev/led //打开 LED 灯 输入上述命令以后观察开发板上的红色 LED 灯，也就是 LED0 是否点亮，如果点亮的话说明驱动工作正常。在输入如下命令关闭 LED 灯：1echo 0 &gt; /dev/led //关闭 LED 灯 输入上述命令以后观察开发板上的红色 LED 灯是否熄灭，如果熄灭的话说明我们编写的LED 驱动工作完全正常！至此，我们成功编写了第一个真正的 Linux 驱动设备程序。如果要卸载驱动的话输入如下命令即可：1modprobe -r led 经验总结难点主要在如何看《STM32MP157参考手册.pdf》，首先要找到外设基地址(0x40000000)，然后找到GPIOI(0x5000A000 - 0x5000A3FF)，需要了解STM32的GPIO的每个寄存器作用，如何控制高低电平输出。GPIO控制时序： 使能PI时钟 设置PI0通用的输出模式 设置PI0为推挽模式 设置PI0为高速 设置PI0为上拉 打开关闭LED 这些初始化时序可以百度STM32 GPIO寄存器操作时序，可以看厂商提供的源码中GPIO相关的内容]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>stm32mp157</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[inotify - monitoring filesystem events]]></title>
    <url>%2F2021%2F08%2F27%2Finotify-monitoring-filesystem-events%2F</url>
    <content type="text"><![CDATA[概论inotify是Linux中用于监控文件系统变化的一个框架，不同于前一个框架dnotify, inotify可以实现基于inode的文件监控。也就是说监控对象不再局限于目录，也包含了文件。不仅如此，在事件的通知方面，inotify摈弃了dnotify的信号方式，采用在文件系统的处理函数中放置hook函数的方式实现。 详细说明函数1234#include &lt;sys/inotify.h&gt;int inotify_init(void);int inotify_init1(int flags);int inotify_add_watch(int fd, const char *pathname, uint32_t mask);int inotify_rm_watch(int fd, int wd); 数据结构在inotify中，对于一个文件或目录的监控被称为一个watch。 给某一个文件或目录添加一个watch就表示要对该文件添加某一类型的监控。监控的类型由一个掩码Mask表示，mask有：1234567891011IN_ACCESS ： 文件的读操作IN_ATTRIB ： 文件属性变化IN_CLOSE_WRITE ： 文件被关闭之前被写IN_CLOSE_NOWRITE ： 文件被关闭IN_CREATE ： 新建文件IN_DELETE ： 删除文件IN_MODIFY ： 修改文件IN_MOVE_SELF ： 被监控的文件或者目录被移动IN_MOVED_FROM ： 文件从被监控的目录中移出IN_MOVED_TO ： 文件从被监控的目录中移入IN_OPEN ： 文件被打开 事件的类型有了，我们还需要一个结构体去表示一次事件， 在用户空间，inotify使用inotify_event表示一个事件，每一个事件都有一个特定的身份标示wd, wd是一个整型变量。每一个事件都有一组事件类型与其关联(IN_CREATE | IN_OPEN)。 事件中还应包含文件名。12345678struct inotify_event &#123; int wd; /* Watch deor */ uint32_t mask; /* Mask of events */ uint32_t cookie; /* Unique cookie associating related events (for rename(2)) */ uint32_t len; /* Size of name field */ char name[]; /* Optional null-terminated name */&#125;; 实例为了防止文件描述符fd的快速消耗，inotify提出了一个inotify instance(inotify实例)的概念。每一个inotify实例表示一个可读写的fd, 一个inotify实例链接有多个对于文件的watch。而函数inotify_init的工作就是生成一个inotify实例。 如何添加对于目标文件的watch呢？使用inotify_add_watch完成该任务，inotify_add_watch有三个参数，第一个参数是该watch所属的实例的fd, 第二个参数是被监控的文件名，第三个参数要监控的事件类型。 有添加就有删除, inotify_rm_watch(int fd, int wd)完成watch的删除工作，类似的, fd表示实例，wd表示即将删除的watch. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * @Author: lei.xu@ts * @Date: 2021-08-27 09:51:05 * @LastEditTime: 2021-08-27 10:07:10 * @LastEditors: your name * @Description: * @FilePath: /frameworks/tmp/123.c * Copyright ThunderSoft All rights reserved. */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/select.h&gt;#include &lt;errno.h&gt;#include &lt;sys/inotify.h&gt;static void _inotify_event_handler(struct inotify_event *event) //从buf中取出一个事件。&#123; printf("event-&gt;mask: 0x%08x\n", event-&gt;mask); printf("event-&gt;name: %s\n", event-&gt;name);&#125;int main(int argc, char **argv)&#123; if (argc != 2) &#123; printf("Usage: %s &lt;file/dir&gt;\n", argv[0]); return -1; &#125; unsigned char buf[1024] = &#123;0&#125;; struct inotify_event *event = NULL; int fd = inotify_init(); //初始化 int wd = inotify_add_watch(fd, argv[1], IN_ALL_EVENTS); //监控指定文件的ALL_EVENTS。 for (;;) &#123; fd_set fds; FD_ZERO(&amp;fds); FD_SET(fd, &amp;fds); if (select(fd + 1, &amp;fds, NULL, NULL, NULL) &gt; 0) //监控fd的事件。当有事件发生时，返回值&gt;0 &#123; int len, index = 0; while (((len = read(fd, &amp;buf, sizeof(buf))) &lt; 0) &amp;&amp; (errno == EINTR)) ; //没有读取到事件。 while (index &lt; len) &#123; event = (struct inotify_event *)(buf + index); _inotify_event_handler(event); //获取事件。 index += sizeof(struct inotify_event) + event-&gt;len; //移动index指向下一个事件。 &#125; &#125; &#125; inotify_rm_watch(fd, wd); //删除对指定文件的监控。 return 0;&#125; 从以上代码可以看出，inotify的使用很简单，由于一个inotify实例被抽象为一个文件，所以我们可以通过read函数直接读取其中的事件。详情可以man inotify。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg之数据结构]]></title>
    <url>%2F2021%2F04%2F06%2Fffmpeg%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[FFMpeg中关键数据结构之间的关系123456789101112131415161718graph LRA0[AVPacket]A[AVFormatContext] --&gt;B0[AVIOContext] subgraph 2[Protocol Layer] B0 --&gt; B1[URLContext] --&gt; B2[URLProtocol] endA --&gt; C0[AVInputFormat] subgraph 1[Format Layer] C0 endA --&gt; D0[&quot;AVStream[0]&quot;]A --&gt; E0[&quot;AVStream[1]&quot;] subgraph 3[Codec Layer] D0 --&gt; D1[AVCodecContext] --&gt; D2[AVCodec] E0 --&gt; E1[AVCodecContext] --&gt; E2[AVCodec] endA1[AVFrame] 每个AVStream存储一个视频/音频流的相关数据； 每个AVStream对应一个AVCodecContext，存储该视频/音频流使用解码方式的相关数据； 每个AVCodecContext中对应一个AVCodec，包含该视频/音频对应的解码器。 每种解码器都对应一个AVCodec结构。 数据结构的动态和静态关系URLProtocol和URLContext、AVInputFormat和AVFormatContext、AVCodec和AVCodecContext Context结构将多种类型的广义数据的共同部分抽象出来，着重于动态性，其核心成员只能在程序运行时动态确定其值。并且接口类的数据结构在运行时有多个实例，而相应的Context类只有一个实例，同时体现了数据结构的划分原则，如果有一对多的关系就要分开定义。 数据结构解析AVInputFormat/AVFormatContext/AVIContext分析AVInputFormat/AVFormatContext/AVIContext 三个结构体之间的关系。 AVFormatContext父类 AVInputFormat接口类，libavformat/avidec.c实现了avi封装器的接口。 AVIContext 子类，包含指向父类的指针以及子类特有属性。 AVFormatContext通过AVInputFormat调用avidec封装器的函数，设置AVIContext 特有属性和AVFormatContext通用属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// libavformat/avformat.htypedef struct AVFormatContext &#123; /** * The input container format. * * Demuxing only, set by avformat_open_input(). */ ff_const59 struct AVInputFormat *iformat; /** * The output container format. * * Muxing only, must be set by the caller before avformat_write_header(). */ ff_const59 struct AVOutputFormat *oformat; /** * Format private data. This is an AVOptions-enabled struct * if and only if iformat/oformat.priv_class is not NULL. * * - muxing: set by avformat_write_header() * - demuxing: set by avformat_open_input() */ void *priv_data; // AVIContext&#125; AVFormatContext;// AVInputFormat和AVOutputFormat是互斥的，同一个实例只能是其中一个。typedef struct AVInputFormat &#123; const AVClass *priv_class; ///&lt; AVClass for the private context&#125; AVInputFormat;static const AVInputFormat * const demuxer_list[] = &#123; &amp;ff_avi_demuxer,&#125;// libavformat/avidec.ctypedef struct AVIContext &#123; const AVClass *class;&#125; AVIContext;AVInputFormat ff_avi_demuxer = &#123; .name = "avi", .long_name = NULL_IF_CONFIG_SMALL("AVI (Audio Video Interleaved)"), .priv_data_size = sizeof(AVIContext), .extensions = "avi", .read_probe = avi_probe, .read_header = avi_read_header, .read_packet = avi_read_packet, .read_close = avi_read_close, .read_seek = avi_read_seek, .priv_class = &amp;demuxer_class,&#125;; URLProtocol/URLContext/AVIOContext/HTTPContextURLContext通过URLProtocol调用http的函数，设置HTTPContext特有属性和URLContext通用属性。 AVIOContext在此之上，包含了opaque指针，可以指向URLContext使用对应URL的实现，也可以自定义结构体，实现read、write等函数。 123456789101112131415161718192021222324// libavformat/url.htypedef struct URLContext &#123; const AVClass *av_class; /**&lt; information for av_log(). Set by url_open(). */ const struct URLProtocol *prot; // 广义输入文件 void *priv_data; // 文件句柄fd，网络通信socket等&#125; URLContext;typedef struct URLProtocol &#123; int (*url_open)( URLContext *h, const char *url, int flags); const AVClass *priv_data_class; int priv_data_size;&#125; URLProtocol;// libavformat/avio.htypedef struct AVIOContext &#123; void *opaque; // passed to the read/write/seek/...functions.&#125; AVIOContext;// opaque 来完成广义文件读写操作。 opaque 关联字段用于关联URLContext 结构，间接关联并扩展URLProtocol结构// libavformat/protocols.cconst URLProtocol *up = url_protocols[i];// libavformat/protocol_list.cstatic const URLProtocol * const url_protocols[] = &#123; &amp;ff_http_protocol,&#125;; AVCodec/AVCodecContext/MsrleContext分析AVCodec/AVCodecContext/MsrleContext三个结构体之间的关系。 AVCodecContext父类 AVCodec接口类，libavcodec/msrle.c实现了Msrle解码器的接口。 MsrleContext子类，包含指向父类的指针以及子类特有属性。 AVCodecContext通过AVCodec调用Msrle解码器的函数，设置MsrleContext特有属性和AVCodecContext通用属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef struct AVCodecContext&#123; // 类似父类 void *priv_data;// 子类的私有options，可以没有 const struct AVCodec *codec;&#125;AVCodecContext;// libavcodec/options.cs-&gt;priv_data= av_mallocz(codec-&gt;priv_data_size);*(const AVClass**)s-&gt;priv_data = codec-&gt;priv_class;// 获取AVCodecContext需要传入一个codec// dec_ctx = avcodec_alloc_context3(dec);typedef struct AVCodec &#123; // 类似接口 const AVClass *priv_class; int priv_data_size;&#125; AVCodec;// libavcodec/allcodecs.c 通过codec_id获取对应解码器的contextdec = avcodec_find_decoder(st-&gt;codecpar-&gt;codec_id);const AVCodec *c = codec_list[i];// libavcodec/codec_list.cstatic const AVCodec * const codec_list[] = &#123; &amp;ff_msrle_decoder,&#125;// libavcodec/msrle.c 具体的解码器的contexttypedef struct MsrleContext &#123; // 类似子类 AVCodecContext *avctx; // 类似父类，通用属性和函数 AVFrame *frame; GetByteContext gb; uint32_t pal[256]; // 私有属性&#125; MsrleContext;AVCodec ff_msrle_decoder = &#123; .name = "msrle", .long_name = NULL_IF_CONFIG_SMALL("Microsoft RLE"), .type = AVMEDIA_TYPE_VIDEO, .id = AV_CODEC_ID_MSRLE, .priv_data_size = sizeof(MsrleContext), .init = msrle_decode_init, .close = msrle_decode_end, .decode = msrle_decode_frame, .flush = msrle_decode_flush, .capabilities = AV_CODEC_CAP_DR1,&#125;; AVStream/AVIStream/AVCodecParametersAVStream 结构表示当前媒体流的上下文context， 着重于所有媒体流共有的属性(并且是在程序运行时才能确定其值)和关联其他结构的字段。 codecpar 字段关联当前音视频媒体使用的编解码器； priv_data 字段关联解析各个具体媒体流与文件容器有关的独有的属性；还有一些媒体帧索引和时钟信息 与之前两个不同，这类结构体没有定义函数，都是stream属性 12345678// demux时候获取streamavformat_open_input -&gt; s-&gt;iformat-&gt;read_header(s)) typedef struct AVStream &#123; void *priv_data; //AVIStream AVCodecParameters *codecpar;// 编码器的参数&#125; AVPacket/AVPacketList/AVFrame12345678910111213141516171819typedef struct AVPacket &#123; /** * A reference to the reference-counted buffer where the packet data is * stored. * May be NULL, then the packet data is not reference-counted. */ AVBufferRef *buf;&#125; AVPacket;// AVPacket 代表音视频数据帧，固有的属性是一些标记，时钟信息，和压缩数据首地址，大小等信息typedef struct AVPacketList &#123; AVPacket pkt; struct AVPacketList *next;&#125; AVPacketList;// AVPacketList 把音视频AVPacket 组成一个小链表typedef struct AVFrame &#123;&#125; AVFrame;// 解码后的一帧数据 AVUtil :工具类 AVLog：日志输出 AVOption (AVClass)：选项设置，用ffmpeg查询支持哪些AVOption。例如：ffmpeg -h filter=volume。 AVDictionary：键值对存储 ParseUtil：字符串解析 AVFilter：音视频滤镜]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg源码example解析之decode-audio]]></title>
    <url>%2F2021%2F03%2F24%2Fffmpeg%E6%BA%90%E7%A0%81example%E8%A7%A3%E6%9E%90%E4%B9%8Bdecode-audio%2F</url>
    <content type="text"><![CDATA[音频播放源码文件&lt;ffmpeg&gt;/doc/examples/decode_audio.c&lt;ffmpeg&gt;/doc/examples/muxing.c&lt;ffmpeg&gt;/doc/examples/resampling_audio.c&lt;ffmpeg&gt;/doc/examples/transcode_aac.c 代码调用流程代码流程跟《ffmpeg源码example解析之decode-video》基本类似，主要的区别是在播放上。对于播放器来说需要设置一套播放参数，比如：采样率，通道数，大小端，采样大小以及数据类型。理论上可以通过ffmpeg解析出来的的这些参数设置给播放器，但是ffmpeg的format的跟播放器的format不是同一个枚举，需要建立一个映射关系，所以觉得一般的播放器会统一设置成固定值，比如：采样率：44100，通道数：2，大小端：LittleEndian，采样大小：16bit，数据类型：有符号也就是说无论输入是什么配置参数，统一重采样成这套参数跟播放匹配。 项目该项目用于学习ffmpeg编解码使用qt主要是比较方便，后续采用glfw和sdl显示 源码地址https://github.com/xuleilx/MediaPlayer/tree/main/qt 功能描述播放视频 使用FFMpeg解码 使用sws_scale将FFMpeg解码后的yuv数据转换成rgb 使用QT的QLabel组件，通过QImage显示rgb数据 播放音频 使用FFMpeg解码 使用swr_convert将FFMpeg解码后的一帧数据转换成播放器指定的播放参数 使用QT的QAudioOutput播放pcm数据]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gstreamer]多媒体播放服务]]></title>
    <url>%2F2021%2F03%2F18%2FGstreamer-%E5%A4%9A%E5%AA%92%E4%BD%93%E6%92%AD%E6%94%BE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[项目介绍一直对多媒体感兴趣，跟着雷神的博客学了一段时间，感觉内力大增，苦于项目中多媒体模块不是我负责，有力气没地方使，于是有了此项目。 本来打算将这个工程用于项目中验证的，所以一开始没有开源。最近发现项目太多，没有精力上项目验证了，就开源吧。 功能 音乐、视频播放，暂停，快进，快退，seek等基本功能 获取音乐媒体文件id3信息 通过配置文件定制插件 源码https://github.com/xuleilx/MediaplayerServer 编译1234# mkdir build# cd build# cmake ../# make 运行1234567891011121314# 启动dbus服务export DBUS_SESSION_BUS_ADDRESS="unix:path=/run/dbus/session_bus_help"dbus-daemon --session --address=unix:path=/run/dbus/session_bus_help &amp;# 启动多媒体播放服务./mediaplayerserver &amp;# 查看所有接口dbus-send --session --print-reply --dest=com.hsae.mediaplayerserver.mediaplayer /com/hsae/mediaplayerserver org.freedesktop.DBus.Introspectable.Introspect # 设置播放文件dbus-send --session --print-reply --type=method_call --dest=com.hsae.mediaplayerserver.mediaplayer /com/hsae/mediaplayerserver com.hsae.mediaplayerserver.mediaplayer.setFile string:"/home/xuleilx/mywork/multimedia/video/AVC_high_1280x720_2013.mp4"# 播放dbus-send --session --print-reply --type=method_call --dest=com.hsae.mediaplayerserver.mediaplayer /com/hsae/mediaplayerserver com.hsae.mediaplayerserver.mediaplayer.start]]></content>
      <categories>
        <category>Gstreamer</category>
      </categories>
      <tags>
        <tag>Gstreamer</tag>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg源码example解析之decode_video]]></title>
    <url>%2F2021%2F03%2F17%2Fffmpeg%E6%BA%90%E7%A0%81example%E8%A7%A3%E6%9E%90%E4%B9%8Bdecode-video%2F</url>
    <content type="text"><![CDATA[视频解码流程源码文件&lt;ffmpeg&gt;/doc/examples/decode_video.c 代码调用流程 该流程并不是一个正常的流程，它假设了该文件是mpeg1video的编码格式，并且没有封装容器。通常情况下是需要解封装的，比如说拿到一个视频文件，并不知道是什么编码，这时候就需要解封装来了解容器里面数据流了。 首先我们先要了解ffmpeg的几个大类： AVFormat：封装、解封装、包含协议封装 AVCodec：编解码 AVFilter：音视频滤镜 swscale：视频图像转换 swresample：音频转换计算 AVUtil :工具类 视频解封装，解码，图像转换流程根据ffmpeg的几个大类，介绍解码视频并显示的一般流程和操作，序号为程序调用顺序 AVFormat：封装、解封装、包含协议封装解封装123456789101. avformat_alloc_context #封装结构体分配内存 // 可以不调用，avformat_open_input会判断入参是否为NULL，自行分配2. avformat_open_input #打开输入文件用于读取数据3. avformat_find_stream_info#获取流信息4. 针对每个stream处理 - pFormatContext-&gt;nb_streams - avcodec_find_decoder #根据流中的编码参数AVCodecParameters，查找是否支持该编码 - 判断流的类型 pLocalCodecParameters-&gt;codec_type - 保存AVCodecParameters和AVCodec，用于后续处理 9. av_read_frame #读取一包AVPacket数据包 AVCodec：编解码解码12345675. avcodec_alloc_context3 #编解码结构体分配内存6. avcodec_parameters_to_context#将解封装得到的编码参数AVCodecParameters赋值给编解码结构体7. avcodec_open2 #打开编码器10. avcodec_send_packet #将解封装中得到的AVPacket数据包送给解码器12. avcodec_receive_frame #读回一帧解码后的数据AVFrame AVPacket：压缩的数据包18. av_packet_alloc #压缩的数据包分配内存 swscale：视频图像转换12313. sws_getContext #给SwsContext结构体分配内存15. sws_scale #视频图像转换 AVUtil :工具类AVFrame：解码后的数据帧111. av_frame_alloc #解码后的数据帧分配内存 image114. av_image_alloc #分配内存用于存放一张图片 项目该项目用于学习ffmpeg编解码使用qt主要是比较方便，后续采用glfw和sdl显示 源码地址https://github.com/xuleilx/MediaPlayer/tree/main/qt 功能描述 使用FFMpeg解码 将FFMpeg解码后的yuv数据转换成rgb 使用QT的QLabel组件，通过QImage显示rgb数据]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[live555搭建rtsp服务器]]></title>
    <url>%2F2021%2F03%2F02%2Flive555%E6%90%AD%E5%BB%BArtsp%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[live555搭建rtsp直播或点播平台http://www.live555.com/ 编译123456wget http://www.live555.com/liveMedia/public/live555-latest.tar.gztar xzf live555-latest.tar.gzcd live./genMakefiles linux-64bit #注意后面这个参数是根据当前文件夹下config.&lt;后缀&gt;获取得到的makesudo make install 启动12345# 切换到存放视频文件的目录，运行服务videos$ su #切rootvideos$ live555MediaServer # 需要留意的是live555并不支持mp4格式，需要将mp4转为mkvffmpeg -i xxx.mp4 xxx.mkv 客户端播放12vlc rtsp://127.0.0.1/xxx.mkvffplay rtsp://127.0.0.1/xxx.mkv]]></content>
      <tags>
        <tag>rtsp</tag>
        <tag>live555</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频和音频编码原理]]></title>
    <url>%2F2021%2F02%2F28%2F%E8%A7%86%E9%A2%91%E5%92%8C%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[视频压缩编码和音频压缩编码的基本原理本文介绍一下视频压缩编码和音频压缩编码的基本原理。其实有关视频和音频编码的原理的资料非常的多，但是自己一直也没有去归纳和总结一下，在这里简单总结一下，以作备忘。 视频编码基本原理视频信号的冗余信息以记录数字视频的YUV分量格式为例，YUV分别代表亮度与两个色差信号。例如对于现有的PAL制电视系统，其亮度信号采样频率为13.5MHz；色度信号的频带通常为亮度信号的一半或更少，为6.75MHz或3.375MHz。以4：2：2的采样频率为例，Y信号采用13.5MHz，色度信号U和V采用6.75MHz采样，采样信号以8bit量化，则可以计算出数字视频的码率为：$$13.58 + 6.758 + 6.75*8= 216Mbit/s$$如此大的数据量如果直接进行存储或传输将会遇到很大困难，因此必须采用压缩技术以减少码率。数字化后的视频信号能进行压缩主要依据两个基本条件： 数据冗余 例如如空间冗余、时间冗余、结构冗余、信息熵冗余等，即图像的各像素之间存在着很强的相关性。消除这些冗余并不会导致信息损失，属于无损压缩。 视觉冗余 人眼的一些特性比如亮度辨别阈值，视觉阈值，对亮度和色度的敏感度不同，使得在编码的时候引入适量的误差，也不会被察觉出来。可以利用人眼的视觉特性，以一定的客观失真换取数据压缩。这种压缩属于有损压缩。 数字视频信号的压缩正是基于上述两种条件，使得视频数据量得以极大的压缩，有利于传输和存储。一般的数字视频压缩编码方法都是混合编码，即将变换编码，运动估计和运动补偿，以及熵编码三种方式相结合来进行压缩编码。通常使用变换编码来消去除图像的帧内冗余，用运动估计和运动补偿来去除图像的帧间冗余，用熵编码来进一步提高压缩的效率。下文简单介绍这三种压缩编码方法。 压缩编码的方法变换编码变换编码的作用是将空间域描述的图像信号变换到频率域，然后对变换后的系数进行编码处理。一般来说，图像在空间上具有较强的相关性，变换到频率域可以实现去相关和能量集中。常用的正交变换有离散傅里叶变换，离散余弦变换等等。数字视频压缩过程中应用广泛的是离散余弦变换。傅里叶分析 https://zhuanlan.zhihu.com/p/19763358?from=singlemessage&amp;isappinstalled=1离散余弦变换简称为DCT变换。它可以将LL的图像块从空间域变换为频率域。所以，在基于DCT的图像压缩编码过程中，首先需要将图像分成互不重叠的图像块。假设一帧图像的大小为1280720，首先将其以网格状的形式分成16090个尺寸为88的彼此没有重叠的图像块，接下来才能对每个图像块进行DCT变换。 经过分块以后，每个88点的图像块被送入DCT编码器，将88的图像块从空间域变换为频率域。下图给出一个实际8*8的图像块例子，图中的数字代表了每个像素的亮度值。从图上可以看出，在这个图像块中各个像素亮度值比较均匀，特别是相邻像素亮度值变化不是很大，说明图像信号具有很强的相关性。 一个实际88图像块* 下图是上图中图像块经过DCT变换后的结果。从图中可以看出经过DCT变换后，左上角的低频系数集中了大量能量，而右下角的高频系数上的能量很小。 图像块经过DCT变换后的系数 信号经过DCT变换后需要进行量化。由于人的眼睛对图像的低频特性比如物体的总体亮度之类的信息很敏感，而对图像中的高频细节信息不敏感，因此在传送过程中可以少传或不传送高频信息，只传送低频部分。量化过程通过对低频区的系数进行细量化，高频区的系数进行粗量化，去除了人眼不敏感的高频信息，从而降低信息传送量。因此，量化是一个有损压缩的过程，而且是视频压缩编码中质量损伤的主要原因。 量化的过程可以用下面的公式表示： 其中FQ（u,v）表示经过量化后的DCT系数；F（u,v）表示量化前的DCT系数；Q（u,v）表示量化加权矩阵；q表示量化步长；round表示归整，即将输出的值取为与之最接近的整数值。 合理选择量化系数，对变换后的图像块进行量化后的结果如图所示。 量化后的DCT系数 DCT系数经过量化之后大部分经变为0，而只有很少一部分系数为非零值，此时只需将这些非0值进行压缩编码即可。 熵编码熵编码是因编码后的平均码长接近信源熵值而得名。熵编码多用可变字长编码（VLC，Variable Length Coding）实现。其基本原理是对信源中出现概率大的符号赋予短码，对于出现概率小的符号赋予长码，从而在统计上获得较短的平均码长。可变字长编码通常有霍夫曼编码、算术编码、游程编码等。其中游程编码是一种十分简单的压缩方法，它的压缩效率不高，但编码、解码速度快，仍被得到广泛的应用，特别在变换编码之后使用游程编码，有很好的效果。 首先要在量化器输出直流系数后对紧跟其后的交流系数进行Z型扫描（如图箭头线所示）。Z型扫描将二维的量化系数转换为一维的序列，并在此基础上进行游程编码。最后再对游程编码后的数据进行另一种变长编码，例如霍夫曼编码。通过这种变长编码，进一步提高编码的效率。 运动估计和运动补偿运动估计（Motion Estimation）和运动补偿（Motion Compensation）是消除图像序列时间方向相关性的有效手段。上文介绍的DCT变换、量化、熵编码的方法是在一帧图像的基础上进行，通过这些方法可以消除图像内部各像素间在空间上的相关性。实际上图像信号除了空间上的相关性之外，还有时间上的相关性。例如对于像新闻联播这种背景静止，画面主体运动较小的数字视频，每一幅画面之间的区别很小，画面之间的相关性很大。对于这种情况我们没有必要对每一帧图像单独进行编码，而是可以只对相邻视频帧中变化的部分进行编码，从而进一步减小数据量，这方面的工作是由运动估计和运动补偿来实现的。 运动估计技术一般将当前的输入图像分割成若干彼此不相重叠的小图像子块，例如一帧图像的大小为1280720，首先将其以网格状的形式分成4045个尺寸为16*16的彼此没有重叠的图像块，然后在前一图像或者后一个图像某个搜索窗口的范围内为每一个图像块寻找一个与之最为相似的图像块。这个搜寻的过程叫做运动估计。通过计算最相似的图像块与该图像块之间的位置信息，可以得到一个运动矢量。这样在编码过程中就可以将当前图像中的块与参考图像运动矢量所指向的最相似的图像块相减，得到一个残差图像块，由于残差图像块中的每个像素值很小，所以在压缩编码中可以获得更高的压缩比。这个相减过程叫运动补偿。 由于编码过程中需要使用参考图像来进行运动估计和运动补偿，因此参考图像的选择显得很重要。一般情况下编码器的将输入的每一帧图像根据其参考图像的不同分成3种不同的类型：I（Intra）帧、B（Bidirection prediction）帧、P（Prediction）帧。如图所示。 典型的I，B，P帧结构顺序 如图所示，I帧只使用本帧内的数据进行编码，在编码过程中它不需要进行运动估计和运动补偿。显然，由于I帧没有消除时间方向的相关性，所以压缩比相对不高。P帧在编码过程中使用一个前面的I帧或P帧作为参考图像进行运动补偿，实际上是对当前图像与参考图像的差值进行编码。B帧的编码方式与P帧相似，惟一不同的地方是在编码过程中它要使用一个前面的I帧或P帧和一个后面的I帧或P帧进行预测。由此可见，每一个P帧的编码需要利用一帧图像作为参考图像，而B帧则需要两帧图像作为参考。相比之下，B帧比P帧拥有更高的压缩比。 混合编码上面介绍了视频压缩编码过程中的几个重要的方法。在实际应用中这几个方法不是分离的，通常将它们结合起来使用以达到最好的压缩效果。下图给出了混合编码（即变换编码+ 运动估计和运动补偿+ 熵编码）的模型。该模型普遍应用于MPEG1，MPEG2，H.264等标准中。 混合编码模型 从图中我们可以看到，当前输入的图像首先要经过分块，分块得到的图像块要与经过运动补偿的预测图像相减得到差值图像X，然后对该差值图像块进行DCT变换和量化，量化输出的数据有两个不同的去处：一个是送给熵编码器进行编码，编码后的码流输出到一个缓存器中保存，等待传送出去。另一个应用是进行反量化和反变化后的到信号X’，该信号将与运动补偿输出的图像块相加得到新的预测图像信号，并将新的预测图像块送至帧存储器。 音频编码基本原理音频信号的冗余信息数字音频信号如果不加压缩地直接进行传送，将会占用极大的带宽。例如，一套双声道数字音频若取样频率为44.1KHz，每样值按16bit量化，则其码率为：$$244.1kHz16bit=1.411Mbit/s$$如此大的带宽将给信号的传输和处理都带来许多困难，因此必须采取音频压缩技术对音频数据进行处理，才能有效地传输音频数据。 数字音频压缩编码在保证信号在听觉方面不产生失真的前提下，对音频数据信号进行尽可能大的压缩。数字音频压缩编码采取去除声音信号中冗余成分的方法来实现。所谓冗余成分指的是音频中不能被人耳感知到的信号，它们对确定声音的音色，音调等信息没有任何的帮助。 冗余信号包含人耳听觉范围外的音频信号以及被掩蔽掉的音频信号等。例如，人耳所能察觉的声音信号的频率范围为20Hz～20KHz，除此之外的其它频率人耳无法察觉，都可视为冗余信号。此外，根据人耳听觉的生理和心理声学现象，当一个强音信号与一个弱音信号同时存在时，弱音信号将被强音信号所掩蔽而听不见，这样弱音信号就可以视为冗余信号而不用传送。这就是人耳听觉的掩蔽效应，主要表现在频谱掩蔽效应和时域掩蔽效应，现分别介绍如下： 频谱掩蔽效应一个频率的声音能量小于某个阈值之后，人耳就会听不到，这个阈值称为最小可闻阈。当有另外能量较大的声音出现的时候，该声音频率附近的阈值会提高很多，即所谓的掩蔽效应。如图所示： 频率掩蔽效应 由图中我们可以看出人耳对2KHz～5KHz的声音最敏感，而对频率太低或太高的声音信号都很迟钝，当有一个频率为0.2KHz、强度为60dB的声音出现时，其附近的阈值提高了很多。由图中我们可以看出在0.1KHz以下、1KHz以上的部分,由于离0.2KHz强信号较远，不受0.2KHz强信号影响,阈值不受影响；而在0.1KHz～1KHz范围，由于0.2KHz强音的出现,阈值有较大的提升，人耳在此范围所能感觉到的最小声音强度大幅提升。如果0.1KHz～1KHz范围内的声音信号的强度在被提升的阈值曲线之下，由于它被0.2KHz强音信号所掩蔽，那么此时我们人耳只能听到0.2KHz的强音信号而根本听不见其它弱信号，这些与0.2KHz强音信号同时存在的弱音信号就可视为冗余信号而不必传送。 时域掩蔽效应当强音信号和弱音信号同时出现时，还存在时域掩蔽效应。即两者发生时间很接近的时候，也会发生掩蔽效应。时域掩蔽过程曲线如图所示，分为前掩蔽、同时掩蔽和后掩蔽三部分。 时域掩蔽效应 由图我们可以看出，时域掩蔽效应可以分成三种：前掩蔽，同时掩蔽，后掩蔽。前掩蔽是指人耳在听到强信号之前的短暂时间内，已经存在的弱信号会被掩蔽而听不到。同时掩蔽是指当强信号与弱信号同时存在时，弱信号会被强信号所掩蔽而听不到。后掩蔽是指当强信号消失后，需经过较长的一段时间才能重新听见弱信号，称为后掩蔽。这些被掩蔽的弱信号即可视为冗余信号。 压缩编码方法当前数字音频编码领域存在着不同的编码方案和实现方式, 但基本的编码思路大同小异, 如图所示。 数字音频编码系统模型 对每一个音频声道中的音频采样信号,首先都要将它们映射到频域中,这种时域到频域的映射可通过子带滤波器实现。每个声道中的音频采样块首先要根据心理声学模型来计算掩蔽门限值, 然后由计算出的掩蔽门限值决定从公共比特池中分配给该声道的不同频率域中多少比特数，接着进行量化以及编码工作，最后将控制参数及辅助数据加入数据之中，产生编码后的数据流。————————————————版权声明：本文为CSDN博主「雷霄骅」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/leixiaohua1020/article/details/28114081]]></content>
      <tags>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg指令汇总]]></title>
    <url>%2F2021%2F02%2F22%2Fffmpeg%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[ffmpeg常用命令ffmpeg --help大概分为6个部分，具体如下： ffmpeg信息查询部分 公共操作参数部分 文件主要操作参数部分 视频操作参数部分 音频操作参数部分 字母操作参数部分 查看支持的容器格式12345678910# 封装和解封装ffmpeg -formats# 解封装ffmpeg -demuxers# 封装ffmpeg -muxers# 查看FLV封装器的参数支持ffmpeg -h muxer=flv# 查看FLV解封装器的参数支持ffmpeg -h demuxer=flv 查看支持的编解码格式12345678910# 编解码ffmpeg -codecs# 解码ffmpeg -decoders# 编码ffmpeg -encoders# 查看H.264(AVC)的编码参数支持ffmpeg -h encoder=h264# 查看H.264(AVC)的解码参数支持ffmpeg -h decoder=h264 查看支持的滤镜1234# 滤镜ffmpeg -filters# 查看colorkey滤镜的参数支持ffmpeg -h filter=colorkey 转码123456ffmpeg -i WMV9_1280x720.wmv -vcodec mpeg4 -b:v 200 -r 15 -an output.mp4 # -i 文件 （后缀名）封装格式# -vcodec 视频编码格式# -b:v 视频码率# -r 视频帧率# -an 不包括音频 ffprobe常用命令-show_packets 查看多媒体数据包信息 字段 说明 codec_type 多媒体类型，如视频包、音频包等 stream_index 多媒体的stream索引 pts 多媒体的显示时间值 pts_time 根据不同格式计算过后的多媒体的显示时间 dts 多媒体解码时间值 dts_time 根据不同格式计算过后的多媒体的解码时间 duration 多媒体包占用的时间值 duration_time 根据不同格式计算过后的多媒体包所占用的时间值 size 多媒体包的大小 pos 多媒体包所在的文件偏移位置 flags 多媒体包标记，如关键包与非关键包的标记 -show_format 查看多媒体的封装格式 字段 说明 filename 文件名 nb_streams 媒体中包含的流的个数 nb_programs 节目数 format_name 使用的封装模块的名称 format_long_name 封装的完整名称 start_time 媒体文件的起始时间 duration 媒体文件的总时间长度 size 媒体文件的大小 bit_rate 媒体文件的码率 -show_frames 查看视频文件中的帧信息 属性 说明 值 media_type 帧的类型（视频、音频、字幕等） video stream_index 帧所在的索引区域 0 key_frame 是否为关键帧 1 pkt_pts Frame包的pts 0 pkt_pts_time Frame包的pts的时间显示 0.080000 pkt_dts Frame包的dts 80 pkt_dts_time Frame包的dts的时间显示 0.080000 pkt_duration Frame包的时长 N/A pkt_duration_time Frame包的时长时间显示 N/A pkt_pos Frame包所在文件的偏移位置 344 width 帧显示的宽度 1280 height 帧显示的高度 714 pix_fmt 帧的图像色彩格式 yuv420p pict_type 帧类型 I -show_streams 查看多媒体文件中的流信息 属性 说明 值 index 流所在的索引区域 0 codec_name 编码名 h264 codec_long_name 编码全名 MPEG-4 part 10 profile 编码的profile High level 编码的level 31 has_b_frames 包含B帧信息 2 codec_type 编码类型 video codec_time_base 编码的时间戳计算基础单位 1/50 pix_fmt 图像显示的色彩格式 yuv420p coded_width 图像的宽度 1280 coded_height 图像的高度 714 codec_tag_string 编码的标签数据 [0][0][0][0] r_frame_rate 实际帧率 25/1 avg_frame_rate 平均帧率 25/1 time_base 时间基数（用来进行timestamp计算） 1/1000 bit_rate 码率 200000 max_bit_rate 最大码率 N/A nb_frames 帧数 N/A -printf_format或-of 格式化输出支持XML、INI、JSON、CSV、FLAT等ffplay可视化Visualize information exported by some codecs. http://ffmpeg.org/ffmpeg-all.html#codecview https://trac.ffmpeg.org/wiki/Debug/MacroblocksAndMotionVectors 1ffmpeg -h filter=codecview Visualize forward predicted MVs of all frames using 1ffplay -flags2 +export_mvs input.mp4 -vf codecview=mv_type=fp Visualize multi-directionals MVs of P and B-Frames using 1ffplay -flags2 +export_mvs input.mp4 -vf codecview=mv=pf+bf+bb ffmpeg转封装格式 需要知道 源容器 和 目标容器 的可容纳的编码格式 编码格式如果相互兼容，可以用-c copy拷贝原有的stream ffmpeg -i input.mp4 -c copy -f flv output.flv 编码格式如果不兼容，需要转化成目标文件支持的编码 ffmpeg -i input_ac3.mp4 -vcodec copy -acodec aac -f flv output.flv HLS FFmpeg转HLS举例常规的从文件转换HLS直播时：12ffmpeg -re -i input.mp4 -c copy -f hls -bsf:v h264_mp4toannexb output.m3u8# -bsf:v h264_mp4toannexb 作用是将MP4中的H.264数据转换成H.264 AnnexB标准编码，AnnexB标准的编码常见于实时传输流中 如果源文件为FLV、TS等可以作为直播传输流的视频，则不需要这个参数。 ffmpeg推流上传HLS相关的M3U8以及TS文件Nginx配置webdav模块1ffmpeg -re -i input.mp4 -c copy -f hls -hls_time 3 -hls_list_size 0 -method PUT -t 30 http://127.0.0.1/test/output.m3u8 音视频文件音视频流抽取 FFmpeg抽取音视频文件中的AAC音频流ffmpeg -i input.mp4 -vn -acodec copy output.aac FFmpeg抽取音视频文件中的H.264视频流ffmpeg -i input.mp4 -vcodec copy -an output.h264 FFmpeg抽取音视频文件中的H.265视频流(前提文件视频编码格式为hevc)ffmpeg -i input.mp4 -vcodec copy -an -bsf hevc_mp4toannexb -f hevc output.hevcffmpeg转码 h264转h265(HEVC)ffmpeg -i input.mp4 -c:v libx265 -vtag hvc1 h265_output.mp4 aac转MP3(需要安装libmp3lame)ffmpeg -i AVC_high_1280x720_2013.mp4 -vn -acodec libmp3lame -f mp3 out.mp3 x264安装12345$git clone git://git.videolan.org/x264.git$cd x264$./configure –enable-shared $make$sudo make install 查看 x264 --full help 设置编码参数 编码器预设参数设置preset 通常通过preset来设置编码的速度，影响清晰度 ffmpeg -i input.mp4 -vcodec libx264 -preset ultrafast -b:v 2000k output.mp4 H.264编码优化参数tune 在使用ffmpeg与x264进行H.264直播编码并进行推流时，只用tune参数的zerolatency将会提升效率，因为其降低了因编码导致的延迟。 H.264的profile与level设置 baseline profile编码的H.264视频不会包含B Slice，而使用main profile、high profile编码出来的视频，均可以包含B Slice ffmpeg -i input.mp4 -vcodec libx264 -profile:v baseline -level 3.1 -s 352x288 -an -y -t 10 output_baseline.ts ffmpeg -i input.mp4 -vcodec libx264 -profile:v high -level 3.1 -s 352x288 -an -y -t 10 output_high.ts 查看包含B帧的情况： ffprobe -v quiet -show_frames -select_streams v output_baseline.ts | grep &quot;pict_type=B&quot; | wc -l 当进行实时流媒体直播时，采用baseline编码相对main或high的profile会更可靠些。 控制场景切花关键帧插入参数 sc_thresholdffmpeg通过-g参数设置以帧数间隔为GOP的长度，但是当遇到场景切换时，例如从一个画面突然变成另一个画面时，会强行插入一个关键帧，这是GOP的间隔将会重新开始，可以通过使用sc_threshold参数进行设定以决定是否在场景切换时插入关键帧。ffmpeg命令控制编码时的GOP大小ffmpeg -i AVC_high_1280x720_2013.mp4 -c:v libx264 -g 50 -t 60 output.mp4为了使得GOP的插入更加均匀，使用参数 sc_thresholdffmpeg -i AVC_high_1280x720_2013.mp4 -c:v libx264 -g 50 -sc_threshold 0 -t 60 -y output.mp4 设置x264内部参数x264opts去掉B帧ffmpeg -i input.mp4 -c:v libx264 -x264opts &quot;bframes=0&quot; -g 50 -sc_threshold 0 output.mp4控制I帧、P帧、B帧的频率与规律例如设置GOP中，每2个P帧之间存放3个B帧：ffmpeg -i input.mp4 -c:v libx264 -x264opts &quot;bframes=3:b-adapt=0&quot; -g 50 -sc_threshold 0 output.mp4 CBR 恒定码率设置参数 nal-hrd （固定码率好处，可能是网络传输）VBR：可变码率CBR：恒定码率ABR：平均码率。VBR和CBR混合产物。123456789ffmpeg -i input.mp4 -c:v libx264 -x264opts "bframes=10:b-adapt=0" -b:v 1000k -maxrate 1000k -minrate 1000k -bufsize 50k -nal-hrd cbr -g 50 -sc_threshold 0 output.ts# 设置B帧的个数，并且是每2个P帧之间包含10个B帧# 设置视频码率为 1000 kbit/s# 设置最大码率为 1000 kbit/s# 设置最小码率为 1000 kbit/s# 设置编码的buffer大小为 50KB# 设置 H.264 的编码HRD信号形式为 CBR# 设置每50帧一个GOP# 设置场景切换不强行插入关键帧 MP3/AAC MP3转码ffmpeg -i INPUT -acodec libmp3lame output.mp3 参数控制123456# -q 控制码率(0~9) 高-&gt;低ffmpeg -i input.mp3 -acodec libmp3lame -q:a 8 output.mp3# -b 设置为CBRffmpeg -i input.mp3 -acodec libmp3lame -b:a 64k output.mp3# -abr 设置为abr编码ffmpeg -i input.mp3 -acodec libmp3lame -b:a 64k -abr 1 output.mp3 ffmpeg流媒体ffmpeg发布与录制RTMP流FFmpeg操作RTMP的参数 参数 类型 说明 rtmp_app 字符串 RTMP流发布点，又称为APP rtmp_buffer 整数 客户端buffer大小（单位：毫秒），默认为3秒 rtmp_conn 字符串 在RTMP的Connect命令中增加自定义AMF数据 rtmp_flashver 字符串 设置模拟的flashplugin的版本号 rtmp_live 整数 指定RTMP流媒体播放类型，具体如下：- any：直播或点播 - live：直播 - recorded：点播 rtmp_pageurl 字符串 RTMP在Connect命令中设置的PageURL字段，其为播放时所在的Web页面URL rtmp_playpath 字符串 RTMP流播放的Stream地址，或者成为秘钥，或者成为发布流 rtmp_subscribe 字符串 直播名称，默认设置为rtmp_playpath的值 rtmp_swfhash 二进制 解压swf文件后的SHA256的hash值 rtmp_swfsize 整数 swf文件解压后的大小，用于swf认证 rtmp_swfurl 字符串 RTMP的Connect命令中设置的swfURL播放器的URL rtmp_swfverify 字符串 设置swf认证时swf文件的URL地址 rtmp_tcurl 字符串 RTMP的Connect命令中设置的tcURL目标发布点地址，一般形如 rtmp://xxx.xxx.xxx/app rtmp_listen 整数 开启RTMP服务时所监听的端口 listen 整数 与rtmp_listen相同 timeout 整数 监听rtmp端口时设置的超时时间，以秒为单位 rtmp_app、rtmp_playpath 参数 通过rtmp_app、rtmp_playpath参数设置rtmp的推流发布点 ffmpeg -re -i AVC_high_1280x720_2013.mp4 -c copy -f flv -rtmp_app live -rtmp_playpath play rtmp://127.0.0.1 等价于 ffmpeg -re -i AVC_high_1280x720_2013.mp4 -c copy -f flv rtmp://127.0.0.1/live/play ffmpeg录制RTSP流 FFmpeg操作RTSP的参数 参数 类型 说明 initial_pause 布尔 建立连接后暂停播放 rtsp_transport 标记 设置RTSP传输协议，具体如下：- udp：UDP- tcp：TCP-udp_multicast：UDP多播协议- http：HTTP隧道 rtsp_flags 标记 RTSP使用标记，具体如下：- filter_src：只接收指定IP的流- listen：设置为被动接收模式- prefer_tcp：TCP亲和模式，如果TCP可用则首选TCP传输 allowed_media_types 标记 设置允许接收的数据模式（默认全部开启），具体如下：- video：只接收视频- audio：只接收音频- data：只接收数据- subtitle：只接收字幕 min_port 整数 设置最小本地UDP端口，默认为5000 max_port 整数 设置最大本地UDP端口，默认为65000 timeout 整数 设置监听端口超时时间 reorder_queue_size 整数 设置录制数据Buffer的大小 buffer_size 整数 设置底层传输包Buffer的大小 user-agent 字符串 用户客户端标识 TCP方式录制RTSP直播流 ffmpeg默认使用的rtsp拉流方式为UDP，为了避免丢包导致的花屏、绿屏、灰屏、马赛克等问题，将UDP改为TCP传输： ffmpeg -rtsp_transport tcp -i rtsp://127.0.0.1/test.mkv -c copy -f mp4 output.mp4 User-Agent设置参数ffmpeg -user-agent &quot;Alex-Player&quot; -i rtsp://input:554/live/1/stream.sdp -c copy -f mp4 -u output.mp4FFmpeg录制HTTP流 FFmpeg操作HTTP的参数 参数 类型 说明 seekable 布尔 设置HTTP连接为可seek操作 chunked_post 布尔 使用Chunked模式post数据 http_proxy 字符串 设置HTTP代理传输数据 headers 字符串 自定义HTTP Header数据 content_type 字符串 设置POST的内容类型 user_agent 字符串 设置HTTP请求客户端信息 multiple_requests 布尔 HTTP长连接开启 post_data 二进制 设置将要POST的数据 cookies 字符串 设置HTTP请求时写代码的Cookies icy 布尔 请求ICY源数据：默认开关 auth_type 整数 HTTP验证类型设置 offset 整数 初始化HTTP请求时的偏移位置 method 字符串 发起HTTP请求时使用的HTTP的方法 reconnect 布尔 在EOF之前断开发起重连 reconnect_at_eof 布尔 在得到EOF时发起重连 reply_code 整数 作为HTTP服务时向客户端反馈状态码 FFmpeg录制和发布TCP与UDP流略 FFmpeg推多路流 推流（tee协议输出多路流）ffmpeg -re -i AVC_high_1280x720_2013.mp4 -vcodec libx264 -acodec aac -map 0 -f flv &quot;tee:rtmp://127.0.0.1/live/p1|rtmp://127.0.0.1/live/p2&quot; 验证ffmpeg -i rtmp://127.0.0.1/live/p1 -i rtmp://127.0.0.1/live/p2 ffmpeg滤镜使用http://ffmpeg.org/ffmpeg-filters.html FFmpeg滤镜Filter描述格式 FFmpeg滤镜Filter的参数排列方式[输入流或标记]滤镜参数[临时标记名];[输入流或标记]滤镜参数[临时标记名]…输入两个文件，一个视频，一个图片，将logo进行缩放，然后放在视频的左上角： 12ffmpeg -i input.mp4 -i input.jpg -filter_complex " [1:v] scale=176:144[logo];[0:v][logo]overlay=x=0:y=0" output.mp4# [0:v]/[1:v]代表第几个输入的视频 FFmpeg为视频加水印 drawtext滤镜 1234567ffmpeg -h filter=drawtext# 文字水印ffmpeg -i input.mp4 -ss 50 -vf "drawtext=fontsize=100:fontfile=/usr/share/fonts/truetype/freefont/FreeSerif.ttf :text='Hello World':fontcolor='yellow':x=20:y=20" output.mp4# 动态日期ffmpeg -i input.mp4 -ss 50 -vf "drawtext=fontsize=100:fontfile=/usr/share/fonts/truetype/freefont/FreeSerif.ttf :text='%&#123;localtime\:%Y\-%m\-%d %H-%M-%S&#125;':fontcolor='yellow':x=20:y=20" output.mp4# 闪烁ffmpeg -i input.mp4 -ss 50 -vf "drawtext=fontsize=100:fontfile=/usr/share/fonts/truetype/freefont/FreeSerif.ttf :text='%&#123;localtime\:%Y\-%m\-%d %H-%M-%S&#125;':fontcolor='yellow':x=20:y=20:enable=lt(mod(t\,3)\,1)" output.mp4 movie滤镜 1234# 图片水印ffmpeg -i input.mp4 -vf "movie=logo.png[wm];[in][wm]overlay=30:10[out]" output.mp4# colorkey 半透明ffmpeg -i input.mp4 -ss 55 -vf "movie=../picture/3d_data.png,colorkey=black:1.0:0.1[wm];[in][wm]overlay=30:10[out]" output.mp4 overlay滤镜 12345678910111213141516# 画中画ffmpeg -re -i input.mp4 -vf "movie=sub.mp4,scale=480x320[test];[in][test]overlay[out]" -vcodec libx264 output.flv# 跑马灯ffmpeg -re -i input.mp4 -vf "movie=sub.wmv,scale=480x320[test];[in][test]overlay=x='if(gte(t,2), -w+(t-2)*50, NAN)':y=0[out]" -vcodec libx264 output.flv# 视频多宫格处理ffmpeg -i input1.mp4 -i input2.mp4 -i input3.mp4 -i input4.mp4 -filter_complex "nullsrc=size=1280x720 [background];[0:v] setpts=PTS-STARTPTS, scale=640x360 [upleft];[1:v] setpts=PTS-STARTPTS, scale=640x360 [upright];[2:v] setpts=PTS-STARTPTS, scale=640x360 [downleft];[3:v] setpts=PTS-STARTPTS, scale=640x360 [downright];[background][upleft] overlay=shortest=1 [background+upleft];[background+upleft][upright] overlay=shortest=1:x=640 [background+up];[background+up][downleft] overlay=shortest=1:y=360 [background+up+downleft];[background+up+downleft][downright] overlay=shortest=1:x=640:y=360" output.mp4 FFmpeg音频流滤镜操作 双声道合并单声道fmpeg -i input.mp3 -ac 1 output.mp3 双声道提取 map_channelffmpeg -i input.mp3 -map_channel 0.0.0 left.mp3 -map_channel 0.0.1 right.mp3 panffmpeg -i input.mp3 -filter_complex &quot;[0:0]pan=1c|c0=c0[left];[0:0]pan=1c|c0=c1[right]&quot; -map &quot;[left]&quot; left.mp3 -map &quot;[right]&quot; right.mp3 双声道转双音频流123ffmpeg -i input.mp4 -filter_complex channelsplit=channel_layout=stereo output.mkaffprobe output.mka# 可以看到有两个stream 不常用，大多数播放器也只会播放第一个流 单声道转双声道ffmpeg -i left.aac -ac 2 output.m4a这样的双声道并不是真正的双声道，而是单声道处理成的多声道，效果不会比原来多声道效果好 两个音频源合并双声道ffmpeg -i left.mp3 -i right.mp3 -filter_complex &quot;[0:a][1:a]amerge=inputs=2[aout]&quot; -map &quot;[aout]&quot; output.mka 多个音频合并为多声道ffmpeg -i front_left.wav -i front_right.wav -i front_center.wav -i lfe.wav -i back_left.wav -i back_right.wav -filter_complex &quot;[0:a][1:a][2:a][3:a][4:a][5:a]amerge=inputs=6[aout]&quot; -map &quot;[aout]&quot; output.wavFFmpeg音频音量探测 音频音量获得ffmpeg -i input.wav -filter_complex volumedetect -f null - 绘制音频波形123ffmpeg -i input.wav -filter_complex "showwavespic=s=640x120" -frames:v 1 output.png# 不通声道的波形图ffmpeg -i input.wav -filter_complex "showwavespic=s=640x120:split_channels=1" -frames:v 1 output.png FFmpeg为视频加字母 ASS字母流写入视频流ffmpeg -i input.mp4 -vf ass=t1.ass -f mp4 output.mp4 ASS字母流写入封装容器1234ffmpeg -i input.mp4 -vf ass=t1.ass -acodec copy -vcodec copy -scodec copy output.mp4# 输入的视频文件汇总原本同样带有字幕流，希望使用t1.ass字幕流，通过map写入# 下面命令会分别将第一个输入文件的第一个流和第二个流与第二个输入文件的第一个流写入output.mkvffmpeg -i input.mp4 -i t1.ass -map 0:0 -map 0:1 -map 1:0 -acodec copy -vcodec copy -scodec copy output.mkv FFmpeg视频抠图合并 chromakey 抠图和背景视频合并的操作12345# 查询颜色支持ffmpeg -colors# chromakey滤镜将绿色背景中的人物抠出来，贴到input.mp4为背景的视频中ffmpeg -i input.mp4 -i input_green.mp4 -filter_complex "[1:v]chromakey=Green:0.1:0.2[ckout];[0:v][ckout]overlay[out]" -map "[out]" output.mp4# FFmpeg中除了有chromakey滤镜外，还有colorkey参数，chromakey滤镜主要用于YUV数据，所以一般来说做绿幕处理更有优势；而colorkey处理纯色均可以，因为colorkey主要用于RGB数据。 FFmpeg 3D视频处理 stereo3d滤镜1234# 黄蓝ffplay -vf "stereo3d=sbsl:aybd" AVC_high_1280x720_2013.mp4# 红蓝ffplay -vf "stereo3d=sbsl:aybg" AVC_high_1280x720_2013.mp4 FFmpeg定时视频截图 vframe参数截取一张图片ffmpeg -i input.flv -ss 00:00:7.435 -vframes 1 output.png fps滤镜定时获得图片123456# 每隔1秒钟生成一张PNG图片ffmpeg -i input.flv -vf fps=1 out%d.png# 每隔一封中生成一张jpg图片ffmpeg -i input.flv -vf fps=1/60 out%d.jpg# select 按照关键帧截取图片ffmpeg -i input.flv -vf "select='eq(pict_type,PICT_TYPE_I)'" -vsync vfr thumb%04d.png FFmpeg 生成测试源数据 音频测试流lavfi 模拟音频源的abuffer、aevalsrc、anullsrc、flite、anoisesrc、sine滤镜生成音频流 1234# 白噪声ffmpeg -re -f lavfi -i aevalsrc="-2+random(0)" -t 5 output.mp3# 正弦波ffmpeg -re -f lavfi -i "sine" -t 5 output.mp3 视频测试流通过FFmpeg模拟多种视频源：allrgb、allyuv、color、haldclutsrc、nullsrc、rgbtestsrc、smptebars、smptehdbars、testsrc、testsrc2、yuvtestsrc 123456# 生成长度为5.3秒、图像大小为QCIF分辨率、帧率为25fps的视频图像数据，并编码成H.264ffmpeg -re -f lavfi -i testsrc=duration=5.3:size=qcif:rate=25 -vcodec libx264 -r:v 25 output.mp4# 纯红ffmpeg -re -f lavfi -i color=c=red@0.2:s=qcif:r=25 -vcodec libx264 -r:v 25 output.mp4# 随机雪花ffmpeg -re -f lavfi -i "nullsrc=s=256x256,geq=random(1)*255:128:128" -vcodec libx264 -r:v 25 output.mp4 FFmpeg对音视频倍速处理 atempo音频倍速处理取值范围：0.5 ~ 2.0 12# 半速处理ffmpeg -i input.wav -filter_complex "atempo=tempo=0.5" -acodec aac output.aac setpts视频倍速处理使用PTS控制播放速度的 12# 半速处理ffmpeg -re -i input.mp4 -filter_complex "setpts=PTS*2" output.mp4 ffmpeg采集设备 Linux下查看设备列表ffmpeg -h demuxer=fbdev Linux采集设备fbdevFrameBuffer是一个比较有年份的设备，专门用于图像展示操作，早期的图形界面也是基于FrameBuffer进行绘制的，有时在向外界展示Linux的命令行操作又不希望别人看到你的桌面时，可以通过获取FrameBuffer设备图像数据进行编码后推流或录制： 123ffmpeg -framerate 30 -f fbdev -i /dev/fb0 output.mp4# ctrl+alt+F1 进入命令行界面# ctrl+alt+F7 进入图形界面 Linux采集设备v4l2v4l2主要用来采集摄像头，而摄像头通常支持多种像素格式，有些摄像头还支持直接输出已经编码好的H.264数据 查看参数ffmpeg -h demuxer=v4l2 查看v4l2摄像头锁支持的色彩格式及分辨率ffmpeg -hide_banner -f v4l2 -list_formats all -i /dev/vide0 采集摄像头ffmpeg -hide_banner -s 1920x1080 -i /dev/vide0 output.avi Linux采集设备x11grab Linux下面采集桌面图像时，通常采用x11grab设备采集图像，输入设备的设备名规则： [主机名]:显示编号id.屏幕编号id[+起始x轴,起始y轴]1234567# 桌面录制(帧率:25,图像分辨率:1366x768,采集的设备:0.0)ffmpeg -f x11grab -framerate 25 -video_size 1366x768 -i :0.0 out.mp4# 桌面录制指定起始位置(:0.0+300,200 指定了x坐标300,y坐标200)# 注意:video_size不要超过实际采集区域的大小ffmpeg -f x11grab -framerate 25 -video_size 352x288 -i :0.0+300,200 out.mp4# 桌面录制带鼠标记录的视频ffmpeg -f x11grab -video_size 1366x768 -follow_mouse 1 -i :0.0 out.mp4 其他x265安装 下载网站1：http://www.videolan.org/developers/x265.htmlhg clone http://hg.videolan.org/x265网站2：https://bitbucket.org/multicoreware/x265hg clone https://bitbucket.org/multicoreware/x265 编译12345sudo apt-get install mercurial cmake cmake-curses-gui build-essential yasmcd x265/build/linux./make-Makefiles.bashmakesudo make install DTS、PTS 的概念DTS、PTS 的概念如下所述： DTS（Decoding Time Stamp）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。 PTS（Presentation Time Stamp）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。 需要注意的是：虽然 DTS、PTS 是用于指导播放端的行为，但它们是在编码的时候由编码器生成的。 当视频流中没有 B 帧时，通常 DTS 和 PTS 的顺序是一致的。但如果有 B 帧时，就回到了我们前面说的问题：解码顺序和播放顺序不一致了。 比如一个视频中，帧的显示顺序是：I B B P，现在我们需要在解码 B 帧时知道 P 帧中信息，因此这几帧在视频流中的顺序可能是：I P B B，这时候就体现出每帧都有 DTS 和 PTS 的作用了。DTS 告诉我们该按什么顺序解码这几帧图像，PTS 告诉我们该按什么顺序显示这几帧图像。顺序大概如下： 123 PTS: 1 4 2 3 DTS: 1 2 3 4Stream: I P B B 其他常用命令1、将文件当作源推送到RTMP服务器 1ffmpeg -re -i localFile.mp4 -c copy -f flv rtmp://server/live/streamName 参数解释-r 以本地帧频读数据，主要用于模拟捕获设备。表示ffmpeg将按照帧率发送数据，不会按照最高的效率发送 2、将直播文件保存至本地 1ffmpeg -i rtmp://server/live/streamName -c copy dump.flv 3、将其中一个直播流中的视频改用H.264压缩，音频不变，推送到另外一个直播服务器 1ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv rtmp://server/live/h264Stream 4、将其中一个直播流中的视频改用H.264压缩，音频改用aac压缩，推送到另外一个直播服务器 1ffmpeg -i rtmp://server/live/originalStream -c:a libfaac -ar 44100 -ab 48k -c:v libx264 -vpre slow -vpre baseline -f flv rtmp://server/live/h264Stream 5、将其中一个直播流中的视频不变，音频改用aac压缩，推送到另外一个直播服务器 1ffmpeg -i rtmp://server/live/originalStream -acodec libfaac -ar 44100 -ab 48k -vcodec copy -f flv rtmp://server/live/h264_AAC_Stream 6、将一个高清流复制为几个不同清晰度的流重新发布，其中音频不变 1ffmpeg -re -i rtmp://server/live/high_FMLE_stream -acodec copy -vcodec x264lib -s 640×360 -b 500k -vpre medium -vpre baseline rtmp://server/live/baseline_500k -acodec copy -vcodec x264lib -s 480×272 -b 300k -vpre medium -vpre baseline rtmp://server/live/baseline_300k -acodec copy -vcodec x264lib -s 320×200 -b 150k -vpre medium -vpre baseline rtmp://server/live/baseline_150k -acodec libfaac -vn -ab 48k rtmp://server/live/audio_only_AAC_48k 7、将当前摄像头以及扬声器通过DSHOW采集，使用H.264/AAC压缩后推送到RTMP服务器 1ffmpeg -r 25 -f dshow -s 640×480 -i video=”video source name”:audio=”audio source name” -vcodec libx264 -b 600k -vpre slow -acodec libfaac -ab 128k -f flv rtmp://server/application/stream_name 8、将一个JPG图片经过H.264压缩后输出为MP4文件 1ffmpeg -i INPUT.jpg -an -vcodec libx264 -coder 1 -flags +loop -cmp +chroma -subq 10 -qcomp 0.6 -qmin 10 -qmax 51 -qdiff 4 -flags2 +dct8x8 -trellis 2 -partitions +parti8x8+parti4x4 -crf 24 -threads 0 -r 25 -g 25 -y OUTPUT.mp4 9、将MP3转化为AAC 1ffmpeg -i 20120814164324_205.wav -acodec libfaac -ab 64k -ar 44100 output.aac 10、将AAC文件转化为flv文件，编码格式采用AAC 1ffmpeg -i output.aac -acodec libfaac -y -ab 32 -ar 44100 -qscale 10 -s 640*480 -r 15 outp]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx_rtmp_ffmpeg搭建直播服务]]></title>
    <url>%2F2021%2F02%2F22%2Fnginx-rtmp-ffmpeg%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[nginx+rtmp+ffmpeg搭建直播服务nginx1、到nginx.org 下载稳定版本的nginx 2、到 https://github.com/arut/nginx-rtmp-module 下载rtmp模块 git clone https://github.com/arut/nginx-rtmp-module.git 3、编译Nginx，如果已经编译过，需要指定nginx-rtmp-module重新编译。 ./configure --add-module=&lt;path&gt;/nginx-rtmp-module https://github.com/arut/nginx-rtmp-module 有编译说明。 nginx添加rtmp配置nginx配置文件位于/usr/local/nginx/conf/nginx.conf12345678rtmp &#123; server &#123; listen 1935; application live &#123; live on; &#125; &#125;&#125; ffmpeg推流和拉流启动或重启nginx服务：sudo /usr/local/nginx/sbin/nginx或sudo systemctl restart nginx 推流：1）摄像头：ffmpeg -i /dev/video0 -an -f flv rtmp://127.0.0.1/live-an 参数是去掉音频，如果需要的话可以去掉，live对应的是nginx配置文件中application的名称。 2）播放文件：ffmpeg -re -i AVC_high_1280x720_2013.mp4 -c copy -f flv rtmp://127.0.0.1/live 3）使用OBS Studio 4）配合rtmpdumpffmpeg -re -i AVC_high_1280x720_2013.mp4 -c copy -f flv rtmp://127.0.0.1/live/play 拉流：1）使用ffplay ffplay rtmp://127.0.0.1/live 2）使用vlc播放 3）配合rtmpdumprtmpdump -r rtmp://127.0.0.1/live/play | vlc -服务器 URL具有以下格式：protocol://servername:port/appName/appInstancertmp://localhost:1935/testapp/instance1 整体框架1234graph LR A[ffmpeg 推流] --&gt; C&#123;Nginx服务器&#125; C --&gt; D[ffplay 拉流] C --&gt; E[vlc 拉流]]]></content>
      <tags>
        <tag>ffmpeg</tag>
        <tag>rtmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H.264视频码流解析]]></title>
    <url>%2F2021%2F02%2F04%2FH-264%E8%A7%86%E9%A2%91%E7%A0%81%E6%B5%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[NAL协议格式NAL全称Network Abstract Layer, 即网络抽象层.https://www.itu.int/rec/T-REC-H.264-201906-I/en SPS vs. PPSH.264 comes in a variety of stream formats. One variation is called “Annex B”. (AUD)(SPS)(PPS)(I-Slice)(PPS)(P-Slice)(PPS)(P-Slice) … (AUD)(SPS)(PPS)(I-Slice). AUD 总的来说H264的码流的打包方式有两种： annex-b byte stream format 的格式，这个是绝大部分编码器的默认输出格式，就是每个帧的开头的3~4个字节是H264的start_code,0x00000001或者0x000001。 原始的NAL打包格式，就是开始的若干字节（1，2，4字节）是NAL的长度，而不是start_code,此时必须借助某个全局的数据来获得编 码器的profile,level,PPS,SPS等信息才可以解码。紧随AUD，一般是SPS/PPS/SEI/IDR的组合或者简单就是一个SLICE，也就是一个帧的开始。 SPS(Sequence Parameter Set) 所谓的编码视频序列即原始视频的一帧一帧的像素数据经过编码之后的结构组成的序列。而每一帧的编码后数据所依赖的参数保存于图像参数集中。一般情况SPS和PPS的NAL Unit通常位于整个码流的起始位置。但在某些特殊情况下，在码流中间也可能出现这两种结构，主要原因可能为： 解码器需要在码流中间开始解码；编码器在编码的过程中改变了码流的参数（如图像分辨率等）；在做视频播放器时，为了让后续的解码过程可以使用SPS中包含的参数，必须对其中的数据进行解析。 PPS(Picture Parameter Set) 图像参数集 File Video：一般只有文件Header里面有SPS、PPS里面有信息Live Video：为防止丢失SPS/PPS包或者中途播放、每个IFrame/IDR 前面都有SPS、PPS An IDR frame, or an I-slice can not be decoded without a SPS and PPS. IDR vs. I-FrameEvery IDR frame is an I-frame, but not vice versa; so there can be I-frames that aren’t IDR frames. IDR 后面的帧不会参考之前的帧，I-Frame后面的帧还会参考之前的帧。 An IDR frame is a special type of I-frame in H.264. An IDR frame specifies that no frame after the IDR frame can reference any frame before it. This makes seeking the H.264 file easier and more responsive to the player. NAL、Frame、SPS、PPS、SLICE关系 NAL可以是：一帧视频数据（IDR，I-SLICE，P-SLICE）、SPS、PPS 一个video frame可能包含多个NAL ？参考VLC 一个NAL可能会分成多个RTP数据包（STAP聚合包），多个RTP包聚合成一个NAL STAP可以分为两种类型STAP-A，STAP-B： 123456789101112Payload Packet Single NAL Non-Interleaved InterleavedType Type Unit Mode Mode Mode-------------------------------------------------------------0 reserved ig ig ig1-23 NAL unit yes yes no24 STAP-A no yes no25 STAP-B no no yes26 MTAP16 no no yes27 MTAP24 no no yes28 FU-A no yes yes29 FU-B no no yes30-31 reserved ig ig ig SPS + PPS + IDR = I frame VLC的定义是不是有误？IDR就可以认为是I-Frame （15+4）+（4+4）+（46960+4）= 46991 P-SLICE = p frame 1562+4=1566 IDR = I frame 61779 + 4 = 61783 实验linux send h264 rtp stream:1234# 录屏gst-launch-1.0 -v ximagesrc ! video/x-raw,framerate=20/1 ! videoscale ! videoconvert ! x264enc tune=zerolatency bitrate=500 speed-preset=superfast ! rtph264pay ! udpsink host=127.0.0.1 port=5000# h264文件gst-launch-1.0 -v filesrc location=/home/xuleilx/mywork/ffmpeg/test.h264 ! h264parse ! rtph264pay ! udpsink host=127.0.0.1 port=5000 receive h264 rtp stream:1gst-launch-1.0 -v udpsrc port=5000 caps = "application/x-rtp, media=(string)video, clock-rate=(int)90000, encoding-name=(string)H264, payload=(int)96" ! rtph264depay ! decodebin ! videoconvert ! autovideosink Wireshark设置： 右击Decode As …，Current设置成RTP Edit -&gt; Preferences…，Protocols-&gt;h264，DynamicRTP Type :96 RTP承载H264数据需要将大的NAL帧分包123456789101112131415161.如何通过RTP承载H264数据参考博客：https://www.jianshu.com/p/efc5ef2113dahttps://www.jianshu.com/p/5aa012b76951参考技术文档：https://tools.ietf.org/html/rfc6184分包参考实现ffmpeg:libavformat --&gt; rtpenc_h264_hevc.c --&gt; ff_rtp_send_h264_hevc()]]></content>
      <tags>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Plugin]Advanced Concepts]]></title>
    <url>%2F2021%2F01%2F21%2FPlugin-Advanced-Concepts%2F</url>
    <content type="text"><![CDATA[Playbin连接流程 根据URI找src插件 playbin 根据 uri 中指定的协议来判断走哪个src element，比如：uri=file:///tmp/123.mp4 选择filesrcuri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm 选择 souphttpsrc 通过typefind找demux插件 通过typefind初步解析MIME媒体类型，找出支持该媒体类型的demux插件 Demux插件分流 demux插件会解析数据流的头部，完成音频和视频的分流，创建Sometimes 的pads。流消失，pads就会消失。 Decode插件解码 demux知道不同的MIME媒体类型的编码格式，找到对应解码插件 Sink插件 播放或显示裸数据 特殊类型的pads Sometimes pads：用于demux Request pads：用于mux 数据流模式scheduling modesPush- and Pull-mode。GStreamer在任何调度模式下都支持带有pads的element，其中并非所有pads都需要在同一模式下运行。 Push mode之前一篇文章里面有用到_chain ()，可以看到该函数是设置给了sinkpad，上游的gst_pad_push作用在srcpad上，触发下游元素_chain ()被调用。 Pull mode一般Demuxers, parsers 以及部分codec插件充当这样的角色，gst_pad_pull_range作用在sinkpad上，从src element中pull，push到downstream elements，控制着pipeline的数据流。需要提供随机访问。 可以看出，一般source pad会push数据给下游的element。当然source pad也可以pull，但是用的比较少。此模式的先决条件是使用gst_pad_set_getrange_function为source pad设置了_get_range。设置的函数会调用gst_pad_pull_range获取数据。 当sink element在PULL模式下激活时，它应该启动一个task ，该任务在其sinkpad上调用gst_pad_pull_range This can come in useful for several different kinds of elements: Demuxers, parsers and certain kinds of decoders where data comes in unparsed (such as MPEG-audio or video streams), since those will prefer byte-exact (random) access from their input. If possible, however, such elements should be prepared to operate in push-mode mode, too. Certain kind of audio outputs, which require control over their input data flow, such as the Jack sound server. 123gst_pad_set_activate_function (filter-&gt;sinkpad, gst_my_filter_activate);gst_pad_set_activatemode_function (filter-&gt;sinkpad,gst_my_filter_activate_mode);// gst_my_filter_activate_mode 启动一个task，调用gst_pad_push Providing random accessSeveral elements can implement random access: Data sources, such as a file source, that can provide data from any offset with reasonable low latency. Filters that would like to provide a pull-mode scheduling over the whole pipeline. Parsers who can easily provide this by skipping a small part of their input and are thus essentially “forwarding” getrange requests literally without any own processing involved. Examples include tag readers (e.g. ID3) or single output parsers, such as a WAVE parser. Caps negotiationIn GStreamer, negotiation of the media format always follows the following simple rules: A downstream element suggest a format on its sinkpad and places the suggestion in the result of the CAPS query performed on the sinkpad. See also Implementing a CAPS query function. An upstream element decides on a format. It sends the selected media format downstream on its source pad with a CAPS event. Downstream elements reconfigure themselves to handle the media type in the CAPS event on the sinkpad. A downstream element can inform upstream that it would like to suggest a new format by sending a RECONFIGURE event upstream. The RECONFIGURE event simply instructs an upstream element to restart the negotiation phase. Because the element that sent out the RECONFIGURE event is now suggesting another format, the format in the pipeline might change. Dynamic negotiationA typical flow goes like this: Caps are received on the sink pad of the element. If the element prefers to operate in passthrough mode, check if downstream accepts the caps with the ACCEPT_CAPS query. If it does, we can complete negotiation and we can operate in passthrough mode. Calculate the possible caps for the source pad. Query the downstream peer pad for the list of possible caps. Select from the downstream list the first caps that you can transform to and set this as the output caps. You might have to fixate the caps to some reasonable defaults to construct fixed caps. Examples of this type of elements include: Converter elements such as videoconvert, audioconvert, audioresample, videoscale, … Source elements such as audiotestsrc, videotestsrc, v4l2src, pulsesrc, … Memory allocationGstBuffer &gt; GstMemory GstMemory(GstMapInfo)：manages access to a piece of memory and then continue with one of it’s main usersGstBuffer： is used to exchange data between plugins and with the application. A GstBuffer contains one or more GstMemory objects. These objects hold the buffer’s data.GstMeta：can be placed on buffers to provide extra info about it and its memory.GstBufferPool：allows to more-efficiently manage buffers of the same size. Elements can ask a GstBufferPool or GstAllocator from the downstream peer element. If downstream is able to provide these objects, upstream can use them to allocate buffers. Many sink elements have accelerated methods for copying data to hardware, or have direct access to hardware. It is common for these elements to be able to create a GstBufferPool or GstAllocator for their upstream peers. GstMemory的使用 12345678910111213141516GstMemory *mem;GstMapInfo info;gint i;/* allocate 100 bytes */mem = gst_allocator_alloc (NULL, 100, NULL);/* get access to the memory in write mode */gst_memory_map (mem, &amp;info, GST_MAP_WRITE);/* fill with pattern */for (i = 0; i &lt; info.size; i++) info.data[i] = i;/* release memory */gst_memory_unmap (mem, &amp;info); GstBuffer的使用 1234567891011121314151617181920GstBuffer *buffer;GstMemory *mem;GstMapInfo info;/* make empty buffer */buffer = gst_buffer_new ();/* make memory holding 100 bytes */mem = gst_allocator_alloc (NULL, 100, NULL);/* add the buffer */gst_buffer_append_memory (buffer, mem);/* get WRITE access to the memory and fill with 0xff */gst_buffer_map (buffer, &amp;info, GST_MAP_WRITE);memset (info.data, 0xff, info.size);gst_buffer_unmap (buffer, &amp;info);/* free the buffer */gst_buffer_unref (buffer); GstBufferPool的使用 12345678910111213GstStructure *config;/* get config structure */config = gst_buffer_pool_get_config (pool);/* set caps, size, minimum and maximum buffers in the pool */gst_buffer_pool_config_set_params (config, caps, size, min, max);/* configure allocator and parameters */gst_buffer_pool_config_set_allocator (config, allocator, &amp;params);/* store the updated configuration again */gst_buffer_pool_set_config (pool, config); Media Types and PropertiesMIME类型：https://www.iana.org/assignments/media-types/media-types.xhtml Events常见的Event： Stream Start Caps Segment Tag (metadata) End of Stream (EOS) Table Of Contents Gap Flush Start Flush Stop Quality Of Service (QOS) Seek Request Navigation Downstream event：src -&gt; sink Upstream event: src &lt;- sink The most common upstream events are seek events, Quality-of-Service (QoS) and reconfigure events. gst_pad_send_event Segment event: A segment event is sent downstream to announce the range of valid timestamps in the stream and how they should be transformed into running-time and stream-time. A segment event must always be sent before the first buffer of data and after a flush Demuxer or ParserParsers are demuxers with only one source pad.]]></content>
      <categories>
        <category>Gstreamer</category>
      </categories>
      <tags>
        <tag>Gstreamer</tag>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Plugin]The Basics of Writing a Plugin]]></title>
    <url>%2F2021%2F01%2F21%2FPlugin-The-Basics-of-Writing-a-Plugin%2F</url>
    <content type="text"><![CDATA[FoundationsElements and PluginsElements are at the core of GStreamer. In the context of plugin development, an element is an object derived from the GstElement class. Pads A pad is similar to a plug or jack on a physical device. GstMiniObject, Buffers and EventsFor data transport, there are two types of GstMiniObject defined: events (control) and buffers (content). GstMiniObject 是GstBuffer 和GstEvent的父类。 Constructing the Boilerplate(gst-template)模板代码生成和编译1234567$ git clone https://gitlab.freedesktop.org/gstreamer/gst-template.git$ cd gst-template/gst-plugin/src$ git brach -av$ git checkout 1.18 #最新稳定版$ ../tools/make_element MyFilter$ gst-template# meson build$ gst-template# ninjia -C build 修改 gst-plugin/meson.build1234567891011# 修改前plugin_sources = [ &apos;src/gstplugin.c&apos; ]gstpluginexample = library(&apos;gstplugin&apos;,# 修改后plugin_sources = [ &apos;src/gstmyfilter.c&apos; ]gstpluginexample = library(&apos;gstmyfilter&apos;, 修改源代码可能是../tools/make_element的Bug，需要手动修改代码文件1234567# gstmyfilter.h# 修改前G_DECLARE_FINAL_TYPE (GstMyFilter, gst_my_filter, GST, PLUGIN_TEMPLATE, GstElement)# 修改后G_DECLARE_FINAL_TYPE (GstMyFilter, gst_my_filter, GST, MYFILTER, GstElement) 代码解析12345678910111213141516171819202122232425262728// gstmyfilter.h#define GST_TYPE_MY_FILTER (gst_my_filter_get_type())// _get_type返回GType的类型G_DECLARE_FINAL_TYPE (GstMyFilter, gst_my_filter, GST, MY_FILTER, GstElement)// G_DECLARE_FINAL_TYPE 定义一个不能被继承的类// #define G_DECLARE_FINAL_TYPE(ModuleObjName, module_obj_name, MODULE, OBJ_NAME, ParentName) \// GType module_obj_name##_get_type (void); \// G_GNUC_BEGIN_IGNORE_DEPRECATIONS \// typedef struct _##ModuleObjName ModuleObjName; \// typedef struct &#123; ParentName##Class parent_class; &#125; ModuleObjName##Class; struct _GstMyFilter&#123; GstElement element; GstPad *sinkpad, *srcpad; gboolean silent;&#125;;// 在调用G_DEFINE_TYPE() 之前，必须定义_GstMyFilter类型，在G_DECLARE_FINAL_TYPE中被自动定义为GstMyFilter// gstmyfilter.cG_DEFINE_TYPE (GstMyFilter, gst_my_filter, GST_TYPE_ELEMENT);// #define G_DEFINE_TYPE(TN, t_n, T_P) G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, 0, &#123;&#125;)// TN The name of the new type, in Camel case.// t_n The name of the new type, in lowercase, with words separated by '_'.// T_P The GType of the parent type. 主要是三个初始化：类初始化，元素初始化，插件初始化 类初始化：指定类具有的信号，参数和虚函数，并设置全局状态 元素初始化：用于初始化此类型的特定实例。数据和事件处理函数设置 插件初始化：插件加载后立即调用，并且应根据加载的插件是否正确初始化了设置返回值。另外，在此功能中，应注册插件中任何受支持的元素类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// gstmyfilter.c/* initialize the myfilter's class */static voidgst_my_filter_class_init (GstMyFilterClass * klass)&#123; GObjectClass *gobject_class; GstElementClass *gstelement_class; gobject_class = (GObjectClass *) klass; gstelement_class = (GstElementClass *) klass; // gobject_class子类特有属性 gobject_class-&gt;set_property = gst_my_filter_set_property; gobject_class-&gt;get_property = gst_my_filter_get_property; g_object_class_install_property (gobject_class, PROP_SILENT, g_param_spec_boolean ("silent", "Silent", "Produce verbose output ?", FALSE, G_PARAM_READWRITE)); // gstelement_class父类属性 gst_element_class_set_details_simple (gstelement_class, "MyFilter", "FIXME:Generic", "FIXME:Generic Template Element", "xuleilx &lt;&lt;user@hostname.org&gt;&gt;"); gst_element_class_add_pad_template (gstelement_class, gst_static_pad_template_get (&amp;src_factory)); gst_element_class_add_pad_template (gstelement_class, gst_static_pad_template_get (&amp;sink_factory));&#125;/* initialize the new element * instantiate pads and add them to element * set pad calback functions * initialize instance structure */static voidgst_my_filter_init (GstMyFilter * filter)&#123; // 设置数据、事件处理函数，并加入到element filter-&gt;sinkpad = gst_pad_new_from_static_template (&amp;sink_factory, "sink"); gst_pad_set_event_function (filter-&gt;sinkpad, GST_DEBUG_FUNCPTR (gst_my_filter_sink_event)); // gst_my_filter_sink_event handles sink events gst_pad_set_chain_function (filter-&gt;sinkpad, GST_DEBUG_FUNCPTR (gst_my_filter_chain)); // gst_my_filter_chain does the actual processing // _event 、_chain 、_query GST_PAD_SET_PROXY_CAPS (filter-&gt;sinkpad); gst_element_add_pad (GST_ELEMENT (filter), filter-&gt;sinkpad); filter-&gt;srcpad = gst_pad_new_from_static_template (&amp;src_factory, "src"); GST_PAD_SET_PROXY_CAPS (filter-&gt;srcpad); gst_element_add_pad (GST_ELEMENT (filter), filter-&gt;srcpad); filter-&gt;silent = FALSE;&#125;/* entry point to initialize the plug-in * initialize the plug-in itself * register the element factories and other features */static gbooleanmyfilter_init (GstPlugin * myfilter)&#123; /* debug category for filtering log messages * * exchange the string 'Template myfilter' with your description */ GST_DEBUG_CATEGORY_INIT (gst_my_filter_debug, "myfilter", 0, "Template myfilter"); return gst_element_register (myfilter, "myfilter", GST_RANK_NONE, GST_TYPE_MY_FILTER); // gst_element_register (GstPlugin * plugin, // const gchar * name, // guint rank, // GType type) // Create a new elementfactory capable of instantiating objects of the type and add the factory to plugin. // plugin ( [allow-none] ) – GstPlugin to register the element with, or NULL for a static element. // name – name of elements of this type // rank – rank of element (higher rank means more importance when autoplugging) // type – GType of element to register&#125;/* gstreamer looks for this structure to register myfilters * * exchange the string 'Template myfilter' with your myfilter description */GST_PLUGIN_DEFINE (GST_VERSION_MAJOR, GST_VERSION_MINOR, myfilter, "Template myfilter", myfilter_init, PACKAGE_VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)// Parameters:// major – major version number of the gstreamer-core that plugin was compiled for// minor – minor version number of the gstreamer-core that plugin was compiled for// name – short, but unique name of the plugin// description – information about the purpose of the plugin// init – function pointer to the plugin_init method with the signature of static gboolean plugin_init (GstPlugin * plugin).// version – full version string (e.g. VERSION from config.h)// license – under which licence the package has been released, e.g. GPL, LGPL.// package – the package-name (e.g. PACKAGE_NAME from config.h)// origin – a description from where the package comes from (e.g. the homepage URL) What are states?一般建议编写的插件继承自sources，sinks ，filter，transformation ，专门针对音频，视频还有其他的 base classes。 只需要实现基类的start() and stop() 就行了。如果是继承例如GstElement ，必须自己处理状态变更。Demuxer or muxer没有基类，需要自己处理。 upward先处理自己，然后往上处理父类downward先处理父类，然后再处理自己 12345678910static GstStateChangeReturngst_my_filter_change_state (GstElement *element, GstStateChange transition);static voidgst_my_filter_class_init (GstMyFilterClass *klass)&#123; GstElementClass *element_class = GST_ELEMENT_CLASS (klass); element_class-&gt;change_state = gst_my_filter_change_state;&#125;]]></content>
      <categories>
        <category>Gstreamer</category>
      </categories>
      <tags>
        <tag>Gstreamer</tag>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[App]Playback tutorial]]></title>
    <url>%2F2020%2F12%2F27%2FApp-Playback-tutorial%2F</url>
    <content type="text"><![CDATA[Playback tutorial 1: Playbin usagePropertyWe have set all these properties one by one, but we could have all of them with a single call to g_object_set(): 1g_object_set (data.playbin, "uri", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_cropped_multilingual.webm", "flags", flags, "connection-speed", 56, NULL); This is why g_object_set() requires a NULL as the last parameter. tagplaybin defines 3 action signals to retrieve metadata: get-video-tags, get-audio-tagsand get-text-tags. get-audio-tags-&gt; GstTagList -&gt; Constants-&gt; GST_TAG_IMAGE 可以参考ATC例子 How to retrieve a particular tag from the list with gst_tag_list_get_string()or gst_tag_list_get_uint() Playback tutorial 3: Short-cutting the pipelineHow to configure the appsrc using the source-setup signal 12345678910111213141516171819/* This function is called when playbin has created the appsrc element, so we have * a chance to configure it. */static void source_setup (GstElement *pipeline, GstElement *source, CustomData *data) &#123; GstAudioInfo info; GstCaps *audio_caps; g_print ("Source has been created. Configuring.\n"); data-&gt;app_source = source; /* Configure appsrc */ gst_audio_info_set_format (&amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, 1, NULL); audio_caps = gst_audio_info_to_caps (&amp;info); g_object_set (source, "caps", audio_caps, "format", GST_FORMAT_TIME, NULL); g_signal_connect (source, "need-data", G_CALLBACK (start_feed), data); g_signal_connect (source, "enough-data", G_CALLBACK (stop_feed), data); gst_caps_unref (audio_caps);&#125;g_signal_connect (data.pipeline, "source-setup", G_CALLBACK (source_setup), &amp;data); Playback tutorial 4: Progressive streamingdeep-notify1g_signal_connect (pipeline, "deep-notify::temp-location", G_CALLBACK (got_location), NULL); deep-notify signals are emitted by GstObject elements (like playbin) when the properties of any of their children elements change. In this case we want to know when the temp-location property changes, indicating that the queue2 has decided where to store the downloaded data. “temp-location”其实是queue2的属性。 12345678static void got_location (GstObject *gstobject, GstObject *prop_object, GParamSpec *prop, gpointer data) &#123; gchar *location; g_object_get (G_OBJECT (prop_object), "temp-location", &amp;location, NULL); g_print ("Temporary file: %s\n", location); g_free (location); /* Uncomment this line to keep the temporary file after the program exits */ /* g_object_set (G_OBJECT (prop_object), "temp-remove", FALSE, NULL); */&#125; The temp-location property is read from the element that triggered the signal (the queue2) and printed on screen. When the pipeline state changes from PAUSED to READY, this file is removed. As the comment reads, you can keep it by setting the temp-remove property of the queue2 to FALSE. 定时器In main we also install a timer which we use to refresh the UI every second. 12/* Register a function that GLib will call every second */g_timeout_add_seconds (1, (GSourceFunc)refresh_ui, &amp;data);]]></content>
      <categories>
        <category>Gstreamer</category>
      </categories>
      <tags>
        <tag>Gstreamer</tag>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[App]Basic tutorial]]></title>
    <url>%2F2020%2F12%2F24%2FApp-Basic-tutorial%2F</url>
    <content type="text"><![CDATA[Basic tutorialelement -&gt; pad -&gt; caps 包含关系 Basic tutorial 7: Multithreading and Pad AvailabilityRequest padsTo request (or release) pads in the PLAYING or PAUSED states, you need to take additional cautions (Pad blocking) which are not described in this tutorial. It is safe to request (or release) pads in the NULL or READY states, though. 多管道播放 单播放gst-launch-1.0 filesrc location=/home/xuleilx/Music/123.mp3 ! decodebin ! autoaudiosink 单显示gst-launch-1.0 filesrc location=/home/xuleilx/Music/123.mp3 ! decodebin ! wavescope ! videoconvert ! autovideosink 播放+显示gst-launch-1.0 filesrc location=/home/xuleilx/Music/123.mp3 ! decodebin ! tee name=t ! queue ! autoaudiosink t. ! queue ! wavescope ! videoconvert ! autovideosink 修改显示范围，增加个capsfiltergst-launch-1.0 filesrc location=/home/xuleilx/Music/123.mp3 ! decodebin ! tee name=t ! queue ! autoaudiosink t. ! queue ! wavescope ! capsfilter caps=”video/x-raw, format=BGRx,width=1280, height=720, framerate=30/1” ! videoconvert ! autovideosink 注意：playbin的flags的vis有类似功能 Basic tutorial 8: Short-cutting the pipeline主要通过appsrc，appsink实现，截取管道中的数据。 This tutorial expands Basic tutorial 7: Multithreading and Pad Availability in two ways: firstly, the audiotestsrc is replaced by an appsrc that will generate the audio data. Secondly, a new branch is added to the tee so data going into the audio sink and the wave display is also replicated into an appsink. The appsink uploads the information back into the application, which then just notifies the user that data has been received, but it could obviously perform more complex tasks. Basic tutorial 10: GStreamer tools三大利器，可以参照其源码实现想要的功能 123gst-launch-1.0gst-inspect-1.0gst-discoverer-1.0 # id3信息 Basic tutorial 11: Debugging toolsPrinting debug informationThe debug logThe first category is the Debug Level, which is a number specifying the amount of desired output: 123456789101112131415161718192021222324252627282930| # | Name | Description ||---|---------|----------------------------------------------------------------|| 0 | none | No debug information is output. || 1 | ERROR | Logs all fatal errors. These are errors that do not allow the || | | core or elements to perform the requested action. The || | | application can still recover if programmed to handle the || | | conditions that triggered the error. || 2 | WARNING | Logs all warnings. Typically these are non-fatal, but || | | user-visible problems are expected to happen. || 3 | FIXME | Logs all &quot;fixme&quot; messages. Those typically that a codepath that|| | | is known to be incomplete has been triggered. It may work in || | | most cases, but may cause problems in specific instances. || 4 | INFO | Logs all informational messages. These are typically used for || | | events in the system that only happen once, or are important || | | and rare enough to be logged at this level. || 5 | DEBUG | Logs all debug messages. These are general debug messages for || | | events that happen only a limited number of times during an || | | object&apos;s lifetime; these include setup, teardown, change of || | | parameters, etc. || 6 | LOG | Logs all log messages. These are messages for events that || | | happen repeatedly during an object&apos;s lifetime; these include || | | streaming and steady-state conditions. This is used for log || | | messages that happen on every buffer in an element for example.|| 7 | TRACE | Logs all trace messages. Those are message that happen very || | | very often. This is for example is each time the reference || | | count of a GstMiniObject, such as a GstBuffer or GstEvent, is || | | modified. || 9 | MEMDUMP | Logs all memory dump messages. This is the heaviest logging and|| | | may include dumping the content of blocks of memory. |+------------------------------------------------------------------------------+ 设置插件的日志等级GST_DEBUG=2,audiotestsrc:6 支持正则表达式GST_DEBUG=2,audio*:6 显示所有插件的日志等级：gst-launch-1.0 --gst-debug-help Gstreamer日志输出文件，默认输出到终端export GST_DEBUG_FILE=/tmp/gst.log Adding your own debug informationUse the GST_ERROR(), GST_WARNING(), GST_INFO(), GST_LOG() and GST_DEBUG() macros. They accept the same parameters as printf, and they use the default category (default will be shown as the Debug category in the output log). Getting pipeline graphs环境变量export GST_DEBUG_DUMP_DOT_DIR=/tmp/ 代码中GST_DEBUG_BIN_TO_DOT_FILE(GST_BIN(mypipeline), GST_DEBUG_GRAPH_SHOW_ALL, &quot;test&quot;);生成/tmp/test.dot文件，用vscode安装Graphviz Preview可查看 Basic tutorial 12: Streaming对于流媒体来说，buffer是通用解决方案。gstreamer提供了queue、queue2和multiqueue12gst_bus_add_signal_watch (bus);g_signal_connect (bus, "message", G_CALLBACK (cb_message), &amp;data); Live streams cannot be paused, so they behave in PAUSED state as if they were in the PLAYING state. Setting live streams to PAUSED succeeds, but returns GST_STATE_CHANGE_NO_PREROLL, instead of GST_STATE_CHANGE_SUCCESS to indicate that this is a live stream. We are receiving the NO_PREROLL return code even though we are trying to set the pipeline to PLAYING, because state changes happen progressively (from NULL to READY, to PAUSED and then to PLAYING). For the second network issue, the loss of clock, we simply set the pipeline to PAUSED and back to PLAYING, so a new clock is selected, waiting for new media chunks to be received if necessary. Basic tutorial 14: Handy elementsBinsplaybinuridecodebindecodebin File input/outputfilesrcfilesink Networksouphttpsrc Test media generationvideotestsrcaudiotestsrc Video adaptersvideoconvertvideoratevideoscale Audio adaptersaudioconvertaudioresampleaudiorate Multithreadingqueuequeue2multiqueuetee Capabilitiescapsfiltertypefind Debuggingfakesinkidentity]]></content>
      <categories>
        <category>Gstreamer</category>
      </categories>
      <tags>
        <tag>Gstreamer</tag>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[App]Development Manual]]></title>
    <url>%2F2020%2F12%2F22%2FApp-Development-Manual%2F</url>
    <content type="text"><![CDATA[What is GStreamer?GStreamer plug-ins could be classified into protocols handling sources: for audio and video (involves protocol plugins) formats: parsers, formaters, muxers, demuxers, metadata, subtitles codecs: coders and decoders filters: converters, mixers, effects, … sinks: for audio and video (involves protocol plugins) GStreamer is packaged into gstreamer: the core package gst-plugins-base: an essential exemplary set of elements gst-plugins-good: a set of good-quality plug-ins under LGPL gst-plugins-ugly: a set of good-quality plug-ins that might pose distribution problems gst-plugins-bad: a set of plug-ins that need more quality gst-libav: a set of plug-ins that wrap libav for decoding and encoding 软解插件 a few others packages CommunicationendGStreamer provides several mechanisms for communication and data exchange between the application and the pipeline. buffers are objects for passing streaming data between elements in the pipeline. Buffers always travel from sources to sinks (downstream). events are objects sent between elements or from the application to elements. Events can travel upstream and downstream. Downstream events can be synchronised to the data flow. messages are objects posted by elements on the pipeline’s message bus, where they will be held for collection by the application. Messages can be intercepted synchronously from the streaming thread context of the element posting the message, but are usually handled asynchronously by the application from the application’s main thread. Messages are used to transmit information such as errors, tags, state changes, buffering state, redirects etc. from elements to the application in a thread-safe way. queries allow applications to request information such as duration or current playback position from the pipeline. Queries are always answered synchronously. Elements can also use queries to request information from their peer elements (such as the file size or duration). They can be used both ways within a pipeline, but upstream queries are more common. signalsignal不是gstreamer特有的东西，它是来自于GObject体系，是用于app和GObject之间进行交互的一种机制。在gstreamer中，element本身也是gobject，所以，通过signal，就可以将app和element联系起来。当element发生了一些事情相让app知道时，就可以用signal的方式来通知app比如动态创建了一个Pad。当然也可以在element与element之间使用， 比如在Gstplaybin当中就会侦听uridecoderbin发出来的autoplug-factories，autoplug-select等信号。 signal和Bus message不同，bus message是pipeline上的，一般是app和pipeline交互的一种方法。signal则具体到了每个element。 Initializing GStreamerSimple initialization1gst_init The GOption interfaceGOption Elements12345678gst_element_factory_make ()gst_object_unref ()//gst_element_factory_make实际上是由gst_element_factory_find,gst_element_factory_create组合而成gst_element_factory_make () factory = gst_element_factory_find () element = gst_element_factory_create () gst_object_unref (GST_OBJECT (element)); gst_object_unref (GST_OBJECT (factory)); Using an element as a GObjectEvery GstElement inherits at least one property from its parent GstObject: the “name” property. You can get and set this property using the functions gst_object_set_name and gst_object_get_name GObject：https://developer.gnome.org/gobject/stable/rn01.htmlGLIB：https://developer.gnome.org/gobject/stable/pt01.html Linking elements1234// 组成PipeLinegst_bin_add_many()// Link的目的：匹配Element之间的pad，link只能发生在同一个pipeline中的Element之间gst_element_link_many () Element States GST_STATE_NULL: this is the default state. No resources are allocated in this state, so, transitioning to it will free all resources. The element must be in this state when its refcount reaches 0 and it is freed. GST_STATE_READY: in the ready state, an element has allocated all of its global resources, that is, resources that can be kept within streams. You can think about opening devices, allocating buffers and so on. However, the stream is not opened in this state, so the stream positions is automatically zero. If a stream was previously opened, it should be closed in this state, and position, properties and such should be reset. GST_STATE_PAUSED: in this state, an element has opened the stream, but is not actively processing it. An element is allowed to modify a stream’s position, read and process data and such to prepare for playback as soon as state is changed to PLAYING, but it is not allowed to play the data which would make the clock run. In summary, PAUSED is the same as PLAYING but without a running clock. Elements going into the PAUSED state should prepare themselves for moving over to the PLAYING state as soon as possible. Video or audio outputs would, for example, wait for data to arrive and queue it so they can play it right after the state change. Also, video sinks can already play the first frame (since this does not affect the clock yet). Autopluggers could use this same state transition to already plug together a pipeline. Most other elements, such as codecs or filters, do not need to explicitly do anything in this state, however. GST_STATE_PLAYING: in the PLAYING state, an element does exactly the same as in the PAUSED state, except that the clock now runs. GST_STATE_READY or GST_STATE_NULL 这两个状态的变更是同步的。参照gst_element_set_state()接口说明。原因主要这两个状态涉及到资源的分配和释放。 动态添加元素时，需要单独设置状态。when adding elements dynamically to an already-running pipeline, e.g. from within a “pad-added” signal callback, you need to set it to the desired target state yourself using gst_element_set_state () or gst_element_sync_state_with_parent (). BinsBins allow you to combine a group of linked elements into one logical element. You do not deal with the individual elements anymore but with just one element, the bin. Creating a bin123456gst_bin_new();gst_bin_add();gst_bin_add_many();gst_bin_remove();// 可以选择是否放入pipeline中gst_pipeline_new() Bins manage states of their childrenBins manage the state of all elements contained in them. If you set a bin (or a pipeline, which is a special top-level type of bin) to a certain target state using gst_element_set_state (), it will make sure all elements contained within it will also be set to this state. This means it’s usually only necessary to set the state of the top-level pipeline to start up the pipeline or shut it down. BusHow to use a busRun a GLib/Gtk+ main loop (or iterate the default GLib main context yourself regularly) and attach some kind of watch to the bus. This way the GLib main loop will check the bus for new messages and notify you whenever there are messages. 123456789// switch message// 异步消息gst_bus_add_watch()gst_bus_add_signal_watch()// 同步消息gst_bus_set_sync_handler()// 面向对象的做法，需要监视一个添加一个，不破坏原来代码g_signal_connect (bus, "message::eos", G_CALLBACK (cb_message_eos), NULL); The return value of the handler should be TRUE to keep the handler attached to the bus, return FALSE to remove it. Message types Error, warning and information notifications End-of-stream notification Tags: metadata ID3信息 State-changes Buffering: network-streams, 获取网络流媒体播放进度，“buffer-percent” Element messages Application-specific messages Pads and capabilities Pads Dynamic (or sometimes) pads Request pads Capabilities of a padProperties and valuesBasic types, this can be pretty much any GType registered with Glib. An integer value (G_TYPE_INT): the property has this exact value. A boolean value (G_TYPE_BOOLEAN): the property is either TRUE or FALSE. A float value (G_TYPE_FLOAT): the property has this exact floating point value. A string value (G_TYPE_STRING): the property contains a UTF-8 string. A fraction value (GST_TYPE_FRACTION): contains a fraction expressed by an integer numerator and denominator. Range types are GTypes registered by GStreamer to indicate a range of possible values. An integer range value (GST_TYPE_INT_RANGE): the property denotes a range of possible integers, with a lower and an upper boundary. The “vorbisdec” element, for example, has a rate property that can be between 8000 and 50000. A float range value (GST_TYPE_FLOAT_RANGE): the property denotes a range of possible floating point values, with a lower and an upper boundary. A fraction range value (GST_TYPE_FRACTION_RANGE): the property denotes a range of possible fraction values, with a lower and an upper boundary. List value (GST_TYPE_LIST)Array value (GST_TYPE_ARRAY)GST_TYPE_LIST和GST_TYPE_ARRAY区别：GST_TYPE_LIST一组值中任意一个。GST_TYPE_ARRAY是一个整体，每个元素可能用的地方不一样，比如：这个数组有四个值，分别表示左右前后扬声器默认音量。 What capabilities are used for Autoplugging: automatically finding elements to link to a pad based on its capabilities. All autopluggers use this method. Compatibility detection: when two pads are linked, GStreamer can verify if the two pads are talking about the same media type. The process of linking two pads and checking if they are compatible is called “caps negotiation”. Metadata: by reading the capabilities from a pad, applications can provide information about the type of media that is being streamed over the pad, which is information about the stream that is currently being played back. 比如：视频宽高. 1gst_structure_get_int (str, "width", &amp;width); Filtering: an application can use capabilities to limit the possible media types that can stream between two pads to a specific subset of their supported stream types. An application can, for example, use “filtered caps” to set a specific (fixed or non-fixed) video size that should stream between two pads. You will see an example of filtered caps later in this manual, in Manually adding or removing data from/to a pipeline. You can do caps filtering by inserting a capsfilter element into your pipeline and setting its “caps” property. Caps filters are often placed after converter elements like audioconvert, audioresample, videoconvert or videoscale to force those converters to convert data to a specific output format at a certain point in a stream. Creating capabilities for filtering12345678// gst_caps_new_full () caps = gst_caps_new_simple ("video/x-raw", "format", G_TYPE_STRING, "I420", "width", G_TYPE_INT, 384, "height", G_TYPE_INT, 288, "framerate", GST_TYPE_FRACTION, 25, 1, NULL);link_ok = gst_element_link_filtered (element1, element2, caps); Buffers and EventsEvents are control particles that are sent both up- and downstream in a pipeline along with buffers. Downstream events notify fellow elements of stream states. Possible events include seeking, flushes, end-of-stream notifications and so on. Upstream events are used both in application-element interaction as well as element-element interaction to request changes in stream state, such as seeks. 1234567GstEvent *event;event = gst_event_new_seek (1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_NONE, GST_SEEK_METHOD_SET, time_ns, GST_SEEK_TYPE_NONE, G_GUINT64_CONSTANT (0));gst_element_send_event (element, event); Position tracking and seekingQuerying: getting the position or length of a streamInternally, queries will be sent to the sinks, and “dispatched” backwards until one element can handle it; that result will be sent back to the function caller. Usually, that is the demuxer, although with live sources (from a webcam), it is the source itself. 12345gst_element_query () gst_element_query_position () gst_element_query_duration ()// 定时查询进度g_timeout_add (200, (GSourceFunc) cb_print_position, pipeline); Events: seeking (and more)It is important to realise that seeks will not happen instantly in the sense that they are finished when the function gst_element_seek () returns. Seeks with the GST_SEEK_FLAG_FLUSH should be done when the pipeline is in PAUSED or PLAYING state. Seeks without the GST_SEEK_FLAG_FLUSH should only be done when the pipeline is in the PLAYING state. Executing a non-flushing seek in the PAUSED state might deadlock because the pipeline streaming threads might be blocked in the sinks. You can wait (blocking) for the seek to complete with gst_element_get_state() or by waiting for the ASYNC_DONE message to appear on the bus. It is possible to do multiple seeks in short time-intervals, such as a direct response to slider movement. 12gst_element_seek gst_element_seek_simple MetadataMetadata reading 歌曲名 专辑名 艺术家 专辑图片 显示图片gst-launch-1.0 -v filesrc location=3d_data.png ! decodebin ! autovideoconvert ! imagefreeze ! autovideosink ThreadsWhen would you want to force a thread?We have seen that threads are created by elements but it is also possible to insert elements in the pipeline for the sole purpose of forcing a new thread in the pipeline. There are several reasons to force the use of threads. However, for performance reasons, you never want to use one thread for every element out there, since that will create some overhead. Let’s now list some situations where threads can be particularly useful: Data buffering, for example when dealing with network streams or when recording data from a live stream such as a video or audio card. Short hickups elsewhere in the pipeline will not cause data loss. See also Stream buffering about network buffering with queue2. Synchronizing output devices, e.g. when playing a stream containing both video and audio data. By using threads for both outputs, they will run independently and their synchronization will be better. We’ve mentioned the “queue” element several times now. A queue is the thread boundary element through which you can force the use of threads. To use a queue (and therefore force the use of two distinct threads in the pipeline), one can simply create a “queue” element and put this in as part of the pipeline. GStreamer will take care of all threading details internally. Playback ComponentsPlaybinDecodebinDecodebin is the actual autoplugger backend of playbin, which was discussed in the previous section. Decodebin will, in short, accept input from a source that is linked to its sinkpad and will try to detect the media type contained in the stream, and set up decoder routines for each of those. It will automatically select decoders. For each decoded stream, it will emit the “pad-added” signal, to let the client know about the newly found decoded stream. For unknown streams (which might be the whole stream), it will emit the “unknown-type” signal. The application is then responsible for reporting the error to the user. URIDecodebinPlaysinkThings to check when writing an applicationThis chapter contains a fairly random selection of things that can be useful to keep in mind when writing GStreamer-based applications. It’s up to you how much you’re going to use the information provided here. We will shortly discuss how to debug pipeline problems using GStreamer applications. Also, we will touch upon how to acquire knowledge about plugins and elements and how to test simple pipelines before building applications around them. Good programming habits Always add a GstBus handler to your pipeline. Always report errors in your application, and try to do something with warnings and information messages, too. Always check return values of GStreamer functions. Especially, check return values of gst_element_link ()and gst_element_set_state (). Dereference return values of all functions returning a non-base type, such as gst_element_get_pad (). Also, always free non-const string returns, such as gst_object_get_name (). Always use your pipeline object to keep track of the current state of your pipeline. Don’t keep private variables in your application. Also, don’t update your user interface if a user presses the “play” button. Instead, listen for the “state-changed” message on the GstBus and only update the user interface whenever this message is received. Report all bugs that you find to Gitlab at https://gitlab.freedesktop.org/gstreamer/. DebuggingApplications can make use of the extensive GStreamer debugging system to debug pipeline problems. Elements will write output to this system to log what they’re doing. It’s not used for error reporting, but it is very useful for tracking what an element is doing exactly, which can come in handy when debugging application issues (such as failing seeks, out-of-sync media, etc.). Most GStreamer-based applications accept the commandline option --gst-debug=LIST and related family members. The list consists of astart of Rose highlighter annotation. comma-separated end of Rose highlighter annotation.list of category/level pairs, which can set the debugging level for a specific debugging category. For example, --gst-debug=oggdemux:5 would turn on debugging for the Ogg demuxer element. You can use wildcards as well. A debugging level of 0 will turn off all debugging, and a level of 9 will turn on all debugging. Intermediate values only turn on some debugging (based on message severity; 2, for example, will only display errors and warnings). Here’s a list of all available options: start of Rose highlighter annotation.--gst-debug-helpend of Rose highlighter annotation. will print available debug categories and exit. --gst-debug-level=LEVEL will set the default debug level (which can range from 0 (no output) to 9 (everything)). --gst-debug=LIST takes a comma-separated list of category_name:level pairs to set specific levels for the individual categories. Example: GST_AUTOPLUG:5,avidemux:3. Alternatively, you can also set the GST_DEBUGenvironment variable, which has the same effect. --gst-debug-no-color will disable color debugging. You can also set the GST_DEBUG_NO_COLOR environment variable to 1 if you want to disable colored debug output permanently. Note that if you are disabling color purely to avoid messing up your pager output, try using less -R. --gst-debug-color-mode=MODE will change debug log coloring mode. MODE can be one of the following: on, off, auto, disable, unix. You can also set the GST_DEBUG_COLOR_MODE environment variable if you want to change colored debug output permanently. Note that if you are disabling color purely to avoid messing up your pager output, try using less -R. --gst-debug-disable disables debugging altogether. --gst-plugin-spew enables printout of errors while loading GStreamer plugins. Conversion pluginsGStreamer contains a bunch of conversion plugins that most applications will find useful. Specifically, those are videoscalers (videoscale), colorspace convertors (videoconvert), audio format convertors and channel resamplers (audioconvert) and audio samplerate convertors (audioresample). Those convertors don’t do anything when not required, they will act in passthrough mode. They will activate when the hardware doesn’t support a specific request, though. All applications are recommended to use those elements. Utility applications provided with GStreamerGStreamer comes with a default set of command-line utilities that can help in application development. We will discuss only gst-launch and gst-inspect here. gst-launchgst-launch is a simple script-like commandline application that can be used to test pipelines. For example, the command gst-launch audiotestsrc ! audioconvert ! audio/x-raw,channels=2 ! alsasink will run a pipeline which generates a sine-wave audio stream and plays it to your ALSA audio card. gst-launch also allows the use of threads (will be used automatically as required or as queue elements are inserted in the pipeline) and bins (using brackets, so “(” and “)”). You can use dots to imply padnames on elements, or even omit the padname to automatically select a pad. Using all this, the pipeline gst-launch filesrc location=file.ogg ! oggdemux name=d d. ! queue ! theoradec ! videoconvert ! xvimagesink d. ! queue ! vorbisdec ! audioconvert ! audioresample ! alsasink will play an Ogg file containing a Theora video-stream and a Vorbis audio-stream. You can also use autopluggers such as decodebin on the commandline. See the manual page of gst-launch for more information. gst-inspectgst-inspect can be used to inspect all properties, signals, dynamic parameters and the object hierarchy of an element. This can be very useful to see which GObject properties or which signals (and using what arguments) an element supports. Run gst-inspect fakesrc to get an idea of what it does. See the manual page of gst-inspectfor more information.]]></content>
      <categories>
        <category>Gstreamer</category>
      </categories>
      <tags>
        <tag>Gstreamer</tag>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[启动Siri导致车机卡死问题分析]]></title>
    <url>%2F2020%2F11%2F29%2F%E5%90%AF%E5%8A%A8Siri%E5%AF%BC%E8%87%B4%E8%BD%A6%E6%9C%BA%E5%8D%A1%E6%AD%BB%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[启动Siri导致车机卡死问题分析问题现象启动Siri后，车机卡顿，串口输入输出卡顿。CPU使用率达到接近100%。 再现步骤启动Siri 根本原因直接原因录声音的时候用到snd_pcm_wait接口，来判断是否用数据即使没有数据snd_pcm_wait也会直接返回，_GetAvailDelayWithTimestamp函数中的snd_pcm_status循环调用ioctl判断有无数据，导致CPU 100%其他进程无法得到运行。 根本原因该项目音频架构变更，采用外置836的DSP。怀疑alsa版本与新的音频架构不匹配导致。也可以说是alsa的Bug，旧版本的alsa对外置的DSP适配不好。 对比：其他同平台高通原生内置dsp，无此问题，snd_pcm_wait会正常等待。 代码调用流程1234snd_pcm_wait // Wait for a PCM to become ready.snd_pcm_avail // Return number of frames ready to be read (capture) / written (playback)snd_pcm_status // Obtain status (runtime) information for PCM handle. ioctl 解决方案方案1：通过尝试替换alsa版本可以解决该问题，使用二分法找到修改该问题的版本。 alsa修改版本https://www.alsa-project.org/wiki/Detailed_changes_v1.1.1_v1.1.2 最终方案，不是打单个patch，而是更新至最新稳定版alsa。 方案2：alsa修改 snd_pcm_wait 函数，强制poll等待数据 方案3：修改Carplay代码，主动释放cpu。该方案cpu依然很高，但是车机不会卡死。可以作为规避方案。 分析详细下面我们开始抽丝剥茧： gdb定位卡死点 在认知里，我们知道ioctl一般是直接返回的(消耗CPU资源)，一般释放时间片的操作如select，poll，nanosleep等。所以怀疑一直循环调用ioctl导致CPU使用率过高。 对比之前的音频架构首先我们可以明确两个调查方向： 为什么 snd_pcm_wait 没有等待 ？（根本原因，理论上就应该在改接口处等待PCM数据流） 为什么 snd_pcm_status 会死循环 ？（直接原因） 为什么snd_pcm_status 会死循环(方案1)由gdb调试结果可知，栈的调用关系是从snd_pcm_rate_status开始的，然后调用到snd_pcm_plugin_status，那我们看下新旧alsa版本这两个函数的差异： snd_pcm_plugin_status： snd_pcm_rate_status： 再看看 ioctl 究竟在干什么： 我们可以很明显的看到 _agian 的死循环。通过gdb单步执行可以确认的确在死循环。 于是我们找到了这个alsa的patch： 打上patch确认有效。 为什么 snd_pcm_wait 没有等待(方案2)通过增加日志打印，发现每次都是走的default。没有走 snd_pcm_wait_nocheck 函数，其实这个时候根本没有数据可以读。 通过修改代码，强制让程序走一次 snd_pcm_wait_nocheck 亦可解决该问题。 123456// 修改前default: return 1;// 修改后default: break; 插曲不要以为故事已经结束了，其实才刚刚开始。开玩笑啦！打完这个patch之后，其它的问题开始出现了，原则是修改任何问题必须最小改动，但是alsa版本跨度太大，patch之间也会有诸多依赖。打完单个patch之后，发现高概率声卡打开会失败，报下面三个错误： 12345ALSA lib pcm_dsnoop.c:584:(snd_pcm_dsnoop_open) unable to create IPC semaphoreALSA lib pcm_dsnoop.c:600:(snd_pcm_dsnoop_open) unable to create IPC shm instanceALSA lib pcm_dsnoop.c:666:(snd_pcm_dsnoop_open) unable to open slave 也就是说 snd_pcm_dsnoop_open 函数里面的这三处错误都遇到了。 当然，我们也找到了对应的patch：https://git.alsa-project.org/?p=alsa-lib.git;a=commit;h=dec428c352217010e4b8bd750d302b8062339d32 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849author Qing Cai &lt;bsiice@msn.com&gt; Thu, 10 Mar 2016 20:40:51 +0800 (07:40 -0500)committer Takashi Iwai &lt;tiwai@suse.de&gt; Thu, 10 Mar 2016 22:34:36 +0800 (15:34 +0100)pcm: fix &apos;unable to create IPC shm instance&apos; caused by fork from a threadAs stated in manpage SHMCTL(2), shm_nattch is &quot;No. of current attaches&quot;(i.e., number of processes attached to the shared memeory). If anapplication uses alsa-lib and invokes fork() from a thread of theapplication, there may be the following execution sequence: 1. execute the following statement: pcm_direct.c:110: dmix-&gt;shmptr = shmat(dmix-&gt;shmid, 0, 0) (shm_nattch becomes 1) 2. invoke fork() in some thread. (shm_nattch becomes 2) 3. execute the following statement: pcm_direct.c:122: if (buf.shm_nattch == 1) 4. execute the following statement: pcm_direct.c:131: if (dmix-&gt;shmptr-&gt;magic != SND_PCM_DIRECT_MAGIC) (As stated in manpage SHMGET(2), &quot;When a new shared memory segment is created, its contents are initialized to zero values&quot;, so dmix-&gt;shmptr-&gt;magic is 0) 5. execute the following statements: pcm_direct.c:132: snd_pcm_direct_shm_discard(dmix) pcm_direct.c:133: return -EINVALThe above execution sequence will cause the following error: unable to create IPC shm instanceThis error causes multimedia application has no sound. This error rarelyoccurs, probability is about 1%.More notes about this patch:this patch tries to address the race above by changing the conditionto identify &quot;the first user&quot;. Until now, the first user wasidentified by checking shm_nattch. But this is racy, as stated in theabove.In this version, we try to assign a shm at first without IPC_CREAT.If this succeeds, we are not alone, so we must not be the first user.Only when this fails, try to get a shmem with IPC_CREAT and IPC_EXCL.If this succeeds, we are the first user. And, one more notable pointis that the race of this function call itself is protected bysemaphore in the caller side. The only point to avoid is the raceafter shmget() and the first initialization, and this method shouldwork around that.Signed-off-by: Qing Cai &lt;bsiice@msn.com&gt;Signed-off-by: Qing Cai &lt;caiqing@neusoft.com&gt;Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt; 看到 neusoft 居然是东软，有点惊讶。敬佩这样一步步找根本原因，给开源代码提patch的共享者。向他们致敬。]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Pop音解决方案]]></title>
    <url>%2F2020%2F11%2F27%2F%E5%85%B3%E4%BA%8EPop%E9%9F%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[现象分析先来看一个典型的爆音音频示例，播放一个1k hz的正玄波，由于播放的正弦波的起始点不是0开始的完整的正弦波，第一个音频frame跳变。 由于幅度跳变，过渡不连续，造成爆音，从频谱图来看这条竖直的亮线处，就是产生爆音的位置 数据源线性变换针对数据源，做梯度上升 频谱来看，爆破音减弱了很多。 300ms线性变化的频谱 500ms线性变化的频谱 线性变换的梯度越缓，消除pop音的效果越好，不过实际测下来10ms的渐变就可以达到比较良好的水平。当然网上有更为优秀的算法，可以实现完全消除的。 伪代码 参考实现首先我们得弄清楚buffer/period/frame/sample之间的关系，下面一张图直观的表示buffer/period/frame/sample之间的关系： 对于底层来说是以frame为单位进行播放的，所以我们应该以frame为单位，针对的sample做线性变换。以下是渐入的代码参考实现：]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经验分享：gcc编译参数stack-protector]]></title>
    <url>%2F2020%2F11%2F27%2F%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%EF%BC%9Agcc%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0stack-protector%2F</url>
    <content type="text"><![CDATA[经验分享：gcc编译参数stack-protector前言 1 目的指导针对gcc编译选项stack-protector产生的core的解析，解决产品中的Bug。 2 适用范围C/C++程序开发者。 3 职责与权限针对 stack smashing detected 错误，使开发工程师在开发调试时明确调试与修改方向。 4 正文内容4.1 stack-protector介绍Stack overflow攻击是一种很常见的代码攻击，armcc和gcc等编译器都实现了stack protector来避免stack overflow攻击。虽然armcc和gcc在汇编代码生成有些不同，但其原理是相同的。这篇文章以armcc为例，看一看编译器的stack protector。 armcc提供了三个编译选项来打开/关闭stack protector。 -fno-stack-protector 关闭stack protector man gcc没有找到，gcc版本相关？ -fstack-protector 为armcc认为危险的函数打开stack protector -fstack-protector-all 为所有的函数打开stack protector 4.2 如何防止stack overflow攻击？armcc在函数栈中的上下文和局部变量之间插入了一个数字来监控堆栈破坏，这个值一般被称作为canary word，在armcc中将这个值定义为stack_chk_guard。当函数返回之前，函数会去检查canary word是否被修改，如果canary word被修改了，那么证明函数栈被破坏了，这个时候armcc就会去调用一个函数来处理这种栈破坏行为，armcc为我们提供了stack_chk_fail这个回调函数来处理栈破坏。 因此，在armcc打开-fstack-protector之前需要在代码中设置stack_chk_guard和stack_chk_fail。我从ARM的官网上摘抄了一段它们的描述。1234567void *__stack_chk_guardYou must provide this variable with a suitable value, such as a random value. The value can change during the life of the program. For example, a suitable implementation might be to have the value constantly changed by another thread.void __stack_chk_fail(void)It is called by the checking code on detection of corruption of the guard. In general, such a function would exit, possibly after reporting a fault. 4.3 stack protector产生了什么代码来防止stack overflow？首先来看一下写的一个c代码片段， 代码很简单，stack_chk_guard 设置为一个常数，当然这只是一个例子，最好的方法是设置这个值为随机数。然后重写了stack_chk_fail这个回调接口。test_stack_overflow这个函数很简单，仅仅在函数栈上分配了i和c_arr这两个局部变量，并对部分成员赋值。12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;void __stack_chk_fail()&#123; printf("__stack_chk_fail()\n"); while(1);&#125;void *__stack_chk_guard = (void *)0;int test_stack_overflow(int a, int b, int c, int d, int e)&#123; int i; int c_arr[15]; int *p = c_arr; i = 15; c_arr[0] = 2; c_arr[1] = 3; return 0;&#125;int main(int argc,char* argv[]) &#123; printf("before test_stack_overflow\n"); test_stack_overflow(1, 2, 3, 4, 5); printf("after test_stack_overflow\n"); return 0;&#125; 没有打开-fstack-protector选项时：打开-fstack-protector选项时： 在函数返回的时候，检测__stack_chk_guard的值。 下图左边是没有打开-fstack-protector，右边是打开-fstack-protector的汇编代码： 4.4示例代码 test_overflow.c12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int check_password(char *password)&#123; int flag = 0; char buffer[20]; strcpy(buffer, password); if(strcmp(buffer, "mypass") == 0)&#123; flag = 1; &#125; if(strcmp(buffer, "yourpass") == 0)&#123; flag = 1; &#125; return flag;&#125;int main(int argc, char *argv[])&#123; if(argc &gt;= 2)&#123; if(check_password(argv[1]))&#123; printf("%s", "Access granted\n"); &#125;else&#123; printf("%s", "Access denied\n"); &#125; &#125;else&#123; printf("%s", "Please enter password!\n"); &#125;&#125; 编译：1# gcc test_overflow.c -g -fstack-protector]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于StackSmashingDetected问题调查]]></title>
    <url>%2F2020%2F11%2F27%2F%E5%85%B3%E4%BA%8EStackSmashingDetected%E9%97%AE%E9%A2%98%E8%B0%83%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[关于StackSmashingDetected问题调查■现象密钥交换时报错： stack smashing detected ，产生CoreDump。 ■再现步骤1.密钥交换 ■根本原因使用解密函数写穿了局部变量的buffer，导致触发了stack protector机制。 代码分析：12345678910int RootKeyCmdDown::procMsg(std::shared_ptr&lt;ConnectionContext&gt; conn)&#123; logInfo("%s procMsg.", TAG.data()); vector&lt;BYTE&gt; dataVec; dataVec.resize(32); memset(&amp;dataVec[0], 0, 32); BYTE new_root_key[16] = &#123;0&#125;; get_new_rootkey(new_root_key); .......&#125; 1aes_decrypt((unsigned char*)new_root_key_aes,32,pMsgContainer-&gt;GetRootKeyVector(),aes_decrypt_buf); 12345678910int aes_decrypt(unsigned char* in, int len , unsigned char* key, unsigned char* out)&#123; AES_KEY aes; if(AES_set_decrypt_key(key, 128, &amp;aes) &lt; 0) return 0; for(int i = 0;i&lt;(len/16);i++) //循环调用两次，out处写了32个字节 &#123; AES_ecb_encrypt(in+i*16, out+i*16, &amp;aes , AES_DECRYPT); &#125; return 1;&#125; ■调查详细由于密钥交换触发条件比较麻烦，本示例使用的是测试程序，并非项目代码 1.打开产生Core文件选项123root@mdm9607-perf:~/work/stack-protector# ulimit -c unlimitedroot@mdm9607-perf:~/work/stack-protector# ulimit -cunlimited 2.查看Core产生路径12root@mdm9607-perf:~/work/stack-protector# cat /proc/sys/kernel/core_pattern core 相对路径core，代表Core文件生成在执行命令的当前目录下。 3.gdb调试3.1 打印堆栈回溯12345678910111213141516171819root@mdm9607-perf:~/work/stack-protector# ./test_overflow_smash xxxxxxxxxxxxxxxxxxxxx*** stack smashing detected ***: ./test_overflow_smash terminatedAborted (core dumped)root@mdm9607-perf:~/work/stack-protector# gdb ./test_overflow_smash coreReading symbols from ./test_overflow_smash...2502done.warning: core file may not match specified executable file.[New LWP 5939]Core was generated by `./test_overflow_smash xxxxxxxxxxxxxxxxxxxxx&apos;.Program terminated with signal SIGABRT, Aborted.#0 0x4c93cb94 in raise () from /lib/libc.so.6(gdb) bt#0 0x4c93cb94 in raise () from /lib/libc.so.6#1 0x4c940670 in abort () from /lib/libc.so.6#2 0x4c974998 in ?? () from /lib/libc.so.6Backtrace stopped: previous frame identical to this frame (corrupt stack?)(gdb) libc.so以后的堆栈回溯只能看到？号。百度一下，可能是libc.so的版本不对。也就是说集成环境的libc.so与我们编译的SDK中libc.so版本不一致。 3.2 拷贝SDK中的libc.so到环境中，编译时指定该目录123root@mdm9607-perf:~/work/stack-protector# lscore test_overflow_segvlibc.so.6 3.3 gdb中设置lib库的加载路径123456789101112131415161718(gdb) set solib-absolute-prefix "./"(gdb) set solib-search-path "./"warning: .dynamic section for "/home/root/work/stack-protector/libc.so.6" is not at the expected address (wrong library or version mismatch?)Reading symbols from /home/root/work/stack-protector/libc.so.6...done.Loaded symbols for /home/root/work/stack-protector/libc.so.6(gdb) bt#0 0x4c93cb94 in raise () from /home/root/work/stack-protector/libc.so.6#1 0x4c940670 in abort () from /home/root/work/stack-protector/libc.so.6#2 0x4c974998 in __libc_message () from /home/root/work/stack-protector/libc.so.6#3 0x4c9f042c in __fortify_fail () from /home/root/work/stack-protector/libc.so.6#4 0x4c9f03e8 in __stack_chk_fail () from /home/root/work/stack-protector/libc.so.6#5 0x0000862c in check_password (password=0xbebcfed8 'x' &lt;repeats 21 times&gt;) at test_overflow.c:19#6 0x00008674 in main (argc=2, argv=0xbebcfdc4) at test_overflow.c:23(gdb) 3.4 关于编译参数stack-protector介绍见《经验分享：gcc编译参数stack-protector》]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于gst_element_set_state死锁问题调查]]></title>
    <url>%2F2020%2F11%2F26%2F%E5%85%B3%E4%BA%8Egst-element-set-state%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E8%B0%83%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[关于gst_element_set_state死锁问题调查■现象gst_element_set_state 变更GST_STATE_NULL状态时deadlock。 ■再现步骤1.Carlife语音识别时说”鲜花”2.在VR语音提示音的时候播放过程中，按radio硬按键切源 更普遍的再现方法：(也就是说该问题是普遍性问题，与Carlife无直接关系)1.插入U盘播放音乐2.音乐播放过程中，点击暂停3.使用gst-launch-1.0 playbin uri=file:///media/disk/Track02.mp3 播放音乐4.步骤3音乐播放过程中按radio硬按键切源5.按Ctrl+C 结束步骤3的音乐播放，发现无法结束，终端输出以下内容后hangup。Setting pipeline to PAUSED … ■直接原因调用 gst_element_set_state() 函数暂停播放时会调用到alsasink的 gst_alsasink_reset() 函数来重置PCM流，该函数会获取alsa_lock锁，以保证当前正在处理的Buffer中的数据处理结束后重置PCM流。由于alsasink的 gst_alsasink_write() 函数获取alsa_lock锁之后，无法写入最后一包数据，导致该锁无法释放，最终导致 gst_element_set_state() 死锁。也就是说问题发生的时候，声卡的文件句柄无法正常写入。err = snd_pcm_writei() 的返回值是：-11。snd_strerror(err) 打印出来的含义是：”Resource temporarily unavailable”。 ■根本原因切源的时候DSP那边通路被切走，导致alsa的最后一包数据写不进去。此时可以关声卡，但是不能写入数据。通路再切回来就能正常写入，声卡就可以关闭结束。 ■调查详细1）由于Carlife服务线程较多，为了准确定位是哪个线程，设置了线程名”SetNameForA7”1234567891011(gdb) info threads Id Target Id Frame 15 Thread 0xb6588450 (LWP 2718) "SetNameForA7" 0xb6f6e6ee in recv () ★ at ../sysdeps/unix/syscall-template.S:81 14 Thread 0xb5d88450 (LWP 2719) "CarlifeDaemon" __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:43...略... 2 Thread 0xae47a450 (LWP 2993) "TinyVpuDec:src" __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:43* 1 Thread 0xb658a000 (LWP 2717) "CarlifeDaemon" __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:43 ★处是我们要找的”SetNameForA7”线程 2）正常情况下线程2718的状态1234567891011121314151617(gdb) thread 18[Switching to thread 18 (Thread 0xb6588450 (LWP 2718))]#0 0xb6f6e6ee in recv () at ../sysdeps/unix/syscall-template.S:8181 ../sysdeps/unix/syscall-template.S: No such file or directory.(gdb) bt#0 0xb6f6e6ee in recv () at ../sysdeps/unix/syscall-template.S:81#1 0xb6e64f64 in Socket::recv(unsigned char*, unsigned int) const () from /usr/app/carlife/lib/libcarlifevehicle.so ★#2 0xb6e639fa in CConnectManager::readCmdData(unsigned char*, unsigned int) () from /usr/app/carlife/lib/libcarlifevehicle.so...略...#10 0xb6d54ee4 in ?? () from /usr/app/carlife/lib/libboost_thread.so.1.59.0#11 0xb6f6845e in start_thread (arg=0xb6588910) at pthread_create.c:314#12 0xb6905d9c in ?? () at ../ports/sysdeps/unix/sysv/linux/arm/nptl/../clone.S:92 from /lib/arm-linux-gnueabihf/libc.so.6Backtrace stopped: previous frame identical to this frame (corrupt stack?) 该线程用于接收来自手机Carlife的命令通道的消息，recv是阻塞式函数，无消息时阻塞在recv处，属于正常情况。 3）出问题的时候，线程2718的状态123456789101112131415(gdb) thread 17[Switching to thread 17 (Thread 0xb6588450 (LWP 2718))]#0 __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:4343 in ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S(gdb) bt#0 __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:43#1 0xb6f6dffc in __lll_lock_wait (futex=futex@entry=0x835fd8, private=0) at ../ports/sysdeps/unix/sysv/linux/arm/nptl/lowlevellock.c:46#2 0xb6f6a3aa in __GI___pthread_mutex_lock (mutex=0x835fd8) at pthread_mutex_lock.c:134#3 0xb6b88de2 in g_mutex_lock () from /usr/lib/libglib-2.0.so.0 ★#4 0xae4e56a2 in ?? () from /usr/lib/gstreamer-1.0/libgstalsa.soBacktrace stopped: previous frame identical to this frame (corrupt stack?) 可以看出是libgstalsa.so中获取互斥锁的地方deadlock了，此时由于gstreamer的调试信息未打开，所以无法看到完整的调用关系。 4）重新编译gstreamer1.0-plugins-base插件，加-g参数增加调试信息，重新打印堆栈回溯12345678910111213141516171819202122232425(gdb) bt#0 __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:43#1 0xb6eb0ffc in __lll_lock_wait (futex=futex@entry=0x1fe0f30, private=0) at ../ports/sysdeps/unix/sysv/linux/arm/nptl/lowlevellock.c:46#2 0xb6ead3aa in __GI___pthread_mutex_lock (mutex=0x1fe0f30) at pthread_mutex_lock.c:134#3 0xb6acbde2 in g_mutex_lock () from /usr/lib/libglib-2.0.so.0 ★#4 0xac4b86a2 in gst_alsasink_reset (asink=0x1fcede8) at /workspace/MR3/F516/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/ext/alsa/gstalsasink.c:1122#5 0xb03a3a1a in gst_audio_sink_ring_buffer_pause (buf=&lt;optimized out&gt;) at /workspace/MR3/F516/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/audio/gstaudiosink.c:545#6 0xb0387082 in gst_audio_ring_buffer_pause_unlocked ( buf=buf@entry=0x1fd4388) at /workspace/MR3/F516/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/audio/gstaudioringbuffer.c:1006#7 0xb038966c in gst_audio_ring_buffer_pause (buf=0x1fd4388) at /workspace/MR3/F516/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/audio/gstaudioringbuffer.c:1049#8 0xb03a0746 in gst_audio_base_sink_change_state (element=0x1fcede8, transition=GST_STATE_CHANGE_PLAYING_TO_PAUSED) at /workspace/MR3/F516/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gst---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---reamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/audio/gstaudiobasesink.c:2471#9 0xb6702ba2 in gst_element_change_state () from /usr/lib/libgstreamer-1.0.so.0#10 0xb6703004 in ?? () from /usr/lib/libgstreamer-1.0.so.0Backtrace stopped: previous frame identical to this frame (corrupt stack?) 此时可以看出完整的Gstreamer设置管道状态的调用顺序。 5）通过阅读alsasink插件的代码,发现只有gst_alsasink_write()，gst_alsasink_reset()两个函数会获取alsa_lock锁。通过代码分析，唯一可能的原因是 gst_alsasink_write() 中调用 snd_pcm_writei() 函数一直失败。 6）使用” export GST_DEBUG=3,alsa:7”打开alsa插件的日志，下面的日志证实了步骤5）的猜想。 ■附录：下面是 gst_alsasink_write() 和 gst_alsasink_reset() 函数的代码。12345678910111213141516171819202122232425262728293031323334static voidgst_alsasink_reset (GstAudioSink * asink)&#123; GstAlsaSink *alsa; gint err; alsa = GST_ALSA_SINK (asink); GST_ALSA_SINK_LOCK (asink); GST_DEBUG_OBJECT (alsa, "drop"); CHECK (snd_pcm_drop (alsa-&gt;handle), drop_error); GST_DEBUG_OBJECT (alsa, "prepare"); CHECK (snd_pcm_prepare (alsa-&gt;handle), prepare_error); GST_DEBUG_OBJECT (alsa, "reset done"); GST_ALSA_SINK_UNLOCK (asink); return; /* ERRORS */drop_error: &#123; GST_ERROR_OBJECT (alsa, "alsa-reset: pcm drop error: %s", snd_strerror (err)); GST_ALSA_SINK_UNLOCK (asink); return; &#125;prepare_error: &#123; GST_ERROR_OBJECT (alsa, "alsa-reset: pcm prepare error: %s", snd_strerror (err)); GST_ALSA_SINK_UNLOCK (asink); return; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static gintgst_alsasink_write (GstAudioSink * asink, gpointer data, guint length)&#123; GstAlsaSink *alsa; gint err; gint cptr; guint8 *ptr = data; alsa = GST_ALSA_SINK (asink); if (alsa-&gt;iec958 &amp;&amp; alsa-&gt;need_swap) &#123; guint i; guint16 *ptr_tmp = (guint16 *) ptr; GST_DEBUG_OBJECT (asink, "swapping bytes"); for (i = 0; i &lt; length / 2; i++) &#123; ptr_tmp[i] = GUINT16_SWAP_LE_BE (ptr_tmp[i]); &#125; &#125; GST_LOG_OBJECT (asink, "received audio samples buffer of %u bytes", length); cptr = length / alsa-&gt;bpf; GST_ALSA_SINK_LOCK (asink); while (cptr &gt; 0) &#123; /* start by doing a blocking wait for free space. Set the timeout * to 4 times the period time */ err = snd_pcm_wait (alsa-&gt;handle, (4 * alsa-&gt;period_time / 1000)); if (err &lt; 0) &#123; GST_DEBUG_OBJECT (asink, "wait error, %d", err); &#125; else &#123; GST_DELAY_SINK_LOCK (asink); err = snd_pcm_writei (alsa-&gt;handle, ptr, cptr); GST_DELAY_SINK_UNLOCK (asink); &#125; GST_DEBUG_OBJECT (asink, "written %d frames out of %d", err, cptr); if (err &lt; 0) &#123; GST_DEBUG_OBJECT (asink, "Write error: %s", snd_strerror (err)); if (err == -EAGAIN) &#123; continue; &#125; else if (err == -ENODEV) &#123; goto device_disappeared; &#125; else if (xrun_recovery (alsa, alsa-&gt;handle, err) &lt; 0) &#123; goto write_error; &#125; continue; &#125; ptr += snd_pcm_frames_to_bytes (alsa-&gt;handle, err); cptr -= err; &#125; GST_ALSA_SINK_UNLOCK (asink); return length - (cptr * alsa-&gt;bpf);write_error: &#123; GST_ALSA_SINK_UNLOCK (asink); return length; /* skip one period */ &#125;device_disappeared: &#123; GST_ELEMENT_ERROR (asink, RESOURCE, WRITE, (_("Error outputting to audio device. " "The device has been disconnected.")), (NULL)); goto write_error; &#125;&#125;]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局变量导致fwrite崩溃问题分析]]></title>
    <url>%2F2020%2F11%2F26%2F%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AF%BC%E8%87%B4fwrite%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[■问题描述项目Carlife语音识别率不高，录音有卡顿，偶发程序崩溃。 ■原因直接原因：fwrite的文件句柄被覆盖，写文件的时候引发程序崩溃。 根本原因：函数重入导致全局变量设定不正确。引起memcpy拷贝数据的时候将buffer数组写穿，内存越界。 ■分析过程好久没有Dump解析了，用这次机会来练练手，废话不多说，开搞。 1.解析Dump的第一步，不用说bt查看栈的回溯。12345678(gdb) bt#0 __GI__IO_fwrite (buf=0x6ab18 &lt;VrPackageBuffer&gt;, size=1, count=1024, fp=0xfb0afbc4) at iofwrite.c:41#1 0x0003200a in CarlifeMicComponent::CaptureCallBack ( pAppleHandle=&lt;optimized out&gt;, inBuffer=0xaf641050, inLen=4000) at /home/dingyu/Workspace/CarLifeDaemon/src/CarlifeMicComponent.cpp:84#2 0xb6d32e0a in ?? ()Backtrace stopped: previous frame identical to this frame (corrupt stack?) 这个结果看，fp=0xfb0afbc4很可疑，哪有文件句柄这么大的。 2.接下来我们看一下当前栈帧的寄存器信息。1234567891011121314151617181920212223(gdb) info rr0 0x6ab18 437016r1 0x1 1r2 0x400 1024r3 0xfb0afbc4 4211801028r4 0xfb0afbc4 4211801028r5 0x400 1024r6 0x0 0r7 0x6aa08 436744r8 0xfa0 4000r9 0xaf641050 2942570576r10 0x6ab18 437016r11 0x0 0r12 0x6a5c8 435656sp 0xab5ce6c0 0xab5ce6c0lr 0x3200b 204811pc 0xb6865bd4 0xb6865bd4 &lt;__GI__IO_fwrite+16&gt;cpsr 0x200f0030 537854000r12 0x6a5c8 435656sp 0xab5ce6c0 0xab5ce6c0lr 0x3200b 204811#pc 0xb6865bd4 0xb6865bd4 &lt;__GI__IO_fwrite+16&gt;cpsr 0x200f0030 537854000 3.下一跳是什么导致崩溃的。1234567891011121314(gdb) disassemble 0xb6865bd4Dump of assembler code for function __GI__IO_fwrite: 0xb6865bc4 &lt;+0&gt;: stmdb sp!, &#123;r4, r5, r6, r7, r8, r9, lr&#125; 0xb6865bc8 &lt;+4&gt;: mul.w r5, r2, r1 0xb6865bcc &lt;+8&gt;: sub sp, #12 0xb6865bce &lt;+10&gt;: cmp r5, #0 0xb6865bd0 &lt;+12&gt;: beq.n 0xb6865cb2 &lt;__GI__IO_fwrite+238&gt; 0xb6865bd2 &lt;+14&gt;: mov r4, r3#=&gt; 0xb6865bd4 &lt;+16&gt;: ldr r3, [r3, #0] 0xb6865bd6 &lt;+18&gt;: mov r6, r0 0xb6865bd8 &lt;+20&gt;: mov r8, r2 0xb6865bda &lt;+22&gt;: mov r7, r1 0xb6865bdc &lt;+24&gt;: ands.w r3, r3, #32768 ; 0x8000 0xb6865be0 &lt;+28&gt;: bne.n 0xb6865c22 &lt;__GI__IO_fwrite+94&gt; 这句话的意思是: 将存储器地址为r3+0的字数据读入寄存器r3 4.我们来访问一下寄存器r3中地址存放的东西。12(gdb) x/x 0xfb0afbc40xfb0afbc4: Cannot access memory at address 0xfb0afbc4 尼玛，居然不能访问，看来是文件句柄被什么覆盖了。 5.被什么覆盖了呢？这下我们要看一下文件句柄在代码里面的位置，无非是被它的邻居覆盖了。CarlifeMicComponent.cpp123456789static char SpeakerInBuffer[MIC_VCP_BUFFER_SIZE + 1];static char MicInBuffer[MIC_VCP_BUFFER_SIZE + 1];static char AecOutBuffer[MIC_VCP_BUFFER_SIZE + 1];static char VrPackageBuffer[DEF_VR_PACKAGE_LENTH + MIC_VCP_BUFFER_SIZE + 1];static FILE *fpMicOrg = NULL;static FILE *fpMicOut = NULL;static const char *pEnv = NULL; 文件句柄是全局静态变量，应该是全局区域的东西把它覆盖了，基本可以排除堆和栈上的数据覆盖文件句柄。上面4个静态全局数组的嫌疑最大。 6.接下来该干什么呢？毫无疑问，把内存中全局变量区域的内容都打印出来。怎么打印呢？还记得bt打印栈回溯额时候fwrite的入参吗？12#0 __GI__IO_fwrite (buf=0x6ab18 &lt;VrPackageBuffer&gt;, size=1, count=1024, fp=0xfb0afbc4) at iofwrite.c:41 这个不就是全局变量区域的地址嘛。好的，我们一步步吧所有变量的值都打印出来，方法比较死板，就是不停的打。往0x6ab18这块内存的上面，下面都打印出来看看。 打印出来整理一下，大概是这样的：(为了看的更清楚，字体隔行变灰)12345678910111213141516170x6aa08 &lt;_ZL11MicInBuffer&gt;: 0xfc98fda2......0x6ab08 &lt;_ZL11MicInBuffer+256&gt;: 0x00000100#0x6ab0c &lt;_ZL8fpMicOrg&gt;: 0xb0113b500x6ab10 &lt;_ZL11bECNREnable&gt;: 0x00000000#0x6ab14 &lt;_ZZN19CarlifeMicComponent15CaptureCallBackEPvPKviE12iVrDataIndex&gt;: 0x000006000x6ab18 &lt;_ZL15VrPackageBuffer&gt;: 0xfe32fa9f 0xfb05ff0b 0xfbdbfe75 0xfd14fdf7.......0x6b018 &lt;_ZL15VrPackageBuffer+1280&gt;: 0xfc98fda2 0xfd12fd81 0xfb0afbc4 0xfd94fbfe#0x6b020 &lt;_ZL8fpMicOut&gt;: 0xfb0afbc40x6b024 &lt;_ZZN19CarlifeMicComponent15CaptureCallBackEPvPKviE15iValidDataIndex&gt;: 0xfd94fbfe#0x6b028 &lt;_ZL15RecodeStartFlag&gt;: 0xfee7fc7e0x6b02c &lt;_ZL15pCarlifeService&gt;: 0xfff90124#0x6b030 &lt;_ZL4pEnv&gt;: 0xffc000e70x6b034 &lt;_ZL15SpeakerInBuffer&gt;: 0x00a50016......0x6b134 &lt;_ZL15SpeakerInBuffer+256&gt;: 0x00000000 凶手出来了iVrDataIndex 看代码这个变量不应该超过1024个字节，代码里面只有一处赋值，并且一到1024个字节就至0了。1234567891011121314151617181920&#123; //DEBUG("cpn: %d\n", MIC_VCP_BUFFER_SIZE); memcpy(VrPackageBuffer + iVrDataIndex, MicInBuffer, MIC_VCP_BUFFER_SIZE);&#125;iVrDataIndex += MIC_VCP_BUFFER_SIZE;if(iVrDataIndex &gt;= DEF_VR_PACKAGE_LENTH)&#123; DEBUG("%s: %d!\n", bECNREnable?"cpe":"cpn", DEF_VR_PACKAGE_LENTH); pTempInstance-&gt;sendVRRecordData(VrPackageBuffer, DEF_VR_PACKAGE_LENTH, 0); if((true == bSavePcmEnable) &amp;&amp; (NULL != fpMicOut)) &#123; PRINT("fp_write:%p\n",fpMicOut); fwrite(VrPackageBuffer, 1, DEF_VR_PACKAGE_LENTH, fpMicOut); //fwrite(MicInBuffer, 1, MIC_VCP_BUFFER_SIZE, fpMicOut); &#125; iVrDataIndex = 0;&#125; 唯一的可能性是这个函数被同时多次调用，又是全局变量惹的祸。 其实后面还有很多工作要做，比如证实iVrDataIndex变量没有问题，没有被覆盖。算一下0x00000600的十进制1536，正好是256的6倍。这下放心了。如果你是个完美主义者，可以这样做，打印从0x6ab18 地址往后打印1535个字节。你会发现最后停在SpeakerInBuffer数组中，之后的数据都是0，完全符合代码逻辑。 0x6ab14 : 0x00000600]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于解码Carlife的h264视频流时程序Dump的调查]]></title>
    <url>%2F2020%2F11%2F26%2F%E5%85%B3%E4%BA%8E%E8%A7%A3%E7%A0%81Carlife%E7%9A%84h264%E8%A7%86%E9%A2%91%E6%B5%81%E6%97%B6%E7%A8%8B%E5%BA%8FDump%E7%9A%84%E8%B0%83%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[关于解码Carlife的h264视频流时程序Dump的调查■现象carlife黑屏。 ■再现步骤1.Iphone手机carlife版本更新至6.0及以上（5.9版本的手机carlife没有此现象） 2.A7项目有carlife功能的车机 （目前尝试了其他项目的A7车机均有此现象。I6平台的项目或使用PC软件播放Carlife的h264数据没有此现象） 3.连接carlife成功后，点击手机home键退到主界面，车机carlife功能黑屏（程序崩溃） ■根本原因直接原因：通过捕获Core文件，使用gdb调试，发现omx代码调用gstreamer接口一路调用到__memcpy_neon时程序Dump。 memcpy拷贝的源地址是非法的地址。 123456789101112131415L127: memcpy (dinfo.data, sinfo.data +offset, size);(gdb) p sinfo$1 = &#123;memory = 0xaf704da0, flags =GST_MAP_READ, data = 0xac167000 &lt;error: Cannot accessmemory at address 0xac167000&gt;, ★非法地址size = 559104, maxsize = 559104, user_data= &#123;0xb6fceab8, 0xb65a019b, 0xb683fda0, 0xb659c0e0&#125;, _gst_reserved =&#123;0x1, 0x7270e000, 0xaca77688, 0x0&#125;&#125; 诱因： 在对Carlife传输给车机的H264码流进行解码时， 我们发现SPS信息中level-id字段会随着Carlife应用在前后台改变而改变。 具体说： Carlife手机应用在前台时SPS信息：00 00 0001 27 42 00 1F &lt;—（level-id：1F） Carlife手机应用在后台时SPS信息：00 00 0001 27 42 00 20 &lt;—（level-id：20） 通过与高通沟通，得知Level 3.1（level-id：1F）和3.2（level-id：20） 所支持的视频解析度范围不同，解码器一般会通过该值进行重新配置。 相同解析度的情况下，如果从level 3.1 改成level 3.2不利于解码的稳定性。 根本原因:高通调查后承认自己解码器的Bug，提供walkaround方案。没有考虑视频播放过程中重新配置解码器的情况。 ■调查详细调试小插曲 一开始直接使用gdb解析CoreDump的时候发现，bt打出来的信息都是？号，无疑这是因为我们的程序没有带-g编译参数，没有符号导致的。 加完-g参数重新编译后，可以完整的显示出了堆栈信息，但是没有行号信息。从gdb的提示信息可以看出，符号是正确加载了，很奇怪。 经过很多尝试之后，决定尝试替换车机里其他人拷贝进去的gdb，使用我在A7平台下编译生成的gdb命令，这下显示了所有想要的东西。 调试开始下面开始展示真正的实力了：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173# gdb /usr/app/carlife/CarlifeDaemon ./TinyVpuDec\:src_14988678226_2254.coreCore was generated by `/usr/app/carlife/CarlifeDaemon -i'.Program terminated with signal SIGSEGV, Segmentation fault.#0 __memcpy_neon () at ../ports/sysdeps/arm/armv7/multiarch/memcpy_impl.S:568568 ../ports/sysdeps/arm/armv7/multiarch/memcpy_impl.S: No such file or directory.(gdb) bt#0 __memcpy_neon () at ../ports/sysdeps/arm/armv7/multiarch/memcpy_impl.S:568#1 0xb6855ff2 in _fallback_mem_copy (mem=0xaf704da0, offset=0, size=559104) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstallocator.c:127#2 0xb685e3a6 in gst_buffer_copy_into (dest=0xaf711020, src=0xaf705ca0, flags=(GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_META | GST_BUFFER_COPY_MEMORY | GST_BUFFER_COPY_DEEP), offset=0, size=559104) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstbuffer.c:498#3 0xb685e5bc in gst_buffer_copy_with_flags (buffer=0xaf705ca0, flags=(GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_META | GST_BUFFER_COPY_MEMORY | GST_BUFFER_COPY_DEEP)) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstbuffer.c:579#4 0xb65b4cbc in gst_base_sink_drain (basesink=0x15ff3f8) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/libs/gst/base/gstbasesink.c:4918#5 0xb65b8e78 in gst_base_sink_default_query (basesink=0x15ff3f8, query=0xaf70bc90) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/libs/gst/base/gstbasesink.c:4941#6 0xb688a152 in gst_pad_query (pad=pad@entry=0x15e2960, query=query@entry=0xaf70bc90)---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstpad.c:3831#7 0xb688a624 in gst_pad_peer_query (pad=0x15e2810, query=query@entry=0xaf70bc90) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstpad.c:3962#8 0xb03d1242 in gst_video_decoder_negotiate_pool (decoder=0x15f6158, caps=&lt;optimized out&gt;) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/video/gstvideodecoder.c:3696#9 0xb03d585a in gst_video_decoder_negotiate (decoder=decoder@entry=0x15f6158) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/video/gstvideodecoder.c:3872#10 0xb032cd92 in gst_omx_video_dec_reconfigure_output_port ( crop_rect=0xb0111168, crop_rect=0xb0111168, self=0x15f6158) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gst-omx/1.2-r0/git/omx/gstomxvideodec.c:1722#11 gst_omx_video_dec_loop (self=0x15f6158) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gst-omx/1.2-r0/git/omx/gstomxvideodec.c:1956#12 0xb68ab9ce in gst_task_func (task=0xb01136b8)---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gsttask.c:331#13 0xb6d06410 in g_thread_pool_thread_proxy (data=&lt;optimized out&gt;) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/cortexa7hf-vfp-poky-linux-gnueabi/glib-2.0/1_2.40.0-r0/glib-2.40.0/glib/gthreadpool.c:307#14 0xb6d05d02 in g_thread_proxy (data=0xaf702b80) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/cortexa7hf-vfp-poky-linux-gnueabi/glib-2.0/1_2.40.0-r0/glib-2.40.0/glib/gthread.c:764#15 0xb6b5145e in start_thread (arg=0xaca78910) at pthread_create.c:314#16 0xb699dd9c in ?? () at ../ports/sysdeps/unix/sysv/linux/arm/nptl/../clone.S:92 from /lib/arm-linux-gnueabihf/libc.so.6Backtrace stopped: previous frame identical to this frame (corrupt stack?)(gdb) frame 1#1 0xb6855ff2 in _fallback_mem_copy (mem=0xaf704da0, offset=0, size=559104) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstallocator.c:127127 /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstallocator.c: No such file or directory.# 结合代码可以发现，程序执行L127: memcpy (dinfo.data, sinfo.data +offset, size);时Dump了# 这时我们需要看一下pc指针指向什么地方Dump的。于是我们查看寄存器的信息。(gdb) info rr0 0xac1f0058 2887712856r1 0xac167000 2887151616r2 0x88800 559104r3 0x0 0r4 0x88800 559104r5 0xac1f0008 2887712776r6 0xaf704da0 2943372704r7 0xb69064b4 3062916276r8 0x88800 559104r9 0xaca775f0 2896655856r10 0x0 0r11 0xaca77624 2896655908r12 0xac1f0058 2887712856sp 0xaca775b8 0xaca775b8lr 0xb6855ff3 -1232773133pc 0xb6855ff2 0xb6855ff2 &lt;_fallback_mem_copy+118&gt;cpsr 0x200e0030 537788464# 看下pc指向的是汇编哪一行(gdb) disassemble r 0xb68e52b4 &lt;+372&gt;: strne r3, [r12], #4 0xb68e52b8 &lt;+376&gt;: lsls r8, r8, #31 0xb68e52bc &lt;+380&gt;: ldrhcs r3, [r1], #2 0xb68e52c0 &lt;+384&gt;: ldrbne r8, [r1] 0xb68e52c4 &lt;+388&gt;: strhcs r3, [r12], #2 0xb68e52c8 &lt;+392&gt;: strbne r8, [r12] 0xb68e52cc &lt;+396&gt;: pop &#123;r8&#125; ; (ldr r8, [sp], #4) 0xb68e52d0 &lt;+400&gt;: bx lr=&gt; 0xb68e52d4 &lt;+404&gt;: vldr d3, [r1] 0xb68e52d8 &lt;+408&gt;: vldr d4, [r1, #64] ; 0x40 0xb68e52dc &lt;+412&gt;: vldr d5, [r1, #128] ; 0x80 0xb68e52e0 &lt;+416&gt;: vldr d6, [r1, #192] ; 0xc0 0xb68e52e4 &lt;+420&gt;: vldr d7, [r1, #256] ; 0x100 0xb68e52e8 &lt;+424&gt;: vldr d0, [r1, #8] 0xb68e52ec &lt;+428&gt;: vldr d1, [r1, #16]# 从汇编代码可以看出来，程序是加载 r1 寄存器中存放的地址时Dump了，访问了无法访问的内存。# 我们看下代码L127: memcpy (dinfo.data, sinfo.data +offset, size);再看一下我们数据的拷贝源是什么，很明显sinfo.data无法访问。(gdb) p sinfo$1 = &#123;memory = 0xaf704da0, flags = GST_MAP_READ, data = 0xac167000 &lt;error: Cannot access memory at address 0xac167000&gt;, size = 559104, maxsize = 559104, user_data = &#123;0xb6fceab8, 0xb65a019b, 0xb683fda0, 0xb659c0e0&#125;, _gst_reserved = &#123;0x1, 0x7270e000, 0xaca77688, 0x0&#125;&#125;# 让我们的显示变得漂亮一点(gdb) set print pretty on# 我们回到栈帧1，为什么要到栈帧1呢？栈帧0是memcpy函数，我们打印不了我们想要看的参数mem# 那我们为什么要看mem呢？很简单，sinfo是怎么来的，通过阅读代码是由mem拷贝过来的。(gdb) frame 1#1 0xb67ebff2 in _fallback_mem_copy (mem=0xaf604da8, offset=0, size=559104) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstallocator.c:127127 /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstallocator.c: No such file or directory.(gdb) info rr0 0xac175058 2887209048r1 0xac0ec000 2886647808r2 0x88800 559104r3 0x0 0r4 0x88800 559104r5 0xac175008 2887208968r6 0xaf604da8 2942324136r7 0xb689c4b4 3062482100r8 0x88800 559104r9 0xac9fc5f0 2896152048r10 0x0 0r11 0xac9fc624 2896152100r12 0xac175058 2887209048sp 0xac9fc5b8 0xac9fc5b8lr 0xb67ebff3 -1233207309pc 0xb67ebff2 0xb67ebff2 &lt;_fallback_mem_copy+118&gt;cpsr 0x200e0030 537788464(gdb) p sinfo$4 = &#123; memory = 0xaf604da8, flags = GST_MAP_READ, data = 0xac0ec000 &lt;error: Cannot access memory at address 0xac0ec000&gt;, size = 559104, maxsize = 559104, user_data = &#123;0xb6f64ab8, 0xb653619b, 0xb67d5da0, 0xb65320e0&#125;, _gst_reserved = &#123;0x1, 0x8583b000, 0xac9fc688, 0x0&#125;&#125;(gdb) p *(GstMemorySystem *)(mem)$6 = &#123; mem = &#123; mini_object = &#123; type = 1980632, refcount = 3, lockstate = 131329, flags = 1, copy = 0xb6817489 &lt;_gst_memory_copy&gt;, dispose = 0xb0280055, free = 0xb6816f49 &lt;_gst_memory_free&gt;, n_qdata = 0, qdata = 0x0 &#125;, allocator = 0xaf60f048, parent = 0x0, maxsize = 559104, align = 0, offset = 0, size = 559104 &#125;, slice_size = 0, data = 0xaf610398 "\001", user_data = 0xac0ec000, ---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- notify = 0xffffffff, map_mode = 0&#125; 来，我们看看gstallocator.c:127的代码，gst_memory_map (mem, &amp;sinfo, GST_MAP_READ)在这个地方，给sinfo赋值了，具体怎么赋值的呢？我们需要深入到gst_memory_map 函数123456789101112131415161718192021222324252627282930313233343536373839404142gbooleangst_memory_map (GstMemory * mem, GstMapInfo * info, GstMapFlags flags)&#123; g_return_val_if_fail (mem != NULL, FALSE); g_return_val_if_fail (info != NULL, FALSE); if (!gst_memory_lock (mem, (GstLockFlags) flags)) goto lock_failed; info-&gt;flags = flags; info-&gt;memory = mem; info-&gt;size = mem-&gt;size; info-&gt;maxsize = mem-&gt;maxsize - mem-&gt;offset; if (mem-&gt;allocator-&gt;mem_map_full) info-&gt;data = mem-&gt;allocator-&gt;mem_map_full (mem, info, mem-&gt;maxsize); else info-&gt;data = mem-&gt;allocator-&gt;mem_map (mem, mem-&gt;maxsize, flags); // ★该函数 if (G_UNLIKELY (info-&gt;data == NULL)) goto error; info-&gt;data = info-&gt;data + mem-&gt;offset; return TRUE; /* ERRORS */lock_failed: &#123; GST_CAT_DEBUG (GST_CAT_MEMORY, "mem %p: lock %d failed", mem, flags); memset (info, 0, sizeof (GstMapInfo)); return FALSE; &#125;error: &#123; /* something went wrong, restore the orginal state again */ GST_CAT_ERROR (GST_CAT_MEMORY, "mem %p: subclass map failed", mem); gst_memory_unlock (mem, (GstLockFlags) flags); memset (info, 0, sizeof (GstMapInfo)); return FALSE; &#125;&#125; 12//gstallocator.c alloc-&gt;mem_map = (GstMemoryMapFunction) _sysmem_map; 123456//gstallocator.cstatic gpointer_sysmem_map (GstMemorySystem * mem, gsize maxsize, GstMapFlags flags)&#123; return mem-&gt;data;&#125; 一开始，以为就是这个函数，但是后来发现不是，思考了一下这个应该就是C语言实现多态的方式。那是怎么知道不是这个函数的呢？增加断点调试。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182(gdb) attach pid（CarlifeDaemon）(gdb) b gstallocator.c:106# 复现问题后继续运行到断点(gdb) c# 锁定当前线程，因为gstmemory.c中的函数会在很多地方调用到，不锁定的话会停在别的线程(gdb) set scheduler-locking on (gdb) b gstmemory.c:309(gdb) c# 为了能够进入mem_map函数调试，我在_sysmem_map函数处加了断点，但是死活进不去，于是我一步步，打印mem-&gt;allocator 的所有成员看看mem_map的函数地址。(gdb) p *(GstAllocator*)mem-&gt;allocator $4 = &#123; object = &#123; object = &#123; g_type_instance = &#123; g_class = 0xaf6138d0 &#125;, ref_count = 17, qdata = 0x2 &#125;, lock = &#123; p = 0xaf60a600, i = &#123;2942346752, 0&#125; &#125;, name = 0xaf60ccb0 "TinyVideoSink:pool:sink:allocator", parent = 0x0, flags = 66060304, control_bindings = 0x0, control_rate = 100000000, last_sync = 18446744073709551615, _gst_reserved = 0x0 &#125;, mem_type = 0xb02bafb8 "V4l2Memory", mem_map = 0xb029efe9, # 需要关注的函数地址---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- mem_unmap = 0xb029ef7d, mem_copy = 0xb6766f7d &lt;_fallback_mem_copy&gt;, mem_share = 0xb029fcc5, mem_is_span = 0xb029ef0d, mem_map_full = 0x0, mem_unmap_full = 0x0, _gst_reserved = &#123;0x0, 0x0&#125;, priv = 0xaf60d040&#125;No function contains specified address.(gdb) x 0xb029efe90xb029efe9: 0x924b146c# 其他调用的地方(gdb) p *(GstAllocator*)mem-&gt;allocator $6 = &#123; object = &#123; object = &#123; g_type_instance = &#123; g_class = 0x1c81ac8 &#125;, ref_count = 7, qdata = 0x2 &#125;, lock = &#123; p = 0x1c81b78, i = &#123;29891448, 0&#125; &#125;, name = 0x1c80950 "allocatorsysmem0", parent = 0x0, flags = 0, control_bindings = 0x0, control_rate = 100000000, last_sync = 18446744073709551615, _gst_reserved = 0x0 &#125;, mem_type = 0xb67db1d4 "SystemMemory", mem_map = 0xb67667dd &lt;_sysmem_map&gt;, # 需要关注的函数地址---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- mem_unmap = 0xb67667e1 &lt;_sysmem_unmap&gt;, mem_copy = 0xb6766a49 &lt;_sysmem_copy&gt;, mem_share = 0xb6766b65 &lt;_sysmem_share&gt;, mem_is_span = 0xb67667e5 &lt;_sysmem_is_span&gt;, mem_map_full = 0x0, mem_unmap_full = 0x0, _gst_reserved = &#123;0x0, 0x0&#125;, priv = 0x1c83c18&#125; 同样的函数指针，指向了不同的函数实现，然而这块代码我们没有，没有办法知道如何赋值的，只知道现在sinfo.data = 0xac0ec000是(GstMemorySystem )(mem)的user_data]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USB之OTG]]></title>
    <url>%2F2020%2F11%2F26%2FOTG-roleswitch%2F</url>
    <content type="text"><![CDATA[OTG roleswitch(Apple CarPlay)关于roleswitch驱动层状态机变化流程插入时的状态 车机作为 a_host 手机作为 b_peripheral 车机枚举手机，完成正常的USB枚举。 roleswitch时的状态 车机发送私有协议（见下图）给手机，通知手机切成 b_host。 此时VBUS仍然是车机供电。手机会一直枚举车机。只要车机状态变更到 a_peripheral，就能枚举成功。 车机触发状态机进行状态机变换，最终切到 a_periphera l状态。 手机枚举车机，完成一次正常的USB枚举。 拔出后的状态 车机切回 a_wait_bcon 状态。 手机切回 b_wait_acon 状态。 OTG 状态机转换A Device状态机 B Device状态机 其他苹果roleswitch私有协议文档说明 ATS 抓包数据 内核状态机日志开关 一次完整的roleswitch过程日志1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 插入手机前[ 2318.493379] Set state: a_wait_bcon[ 2318.496097] usb 1-1: USB disconnect, device number 12# 插入手机[ 2321.151592] Set state: a_host[ 2321.424758] usb 1-1: new high-speed USB device number 13 using ci_hdrc[ 2321.578095] usb 1-1: New USB device found, idVendor=05ac, idProduct=12a8[ 2321.581955] usb 1-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3[ 2321.593696] usb 1-1: Product: iPhone[ 2321.594498] usb 1-1: Manufacturer: Apple Inc.[ 2321.603727] usb 1-1: SerialNumber: 2330bb40ef6c37782d9675fe9d086467f49f031e[ 2321.610365] usb 1-1: Second configuration choosed for Apple MFi device.[ 2321.627515] usb 1-1: 1:1: cannot get freq at ep 0x81[ 2321.650139] hid-generic 0003:05AC:12A8.000C: device has no listeners, quitting# 触发roleswitch[ 2348.700349] Set state: a_suspend[ 2348.700929] usb 1-1: USB disconnect, device number 13 q[ 2348.825643] Set state: a_peripherallatform/devices/ci_hdrc.0/inputs/a_bus_req [ 2348.826318] ci_hdrc ci_hdrc.0: remove, state 1[ 2348.830757] usb usb1: USB disconnect, device number 1[ 2348.847613] ci_hdrc ci_hdrc.0: USB bus 1 deregistered[ 2348.849891] ci_otg_start_host off [ 2348.853548] ci_otg_start_gadget on [ 2349.038270] g_ncm gadget: high-speed config #1: CDC Ethernet (NCM)[ 2349.041631] g_ncm gadget: source/sink enabled, alt intf 0[ 2349.046989] g_ncm gadget: init ncm ctrl 1[ 2349.050985] g_ncm gadget: notify speed 425984000# 拔出手机[ 2867.624758] g_ncm gadget: suspend[ 2868.123519] Set state: a_wait_bcon[ 2868.124092] g_ncm gadget: reset config[ 2868.127819] g_ncm gadget: ncm deactivated[ 2868.131941] ci_otg_start_gadget off [ 2868.136118] ci_hdrc ci_hdrc.0: EHCI Host Controller[ 2868.140452] ci_hdrc ci_hdrc.0: new USB bus registered, assigned bus number 1[ 2868.164755] ci_hdrc ci_hdrc.0: USB 2.0 started, EHCI 1.00[ 2868.167567] usb usb1: New USB device found, idVendor=1d6b, idProduct=0002[ 2868.174095] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1[ 2868.181399] usb usb1: Product: EHCI Host Controller[ 2868.186288] usb usb1: Manufacturer: Linux 3.18.41 ehci_hcd[ 2868.191621] usb usb1: SerialNumber: ci_hdrc.0[ 2868.198254] hub 1-0:1.0: USB hub found[ 2868.199797] hub 1-0:1.0: 1 port detected[ 2868.206021] ci_otg_start_host on 内核各种状态的查询方法12345678910111213141516171819202122232425root@atlas7-arm:/sys/kernel/debug/ci_hdrc.0# cat otg OTG state: a_hosta_bus_drop: 0a_bus_req: 1a_srp_det: 0a_vbus_vld: 1b_conn: 1adp_change: 0power_up: 0a_bus_resume: 0a_bus_suspend: 0a_conn: 0b_bus_req: 0b_bus_suspend: 0b_se0_srp: 0b_ssend_srp: 0b_sess_vld: 0b_srp_done: 0drv_vbus: 1loc_conn: 0loc_sof: 1adp_prb: 0id: 0protocol: 1 内核个节点含义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-platform-chipidea-usb-otgWhat: /sys/bus/platform/devices/ci_hdrc.0/inputs/a_bus_reqDate: Feb 2014Contact: Li Jun &lt;jun.li@nxp.com&gt;Description: Can be set and read. Set a_bus_req(A-device bus request) input to be 1 if the application running on the A-device wants to use the bus, and to be 0 when the application no longer wants to use the bus(or wants to work as peripheral). a_bus_req can also be set to 1 by kernel in response to remote wakeup signaling from the B-device, the A-device should decide to resume the bus. Valid values are &quot;1&quot; and &quot;0&quot;. Reading: returns 1 if the application running on the A-device is using the bus as host role, otherwise 0.What: /sys/bus/platform/devices/ci_hdrc.0/inputs/a_bus_dropDate: Feb 2014Contact: Li Jun &lt;jun.li@nxp.com&gt;Description: Can be set and read The a_bus_drop(A-device bus drop) input is 1 when the application running on the A-device wants to power down the bus, and is 0 otherwise, When a_bus_drop is 1, then the a_bus_req shall be 0. Valid values are &quot;1&quot; and &quot;0&quot;. Reading: returns 1 if the bus is off(vbus is turned off) by A-device, otherwise 0.What: /sys/bus/platform/devices/ci_hdrc.0/inputs/b_bus_reqDate: Feb 2014Contact: Li Jun &lt;jun.li@nxp.com&gt;Description: Can be set and read. The b_bus_req(B-device bus request) input is 1 during the time that the application running on the B-device wants to use the bus as host, and is 0 when the application no longer wants to work as host and decides to switch back to be peripheral. Valid values are &quot;1&quot; and &quot;0&quot;. Reading: returns if the application running on the B device is using the bus as host role, otherwise 0.What: /sys/bus/platform/devices/ci_hdrc.0/inputs/a_clr_errDate: Feb 2014Contact: Li Jun &lt;jun.li@nxp.com&gt;Description: Only can be set. The a_clr_err(A-device Vbus error clear) input is used to clear vbus error, then A-device will power down the bus. Valid value is &quot;1&quot;]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ID3信息]]></title>
    <url>%2F2020%2F11%2F26%2FID3%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[ID3信息Taglib 网址：https://taglib.org/ 代码：https://github.com/xuleilx/taglib/ 实例：https://github.com/xuleilx/taglib/tree/master/examples 新增读取图片实例 Gstreamer123456789101112131415161718192021222324# gst-discoverer-1.0 /media/disk/USB/music/123.mp3Analyzing file:///media/disk/USB/music/123.mp3Done discovering file:///media/disk/USB/music/123.mp3Topology: unknown: ID3 tag audio: MPEG-1 Layer 3 (MP3)Properties: Duration: 0:04:59.339660934 Seekable: yes Tags: container format: ID3 tag ID3v2 frame: buffer of 23 bytes image: buffer of 5926 bytes, type: image/jpeg, width=(int)150, height=(int)150, sof-marker=(int)0 album: 十一月的萧邦 artist: 周杰伦 title: 发如雪 has crc: false channel mode: joint-stereo audio codec: MPEG-1 Layer 3 (MP3) nominal bitrate: 128000 bitrate: 127706]]></content>
      <tags>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟内存管理]]></title>
    <url>%2F2020%2F10%2F29%2F%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-md%2F</url>
    <content type="text"><![CDATA[虚拟内存管理虚拟内存虚拟内存的起因 存储器层次结构 访问时间 Registers 1 nsec Cache 2 nsec Main Memory 10 nsec Magnetic disk 10 msec Magnetic tape 100 sec 覆盖技术覆盖技术：相互之间没有调用关系的程序模块之间。 1.对于一个进程，不需要一开始就把程序的全部指令和数据都装入内存再执行。2.程序划分为若干个功能上相对独立的程序段，按照程序逻辑结构让那些不需要同时执行的程序段共享同一块内存区3.当有关程序段的先头程序段已经执行结束后，再把后续程序段从外存调入内存覆盖前面的程序段 交换技术swap技术：swap out、swap in。内存和硬盘之间。 对象是进程，等待状态的进程驻留内存会造成存储空间的浪费。因此，有必要把处于等待状态的进程换出内存。 虚存技术利用程序的局部性。一页4K大小。基本特征：1.大的用户空间：物理内存+外存2.部分交换3.不连续性：分配不连续，使用不连续 后备存储Backing Store（二级存储）数据，代码，动态库swap file ：程序运行过程中产生的数据 页面置换算法局部页面置换 最优置换算法（OPT）：预测未来，难以实现 先进先出（FIFO）：最简单，性能差 最近最久未使用（LRU）：由过去预测未来，接近OPT，开销大。 时钟算法（Clock）：性能接近LRU，高效，开销小 二次机会法（Enhanced Clock）：Clock算法的改进，增加读写位判断，减少写页被置换 最不常用算法（LFU） Belady现象：一些算法会导致导致不会因为物理页增加，内存访问减少。有时候反而增加内存访问。一般来讲，物理页增加，访问内存的次数会减少，极限情况物理页包含了所有内存。 全局页面置换 工作集置换算法 缺页率置换算法 针对多个程序同时运行，全局页面置换算法优于局部页面置换算法，全局页面置换算法可以动态调整分配给每个程序内存页的大小 内存抖动 进程太多，分配给每个进程的物理页面太少，不能包含工作集 造成大量缺页，频繁置换 进程运行速度变慢 操作系统需要在并发水平和缺页率之间达到一个平衡 选择适当的程序数目和进程需要的物理页数目 LAB3实验12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 给未被映射的地址映射上物理页/*LAB3 EXERCISE 1: YOUR CODE * Maybe you want help comment, BELOW comments can help you finish the code * * Some Useful MACROs and DEFINEs, you can use them in below implementation. * MACROs or Functions: * get_pte : get an pte and return the kernel virtual address of this pte for la * if the PT contians this pte didn't exist, alloc a page for PT (notice the 3th parameter '1') * pgdir_alloc_page : call alloc_page &amp; page_insert functions to allocate a page size memory &amp; setup * an addr map pa&lt;---&gt;la with linear address la and the PDT pgdir * DEFINES: * VM_WRITE : If vma-&gt;vm_flags &amp; VM_WRITE == 1/0, then the vma is writable/non writable * PTE_W 0x002 // page table/directory entry flags bit : Writeable * PTE_U 0x004 // page table/directory entry flags bit : User can access * VARIABLES: * mm-&gt;pgdir : the PDT of these vma * *//* * try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT. * (notice the 3th parameter '1') */// 1. 页目录中找页表，如果没有就创建一个页表// 2. 页表中查找包含addr地址的页表项if ( (ptep = get_pte( mm-&gt;pgdir, addr, 1 ) ) == NULL )&#123; cprintf( "get_pte in do_pgfault failed\n" ); goto failed;&#125;// 如果找到的页表项为空，分配页并映射到页表中if ( *ptep == 0 ) /* if the phy addr isn't exist, then alloc a page &amp; map the phy addr with logical addr */&#123; if ( pgdir_alloc_page( mm-&gt;pgdir, addr, perm ) == NULL ) &#123; cprintf( "pgdir_alloc_page in do_pgfault failed\n" ); goto failed; &#125;&#125;else &#123; // 找到页表项 /*LAB3 EXERCISE 2: YOUR CODE * Now we think this pte is a swap entry, we should load data from disk to a page with phy addr, * and map the phy addr with logical addr, trigger swap manager to record the access situation of this page. * * Some Useful MACROs and DEFINEs, you can use them in below implementation. * MACROs or Functions: * swap_in(mm, addr, &amp;page) : alloc a memory page, then according to the swap entry in PTE for addr, * find the addr of disk page, read the content of disk page into this memroy page * page_insert ： build the map of phy addr of an Page with the linear addr la * swap_map_swappable ： set the page swappable */ /* * if this pte is a swap entry, then load data from disk to a page with phy addr * and call page_insert to map the phy addr with logical addr */ // 如果找到的页表项是需要swap的，swap it if ( swap_init_ok ) &#123; struct Page *page = NULL; if ( (ret = swap_in( mm, addr, &amp;page ) ) != 0 ) &#123; cprintf( "swap_in in do_pgfault failed\n" ); goto failed; &#125; page_insert( mm-&gt;pgdir, page, addr, perm ); swap_map_swappable( mm, addr, page, 1 ); &#125;else &#123; cprintf( "no swap_init_ok but ptep is %x, failed\n", *ptep ); goto failed; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// 基于FIFO的页面替换算法/* * (3)_fifo_map_swappable: According FIFO PRA, we should link the most recent arrival page at the back of pra_list_head qeueue */static int_fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)&#123; list_entry_t *head=(list_entry_t*) mm-&gt;sm_priv; list_entry_t *entry=&amp;(page-&gt;pra_page_link); assert(entry != NULL &amp;&amp; head != NULL); //record the page access situlation /*LAB3 EXERCISE 2: YOUR CODE*/ //(1)link the most recent arrival page at the back of the pra_list_head qeueue. list_add(head, entry); return 0;&#125;/* * (4)_fifo_swap_out_victim: According FIFO PRA, we should unlink the earliest arrival page in front of pra_list_head qeueue, * then set the addr of addr of this page to ptr_page. */static int_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)&#123; list_entry_t *head=(list_entry_t*) mm-&gt;sm_priv; assert(head != NULL); assert(in_tick==0); /* Select the victim */ /*LAB3 EXERCISE 2: YOUR CODE*/ //(1) unlink the earliest arrival page in front of pra_list_head qeueue //(2) set the addr of addr of this page to ptr_page /* Select the tail */ list_entry_t *le = head-&gt;prev; assert(head!=le); struct Page *p = le2page(le, pra_page_link); list_del(le); assert(p !=NULL); *ptr_page = p; return 0;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物理内存管理]]></title>
    <url>%2F2020%2F10%2F25%2F%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[物理内存管理机制虚拟内存虚拟内存存在的意义：抽象，隔离，移植。MCU这类单进程的，一般用物理地址。 现代操作系统肯定要支持多任务，同时运行多个进程。如果直接为进程分配物理内存，就要面临诸多问题：每个进程分配多少物理内存？分配少不够用，分配多则没几个进程物理内存就耗尽了。如果动态分配物理内存，则进程拿到的内存在空间上不连续，系统还要解决碎片的问题。还有安全问题，怎么保证一个进程不越界访问其它进程甚至是操作系统自己的内存，一个程序的错误可能导致整个系统的错误。 虚拟内存系统，是对内存系统和文件系统（可选）的抽象。 将内存资源进行了抽象：可以按需为进程分配 page，甚至可以把长时间不用的 page 缓存在磁盘上节省物理内存；由于每个进程有自己的空间，做到了很好的隔离。而每个进程都以为自己有连续的内存空间可以使用。 物理内存不够的情况下，利用磁盘系统，虽然性能会降低，但是不至于程序无法运行；而增加新的物理内存，就能使程序性能提升。 保护80X86支持两类保护： 任务之间保护 80X86 使用的方法是通过把每个任务放置在不同的虚拟地址空间中，并给予每个任务不同的逻辑地址到物理地址的变换映射。每个任务中的地址变换功能被定义成一个任务中的逻辑地址映射到物理内存的一部分区域，而另一个任务中的逻辑地址映射到物理内存中的不同区域中。这样，因为一个任务不可能生成能够映射到其他任务逻辑地址对应使用的物理内存部分，所以所有任务都被隔绝开了。 特权级保护 特权级 0 是最高的特权级别,用于可靠性最高的程序. 通常,操作系统是为所有的程序服务的,它的可靠性最高,并且操作系统要负责对软硬件的控制,所以操作系统的主体必须拥有特权级 0. 特权级 1, 2 是次于最高的特权级别(特权级 2 的特权级低于特权级 1),用于可靠性不如操作系统(或说是内核 Kernel)的系统服务程序.比较典型的是设备驱动程序. 特权级 3是最低的特权级别,用于可靠性最低的程序.应用程序的可靠性被视为最低的,通常不需要直接访问硬件和一些敏感的系统资源,调用设备驱动程序或操作系统实例能完成绝大多数工作. 分段分页分段机制把逻辑地址转换成线性地址，而分页则把线性地址转换成物理地址。 双重映射其实是毫无必要的，也使映射的过程变得不容易理解。 分页 分段 目的 页是信息的物理单位，分页是为实现离散分配方式，以减少内存的外零头，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要 是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 长度 页的大小固定且由系统决定，由系统把逻辑地址化分为页号和页内地址两部分，由机器硬件实现，因而在系统中只能有一种大小的页面 段的长度不固定，决定于用户编写的程序，通常由编译程序在对流程序进行编译时，根据信息的性质来划分 地址空间 作业地址空间是一维的，即单一的线性地址空间，程序员只需要利用一个记忆符，即可表示一个地址。 作业地址空间是二维的，程序员在标识一个地址时，即需给出段名，又需给出段内地址 碎片 有内部碎片，无外部碎片 有外部碎片，无内部碎片 共享和动态链表 不容易实现 容易实现 图 4 段页式管理总体框架图 ​ 分段 分页​ ↓​ ↓逻辑地址 - 线性地址（虚拟地址） - 物理地址 图 5 分页机制管理 多级页表避免把全部页表一直保存在内存中是多级页表的关键所在。特别是那些不需要的页表就不应该保留。通过一个顶级页表为真正有用的页表提供索引，这是我所理解的二级页表的本质。 32位计算机，4GB内存，每页大小4KB($2^{12}$)，需要$2^{20}$个页表项。每页4KB($2^{12}$)需要用到$2^{8}$个页来存放这些页表项。一般计算机有1M的cache存放这些页表项。 对应用程序来说段选择符是作为指针变量的一部分而可见，但选择符的值通常由链接编辑器或链接加载器进行设置或修改，而非应用程序 物理内存管理步骤探测系统物理内存布局一般来说，获取内存大小的方法由 BIOS 中断调用和直接探测两种。BIOS 中断调用方法是一般只能在实模式下完成，而直接探测方法必须在保护模式下完成。通过 BIOS 中断获取内存布局有三种方式，都是基于INT 15h中断，分别为88h e801h e820h。但是并非在所有情况下这三种方式都能工作。在 Linux kernel 里，采用的方法是依次尝试这三种方法。而在本实验中，我们通过e820h中断获取内存信息。因为e820h中断必须在实模式下使用，所以我们在 bootloader 进入保护模式之前调用这个 BIOS 中断，并且把 e820 映射结构保存在物理地址0x8000处。 实现物理内存探测 物理内存探测是在bootasm.S中实现的，相关代码很短，如下所示： 1234567891011121314151617181920212223242526272829probe_memory://对0x8000处的32位单元清零,即给位于0x8000处的//struct e820map的成员变量nr_map清零 movl $0, 0x8000 xorl %ebx, %ebx//表示设置调用INT 15h BIOS中断后，BIOS返回的映射地址描述符的起始地址 movw $0x8004, %distart_probe: movl $0xE820, %eax // INT 15的中断调用参数//设置地址范围描述符的大小为20字节，其大小等于struct e820map的成员变量map的大小 movl $20, %ecx//设置edx为534D4150h (即4个ASCII字符“SMAP”)，这是一个约定 movl $SMAP, %edx//调用int 0x15中断，要求BIOS返回一个用地址范围描述符表示的内存段信息 int $0x15//如果eflags的CF位为0，则表示还有内存段需要探测 jnc cont//探测有问题，结束探测 movw $12345, 0x8000 jmp finish_probecont://设置下一个BIOS返回的映射地址描述符的起始地址 addw $20, %di//递增struct e820map的成员变量nr_map incl 0x8000//如果INT0x15返回的ebx为零，表示探测结束，否则继续探测 cmpl $0, %ebx jnz start_probefinish_probe: 上述代码正常执行完毕后，在0x8000地址处保存了从BIOS中获得的内存分布信息，此信息按照struct e820map的设置来进行填充。这部分信息将在bootloader启动ucore后，由ucore的page_init函数来根据struct e820map的memmap（定义了起始地址为0x8000）来完成对整个机器中的物理内存的总体管理。 BIOS通过系统内存映射地址描述符（Address Range Descriptor）格式来表示系统物理内存布局，其具体表示如下： 1234Offset Size Description00h 8字节 base address #系统内存块基地址08h 8字节 length in bytes #系统内存大小10h 4字节 type of address range #内存类型 看下面的(Values for System Memory Map address type) 123456Values for System Memory Map address type:01h memory, available to OS02h reserved, not available (e.g. system ROM, memory-mapped device)03h ACPI Reclaim Memory (usable by OS after reading ACPI tables)04h ACPI NVS Memory (OS is required to save this memory between NVS sessions)other not defined yet -- treat as Reserved INT15h BIOS中断的详细调用参数: 12345eax：e820h：INT 15的中断调用参数；edx：534D4150h (即4个ASCII字符“SMAP”) ，这只是一个签名而已；ebx：如果是第一次调用或内存区域扫描完毕，则为0。 如果不是，则存放上次调用之后的计数值；ecx：保存地址范围描述符的内存大小,应该大于等于20字节；es:di：指向保存地址范围描述符结构的缓冲区，BIOS把信息写入这个结构的起始地址。 此中断的返回值为: 1234567891011eflags的CF位：若INT 15中断执行成功，则不置位，否则置位；eax：534D4150h (&apos;SMAP&apos;) ；es:di：指向保存地址范围描述符的缓冲区,此时缓冲区内的数据已由BIOS填写完毕ebx：下一个地址范围描述符的计数地址ecx ：返回BIOS往ES:DI处写的地址范围描述符的字节大小ah：失败时保存出错代码 这样，我们通过调用INT 15h BIOS中断，递增di的值（20的倍数），让BIOS帮我们查找出一个一个的内存布局entry，并放入到一个保存地址范围描述符结构的缓冲区中，供后续的ucore进一步进行物理内存管理。这个缓冲区结构定义在memlayout.h中： 12345678struct e820map &#123; int nr_map; struct &#123; long long addr; long long size; long type; &#125; map[E820MAX];&#125;; 链接地址/虚地址/物理地址/加载地址以及edata/end/text的含义 链接脚本简介 ucore kernel各个部分由组成kernel的各个.o或.a文件构成，且各个部分在内存中地址位置由ld工具根据kernel.ld链接脚本（linker script）来设定。ld工具使用命令-T指定链接脚本。链接脚本主要用于规定如何把输入文件（各个.o或.a文件）内的section放入输出文件（lab2/bin/kernel，即ELF格式的ucore内核）内， 并控制输出文件内各部分在程序地址空间内的布局。下面简单分析一下/lab2/tools/kernel.ld，来了解一下ucore内核的地址布局情况。kernel.ld的内容如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* Simple linker script for the ucore kernel. See the GNU ld &apos;info&apos; manual (&quot;info ld&quot;) to learn the syntax. */OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)OUTPUT_ARCH(i386)ENTRY(kern_entry)SECTIONS &#123; /* Load the kernel at this address: &quot;.&quot; means the current address */ . = 0xC0100000; .text : &#123; *(.text .stub .text.* .gnu.linkonce.t.*) &#125; PROVIDE(etext = .); /* Define the &apos;etext&apos; symbol to this value */ .rodata : &#123; *(.rodata .rodata.* .gnu.linkonce.r.*) &#125; /* Include debugging information in kernel memory */ .stab : &#123; PROVIDE(__STAB_BEGIN__ = .); *(.stab); PROVIDE(__STAB_END__ = .); BYTE(0) /* Force the linker to allocate space for this section */ &#125; .stabstr : &#123; PROVIDE(__STABSTR_BEGIN__ = .); *(.stabstr); PROVIDE(__STABSTR_END__ = .); BYTE(0) /* Force the linker to allocate space for this section */ &#125; /* Adjust the address for the data segment to the next page */ . = ALIGN(0x1000); /* The data segment */ .data : &#123; *(.data) &#125; PROVIDE(edata = .); .bss : &#123; *(.bss) &#125; PROVIDE(end = .); /DISCARD/ : &#123; *(.eh_frame .note.GNU-stack) &#125;&#125; 其实从链接脚本的内容，可以大致猜出它指定告诉链接器的各种信息： 内核加载地址：0xC0100000 入口（起始代码）地址： ENTRY(kern_entry) cpu机器类型：i386 其最主要的信息是告诉链接器各输入文件的各section应该怎么组合：应该从哪个地址开始放，各个section以什么顺序放，分别怎么对齐等等，最终组成输出文件的各section。除此之外，linker script还可以定义各种符号（如.text、.data、.bss等），形成最终生成的一堆符号的列表（符号表），每个符号包含了符号名字，符号所引用的内存地址，以及其他一些属性信息。符号实际上就是一个地址的符号表示，其本身不占用的程序运行的内存空间。 链接地址/加载地址/虚地址/物理地址ucore 设定了ucore运行中的虚地址空间，具体设置可看 lab2/kern/mm/memlayout.h 中描述的”Virtual memory map “图，可以了解虚地址和物理地址的对应关系。lab2/tools/kernel.ld描述的是执行代码的链接地址（link_addr），比如内核起始地址是0xC0100000，这是一个虚地址。所以我们可以认为链接地址等于虚地址。在ucore建立内核页表时，设定了物理地址和虚地址的虚实映射关系是： phy addr + 0xC0000000 = virtual addr 即虚地址和物理地址之间有一个偏移。但boot loader把ucore kernel加载到内存时，采用的是加载地址（load addr），这是由于ucore还没有运行，即还没有启动页表映射，导致这时采用的寻址方式是段寻址方式，用的是boot loader在初始化阶段设置的段映射关系，其映射关系（可参看bootasm.S的末尾处有关段描述符表的内容）是： linear addr = phy addr = virtual addr 查看 bootloader的实现代码 bootmain::bootmain.c readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); 这里的ph-&gt;p_va=0xC0XXXXXX，就是ld工具根据kernel.ld设置的链接地址，且链接地址等于虚地址。考虑到ph-&gt;p_va &amp; 0xFFFFFF == 0x0XXXXXX，所以bootloader加载ucore kernel的加载地址是0x0XXXXXX, 这实际上是ucore内核所在的物理地址。简言之： OS的链接地址（link addr） 在tools/kernel.ld中设置好了，是一个虚地址（virtual addr）；而ucore kernel的加载地址（load addr）在boot loader中的bootmain函数中指定，是一个物理地址。 小结一下，ucore内核的链接地址==ucore内核的虚拟地址；boot loader加载ucore内核用到的加载地址==ucore内核的物理地址。 edata/end/text的含义 在基于ELF执行文件格式的代码中，存在一些对代码和数据的表述，基本概念如下： BSS段（bss segment）：指用来存放程序中未初始化的全局变量的内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。 数据段（data segment）：指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 代码段（code segment/text segment）：指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 在lab2/kern/init/init.c的kern_init函数中，声明了外部全局变量： 1extern char edata[], end[]; 但搜寻所有源码文件*.[ch]，没有发现有这两个变量的定义。那这两个变量从哪里来的呢？其实在lab2/tools/kernel.ld中，可以看到如下内容： 1234567891011121314151617….text : &#123; *(.text .stub .text.* .gnu.linkonce.t.*)&#125;… .data : &#123; *(.data)&#125;…PROVIDE(edata = .);… .bss : &#123; *(.bss)&#125;…PROVIDE(end = .);… 这里的“.”表示当前地址，“.text”表示代码段起始地址，“.data”也是一个地址，可以看出，它即代表了代码段的结束地址，也是数据段的起始地址。类推下去，“edata”表示数据段的结束地址，“.bss”表示数据段的结束地址和BSS段的起始地址，而“end”表示BSS段的结束地址。 这样回头看kerne_init中的外部全局变量，可知edata[]和 end[]这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的起始地址或结束地址等，它们不在任何一个.S、.c或.h文件中定义。 自映射机制这是扩展知识。 上一小节讲述了通过boot_map_segment函数建立了基于一一映射关系的页目录表项和页表项，这里的映射关系为： virtual addr (KERNBASE~KERNBASE+KMEMSIZE) = physical_addr (0~KMEMSIZE) 这样只要给出一个虚地址和一个物理地址，就可以设置相应PDE和PTE，就可完成正确的映射关系。 如果我们这时需要按虚拟地址的地址顺序显示整个页目录表和页表的内容，则要查找页目录表的页目录表项内容，根据页目录表项内容找到页表的物理地址，再转换成对应的虚地址，然后访问页表的虚地址，搜索整个页表的每个页目录项。这样过程比较繁琐。 我们需要有一个简洁的方法来实现这个查找。ucore做了一个很巧妙的地址自映射设计，把页目录表和页表放在一个连续的4MB虚拟地址空间中，并设置页目录表自身的虚地址&lt;–&gt;物理地址映射关系。这样在已知页目录表起始虚地址的情况下，通过连续扫描这特定的4MB虚拟地址空间，就很容易访问每个页目录表项和页表项内容。 具体而言，ucore是这样设计的，首先设置了一个常量（memlayout.h）： VPT=0xFAC00000， 这个地址的二进制表示为： 1111 1010 1100 0000 0000 0000 0000 0000 高10位为1111 1010 11，即10进制的1003，中间10位为0，低12位也为0。在pmm.c中有两个全局初始化变量 pte_t const vpt = (pte_t )VPT; pde_t const vpd = (pde_t )PGADDR(PDX(VPT), PDX(VPT), 0); 并在pmm_init函数执行了如下语句： boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W; 这些变量和语句有何特殊含义呢？其实vpd变量的值就是页目录表的起始虚地址0xFAFEB000，且它的高10位和中10位是相等的，都是10进制的1003。当执行了上述语句，就确保了vpd变量的值就是页目录表的起始虚地址，且vpt是页目录表中第一个目录表项指向的页表的起始虚地址。此时描述内核虚拟空间的页目录表的虚地址为0xFAFEB000，大小为4KB。页表的理论连续虚拟地址空间0xFAC00000~0xFB000000，大小为4MB。因为这个连续地址空间的大小为4MB，可有1M个PTE，即可映射4GB的地址空间。 但ucore实际上不会用完这么多项，在memlayout.h中定义了常量 #define KMEMSIZE 0x38000000 表示ucore只支持896MB的物理内存空间，这个896MB只是一个设定，可以根据情况改变。则最大的内核虚地址为常量 #define KERNTOP (KERNBASE + KMEMSIZE)=0xF8000000 所以最大内核虚地址KERNTOP的页目录项虚地址为 vpd+0xF8000000/0x400000=0xFAFEB000+0x3E0=0xFAFEB3E0 最大内核虚地址KERNTOP的页表项虚地址为： vpt+0xF8000000/0x1000=0xFAC00000+0xF8000=0xFACF8000 在pmm.c中的函数print_pgdir就是基于ucore的页表自映射方式完成了对整个页目录表和页表的内容扫描和打印。注意，这里不会出现某个页表的虚地址与页目录表虚地址相同的情况。 print_pgdir函数使得 ucore 具备和 qemu 的info pg相同的功能，即print pgdir能 够从内存中，将当前页表内有效数据（PTE_P）印出来。拷贝出的格式如下所示: 12345PDE(0e0) c0000000-f8000000 38000000 urw|-- PTE(38000) c0000000-f8000000 38000000 -rwPDE(001) fac00000-fb000000 00400000 -rw|-- PTE(000e0) faf00000-fafe0000 000e0000 urw|-- PTE(00001) fafeb000-fafec000 00001000 -rw 上面中的数字包括括号里的，都是十六进制。 主要的功能是从页表中将具备相同权限的 PDE 和 PTE 项目组织起来。比如上表中： 1PDE(0e0) c0000000-f8000000 38000000 urw • PDE(0e0)：0e0表示 PDE 表中相邻的 224 项具有相同的权限； • c0000000-f8000000：表示 PDE 表中,这相邻的两项所映射的线性地址的范围； • 38000000：同样表示范围，即f8000000减去c0000000的结果； • urw：PDE 表中所给出的权限位，u表示用户可读，即PTE_U，r表示PTE_P，w表示用 户可写，即PTE_W。 1PDE(001) fac00000-fb000000 00400000 -rw 表示仅 1 条连续的 PDE 表项具备相同的属性。相应的，在这条表项中遍历找到 2 组 PTE 表项，输出如下: 12|-- PTE(000e0) faf00000-fafe0000 000e0000 urw|-- PTE(00001) fafeb000-fafec000 00001000 -rw 注意： PTE 中输出的权限是 PTE 表中的数据给出的，并没有和 PDE 表中权限做与运算。 2. 整个print_pgdir函数强调两点：第一是相同权限，第二是连续。 3. print_pgdir中用到了vpt和vpd两个变量。可以参 考VPT和PGADDR两个宏。 自映射机制还可方便用户态程序访问页表。因为页表是内核维护的，用户程序很难知道自己页表的映射结构。VPT 实际上在内核地址空间的，我们可以用同样的方式实现一个用户地址空间的映射（比如 pgdir[UVPT] = PADDR(pgdir) | PTE_P | PTE_U，注意，这里不能给写权限，并且 pgdir 是每个进程的 page table，不是 boot_pgdir），这样，用户程序就可以用和内核一样的 print_pgdir 函数遍历自己的页表结构了。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[x86启动顺序]]></title>
    <url>%2F2020%2F10%2F09%2Fx86%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基本概念BIOS启动过程以Intel 80386为例，计算机加电后，CPU从物理地址0xFFFFFFF0（由初始化的CS：EIP确定，此时CS和IP的值分别是0xF000和0xFFF0)）开始执行。在0xFFFFFFF0这里只是存放了一条跳转指令，通过跳转指令跳到BIOS例行程序起始点。BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的bootloader。 Intel的CPU具有很好的向后兼容性。在16位的8086 CPU时代，内存限制在1MB范围内，且BIOS的代码固化在EPROM中。在基于Intel的8086 CPU的PC机中的EPROM被编址在1ＭB内存地址空间的最高64KB中。PC加电后，CS寄存器初始化为0xF000，IP寄存器初始化为0xFFF0，所以CPU要执行的第一条指令的地址为CS:IP=0xF000:0XFFF0（Segment:Offset 表示）=0xFFFF0（Linear表示）。这个地址位于被固化EPROM中，指令是一个长跳转指令JMP F000:E05B。这样就开启了BIOS的执行过程。 到了32位的80386 CPU时代，内存空间扩大到了4G，多了段机制和页机制，但Intel依然很好地保证了80386向后兼容8086。地址空间的变化导致无法直接采用8086的启动约定。如果把BIOS启动固件编址在0xF000起始的64KB内存地址空间内，就会把整个物理内存地址空间隔离成不连续的两段，一段是0xF000以前的地址，一段是1MB以后的地址，这很不协调。为此，intel采用了一个折中的方案：默认将执行BIOS ROM编址在32位内存地址空间的最高端，即位于4GB地址的最后一个64KB内。在PC系统开机复位时，CPU进入实模式，并将CS寄存器设置成0xF000，将它的shadow register的Base值初始化设置为0xFFFF0000，EIP寄存器初始化设置为0x0000FFF0。所以机器执行的第一条指令的物理地址是0xFFFFFFF0。80386的BIOS代码也要和以前8086的BIOS代码兼容，故地址0xFFFFFFF0处的指令还是一条长跳转指令jmp F000:E05B。注意，这个长跳转指令会触发更新CS寄存器和它的shadow register，即执行jmp F000 : E05B后，CS将被更新成0xF000。表面上看CS其实没有变化，但CS的shadow register被更新为另外一个值了，它的Base域被更新成0x000F0000，此时形成的物理地址为Base+EIP=0x000FE05B，这就是CPU执行的第二条指令的地址。此时这条指令的地址已经是1M以内了，且此地址不再位于BIOS ROM中，而是位于RAM空间中。由于Intel设计了一种映射机制，将内存高端的BIOS ROM映射到1MB以内的RAM空间里，并且可以使这一段被映射的RAM空间具有与ROM类似的只读属性。所以PC机启动时将开启这种映射机制，让4GB地址空间的最高一个64KB的内容等同于1MB地址空间的最高一个64K的内容，从而使得执行了长跳转指令后，其实是回到了早期的8086 CPU初始化控制流，保证了向下兼容。 Bootloader启动过程BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。bootloader完成的工作包括： 切换到保护模式，启用分段机制读磁盘中ELF执行文件格式的ucore操作系统到内存显示字符串信息把控制权交给ucore操作系统 操作系统启动过程当bootloader通过读取硬盘扇区把ucore在系统加载到内存后，就转跳到ucore操作系统在内存中的入口位置（kern/init.c中的kern_init函数的起始地址），这样ucore就接管了整个控制权。当前的ucore功能很简单，只完成基本的内存管理和外设中断管理。ucore主要完成的工作包括： 初始化终端；显示字符串；显示堆栈中的多层函数调用关系；切换到保护模式，启用分段机制；初始化中断控制器，设置中断描述符表，初始化时钟中断，使能整个系统的中断机制；执行while（1）死循环。 代码实现第一个地址机器启动后有个固定启动地址CS:EIP CS=F000H,EIP=FFF0H1234567891011121314151617(gdb) info reax 0x0 0ecx 0x0 0edx 0x663 1635ebx 0x0 0esp 0x0 0x0ebp 0x0 0x0esi 0x0 0edi 0x0 0eip 0xfff0 0xfff0eflags 0x2 [ ]cs 0xf000 61440ss 0x0 0ds 0x0 0es 0x0 0fs 0x0 0gs 0x0 0 早期16位实模式下，CS左移4位+EIP 32位80386，实际地址： Base+EIP = FFFF0000H+0000FFF0H=FFFFFFF0H 12345678(gdb) x/x 0xffff00xffff0: 0x00e05bea(gdb) si=&gt; 0xe05b: add %al,(%bx,%si)0x0000e05b in ?? ()(gdb) x /2i $pc=&gt; 0xe05b: add %al,(%bx,%si) 0xe05d: add %al,(%bx,%si) BIOS到BootloaderBIOS加载存储设备（比如软盘、硬盘、光盘、USB盘）上的第一个扇区（主引导扇区，Master Boot Record or MBR）的512字节到内存0x7c00，然后跳转到@0x7c00的第一条指令开始执行 123456789(gdb) b *0x7c00Breakpoint 1 at 0x7c00(gdb) cContinuing.Breakpoint 1, 0x00007c00 in ?? ()(gdb) x /2i $pc=&gt; 0x7c00: cli &lt;-- bootasm.S 0x7c01: cld 保护模式和分段机制Bootloader中需要完成从实模式到保护模式的切换 实模式只有1M的寻址空间，每个地址对应真实的物理地址 保护模式可以寻址4G字节，对应逻辑地址 通过修改A20地址线可以完成从实模式到保护模式的转换。 保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14个段。 CPL：当前特权级（Current Privilege Level) 保存在CS段寄存器（选择子）的最低两位，CPL就是当前活动代码段的特权级，并且它定义了当前所执行程序的特权级别） DPL：描述符特权（Descriptor Privilege Level） 存储在段描述符中的权限位，用于描述对应段所属的特权等级，也就是段本身能被访问的真正特权级。 RPL：请求特权级RPL(Request Privilege Level) RPL保存在选择子的最低两位。RPL说明的是进程对段访问的请求权限，意思是当前进程想要的请求权限。RPL的值可自由设置，并不一定要求RPL&gt;=CPL，但是当RPL&lt;CPL时，实际起作用的就是CPL了，因为访问时的特权级保护检查要判断：max(RPL,CPL)&lt;=DPL是否成立。所以RPL可以看成是每次访问时的附加限制，RPL=0时附加限制最小，RPL=3时附加限制最大。 分析bootloader 进入保护模式的过程 从%cs=0 $pc=0x7c00，进入后 首先清理环境：包括将flag置0和将段寄存器置01234567.code16 cli cld xorw %ax, %ax movw %ax, %ds movw %ax, %es movw %ax, %ss 开启A20：通过将键盘控制器上的A20线置于高电位，全部32条地址线可用，可以访问4G的内存空间。123456789101112131415seta20.1: # 等待8042键盘控制器不忙 inb $0x64, %al # testb $0x2, %al # jnz seta20.1 # movb $0xd1, %al # 发送写8042输出端口的指令 outb %al, $0x64 #seta20.1: # 等待8042键盘控制器不忙 inb $0x64, %al # testb $0x2, %al # jnz seta20.1 # movb $0xdf, %al # 打开A20 outb %al, $0x60 # 初始化GDT表：一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可1lgdt gdtdesc 进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式123movl %cr0, %eaxorl $CR0_PE_ON, %eaxmovl %eax, %cr0 通过长跳转更新cs的基地址123 ljmp $PROT_MODE_CSEG, $protcseg.code32protcseg: 设置段寄存器，并建立堆栈12345678movw $PROT_MODE_DSEG, %axmovw %ax, %dsmovw %ax, %esmovw %ax, %fsmovw %ax, %gsmovw %ax, %ssmovl $0x0, %ebpmovl $start, %esp 转到保护模式完成，进入boot主方法1call bootmain 分析bootloader加载ELF格式的OS的过程 首先看readsect函数，readsect从设备的第secno扇区读取数据到dst位置123456789101112131415161718192021static voidreadsect(void *dst, uint32_t secno) &#123; waitdisk(); outb(0x1F2, 1); // 设置读取扇区的数目为1 outb(0x1F3, secno &amp; 0xFF); outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF); outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0); // 上面四条指令联合制定了扇区号 // 在这4个字节线联合构成的32位参数中 // 29-31位强制设为1 // 28位(=0)表示访问&quot;Disk 0&quot; // 0-27位是28位的偏移量 outb(0x1F7, 0x20); // 0x20命令，读取扇区 waitdisk(); insl(0x1F0, dst, SECTSIZE / 4); // 读取到dst位置， // 幻数4因为这里以DW为单位&#125; readseg简单包装了readsect，可以从设备读取任意长度的内容。1234567891011121314static voidreadseg(uintptr_t va, uint32_t count, uint32_t offset) &#123; uintptr_t end_va = va + count; va -= offset % SECTSIZE; uint32_t secno = (offset / SECTSIZE) + 1; // 加1因为0扇区被引导占用 // ELF文件从1扇区开始 for (; va &lt; end_va; va += SECTSIZE, secno ++) &#123; readsect((void *)va, secno); &#125;&#125; 在bootmain函数中，1234567891011121314151617181920212223242526272829303132voidbootmain(void) &#123; // 首先读取ELF的头部 readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0); // 通过储存在头部的幻数判断是否是合法的ELF文件 if (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123; goto bad; &#125; struct proghdr *ph, *eph; // ELF头部有描述ELF文件应加载到内存什么位置的描述表， // 先将描述表的头地址存在ph ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; // 按照描述表将ELF文件中数据载入内存 for (; ph &lt; eph; ph ++) &#123; readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); &#125; // ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000 // ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000 // 根据ELF头部储存的入口信息，找到内核的入口 ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); while (1);&#125; 实现函数调用堆栈跟踪函数ss:ebp指向的堆栈位置储存着caller的ebp，以此为线索可以得到所有使用堆栈的函数ebp。ss:ebp+4指向caller调用时的eip，ss:ebp+8等是（可能的）参数。 输出中，堆栈最深一层为123ebp:0x00007bf8 eip:0x00007d68 \ args:0x00000000 0x00000000 0x00000000 0x00007c4f &lt;unknow&gt;: -- 0x00007d67 -- 其对应的是第一个使用堆栈的函数，bootmain.c中的bootmain。bootloader设置的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。call指令压栈，所以bootmain中ebp为0x7bf8。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核完全注释_第三章 内核编程语言和环境]]></title>
    <url>%2F2020%2F08%2F21%2FLinux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[一、目标文件1.1 目标文件格式 a.out格式7个区的基本定义和用途：执行头（exec header）：该部分中含有一些参数（exec结构），是有关目标文件的整体结构信息。例如代码和数据区的长度、未初始化数据区的长度、对应源程序文件名以及目标文件创建时间等。内核使用这些参数把执行文件加载到内存中并执行，而链接程序（ld）使用这些参数将一些模块文件组合成一个可执行文件。这是目标文件唯一必要的组成部分。 执行头结构体 12345678910struct exec &#123; unsigned long a_magic // 执行文件魔数。使用 N_MAGIC 等宏访问。 unsigned a_text // 代码长度，字节数。 unsigned a_data // 数据长度，字节数。 unsigned a_bss // 文件中的未初始化数据区长度，字节数。 unsigned a_syms // 文件中的符号表长度，字节数。 unsigned a_entry // 执行开始地址。 unsigned a_trsize // 代码重定位信息长度，字节数。 unsigned a_drsize // 数据重定位信息长度，字节数。&#125; 代码区（text segment）：由编译器或汇编器生成的二进制指令代码和数据信息，含有程序执行时被加载到内存中的指令和相关数据。可以以只读形式被加载。 数据区（data segment）：由编译器或汇编器生成的二进制指令代码和数据信息，这部分含有已经初始化过的数据，总是被加载到可读写的内存中。 代码重定位（text relocations）：这部分含有供链接程序使用的记录数据。在组合目标模块文件时用于定位代码段中的指针或地址。当链接程序需要该表目标代码的地址时就需要修正和维护这些地方。 数据重定位（data relocations）：类似于代码重定位部分的作用，但是用于数据段中指针的重定位。 重定位结构体 : 123456789struct relocation_info&#123; int r_address; // 段内需要重定位的地址。 unsigned int r_symbolnum:24; // 含义与 r_extern 有关。指定符号表中一个符号或者一个段。 unsigned int r_pcrel:1; // 1 比特。 PC 相关标志。 unsigned int r_length:2; // 2 比特。指定要被重定位字段长度（2 的次方）。 unsigned int r_extern:1; // 外部标志位。 1 - 以符号的值重定位。 0 - 以段的地址重定位。 unsigned int r_pad:4; // 没有使用的 4 个比特位，但最好将它们复位掉。&#125;; 符号表（symbol table）：这部分同样含有供链接程序使用的记录数据。这些记录数据保保存着模块文件中定义的全局符号以及需要从其他模块文件中输入的符号，或者是由链接器定义的符号，用于在模块文件之间对命名的变量和函数（符号）进行交叉引用。 字符串表（string table）：该部分含有与符号名相对应的字符串。用于调试程序调试目标代码，与连接过程无关。这些信息科包含源程序代码和行号、局部符号以及数据结构描述信息等。1234567891011struct nlist &#123; union &#123; char *n_name; // 字符串指针， struct nlist *n_next; // 或者是指向另一个符号项结构的指针， long n_strx; // 或者是符号名称在字符串表中的字节偏移值。 &#125; n_un; unsigned char n_type; // 该字节分成 3 个字段，参见 a.out.h 文件 146-154 行。 char n_other; // 通常不用。 short n_desc; // unsigned long n_value; // 符号的值。&#125;; 对于一个指定的目标文件并非一定会包含所有以上信息。 1.2 可执行文件映射到进程逻辑地址空间 1.3 目标文件的链接操作 1.4 System.map文件链接（ld）时使用“-M”选项，或者使用nm，可以生成链接映像（link map）信息，即连接程序产生的目标程序内存地址映像信息。其中列出了程序段装入内存中的位置信息。有如下信息： 目标文件及符号信息映射到内存中的位置 公共符号如何放置 链接中包含的所有文件成员及其应用的符号 一般存放在： /boot/System.map/System.map/usr/src/linux/System.map 表 3-5 目标文件符号列表文件中的符号类型 符号类型 名称 说明 A Absolute 符号的值是绝对值，并且在进一步链接过程中不会被改变。 B BSS 符号在未初始化数据区或区（section） 中，即在 BSS 段中 C Common 符号是公共的。公共符号是未初始化的数据。在链接时，多个公共符号可能具 有同一名称。如果该符号定义在其他地方，则公共符号被看作是未定义的引用。 D Data 符号在已初始化数据区中。 G Global 符号是在小对象已初始化数据区中的符号。某些目标文件的格式允许对小数据 对象（例如一个全局整型变量）可进行更有效的访问 I Inderect 符号是对另一个符号的间接引用 N Debugging 符号是一个调试符号 R Read only 符号在一个只读数据区中 S Small 符号是小对象未初始化数据区中的符号 T Text 符号是代码区中的符号 U Undefined 符号是外部的，并且其值为 0（未定义） - Stabs 符号是 a.out 目标文件中的一个 stab 符号，用于保存调试信息 ? Unknwon 符号的类型未知，或者是与具体文件格式有关 二、MakeFile2.1 Makefile 文件中的规则12target（目标）...： prerequisites（先决条件）... command（命令） prerequisite（先决条件或称依赖对象）是用以创建 target 所必要或者依赖的一系列文件或其他目标。target 通常依赖于多个这样的必要文件或目标文件。 command（命令）是指 make 所执行的操作，通常就是一些 shell 命令，是生成 target 需要执行的操作。当先决条件中一个或多个文件的最后修改时间比 target 文件的要新时，规则的命令就会被执行。另外，一个规则中可以有多个命令，每个命令占用规则中单独一行。请注意，我们需要在写每个命令之前键入一个制表符（按 Tab 键产生）！12345678910edit : main.o files.o utils.o cc -o edit main.o files.o utils.omain.o : main.c defs.h cc -c main.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit main.o files.o utils.o 2.2 让MakeFile自动推断命令12345678objects = main.o files.o utils.o #变量edit : $(objects) #自动推断命令 cc -o edit $(objects)main.o : defs.hfiles.o : defs.h buffer.h command.hutils.o : defs.hclean : rm edit $(objects) 2.3 隐含规则中的自动变量123# ↓ 第一个先决条件foo.o : foo.c defs.h hack.h cc -c $(CFLAGS) $&lt; -o $@ $^: 表示规则的所有先决条件，包括它们所处目录的名称；代表所有通过目录搜索得到的依赖文件的完整路径名（目录 + 一般文件名）列表 ；$&lt;: 表示规则中的第一个先决条件；如：替换成 foo.c$@: 表示目标对象；如：被替换为 foo.o 参考：GNU make中文手册 三、小结学习可执行文件的内存结构，复习MakeFile的语法。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USB笔记3_复合设备]]></title>
    <url>%2F2020%2F08%2F17%2FUSB%E7%AC%94%E8%AE%B03-%E5%A4%8D%E5%90%88%E8%AE%BE%E5%A4%87%2F</url>
    <content type="text"><![CDATA[USB笔记3_复合设备本篇主要浅谈支持多功能的设备。至少有两种方法能够实现： 只是用一个接口，但是使用两个应用集合和两个报告。 使用两个接口，一个接口实现键盘功能，另一个接口实现鼠标功能。 方法一：一个接口、两个集合、两个报告通过修改报告描述符实现。一个描述符中可以具有多个外层应用集合，而系统软件就是通过分析外层应用集合的功能来增加不通的设备和驱动的。因此在这里，只需要实现用途分别为键盘和鼠标的两个应用集合即可。同时，每个应用集合里还需要增加一个报告ID，以区分返回数据。报告ID是报告输入或者输出时的第一个字节，当没有定义报告ID时，报告前面就没有报告ID。对于返回的没有报告ID的报告，人体学输入设备驱动会自动增加一个报告ID 0；而应用程序在发送数据出去时，也要带一个值为0的报告ID。人体学输入设备驱动会自动去掉这个值为0的报告ID，只发送数据出去。注意：报告ID一旦定义，输入报告和输出报告的第一字节都是报告ID。例如：本例中的键盘，从端点1读输出报告数据时要读2字节的数据，第一字节为报告ID，第二字节才是真正的报告数据。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268//USB报告描述符的定义//该报告描述符定义了两个顶层应用集合——键盘和鼠标。code uint8 ReportDescriptor[]=&#123; //每行开始的第一字节为该条目的前缀，前缀的格式为： //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。 /************************USB键盘部分报告描述符**********************//*******************************************************************/ //这是一个全局（bType为1）条目，将用途页选择为普通桌面Generic Desktop Page(0x01) //后面跟一字节数据（bSize为1），后面的字节数就不注释了， //自己根据bSize来判断。 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //这是一个局部（bType为2）条目，说明接下来的集合用途用于键盘 0x09, 0x06, // USAGE (Keyboard) //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示 //该集合是一个应用集合。它的性质在前面由用途页和用途定义为 //普通桌面用的键盘。 0xa1, 0x01, // COLLECTION (Application) //报告ID，这里定义键盘报告的ID为1（报告ID 0是保留的） 0x85, 0x01, //Report ID (1) //这是一个全局条目，选择用途页为键盘（Keyboard/Keypad(0x07)） 0x05, 0x07, // USAGE_PAGE (Keyboard/Keypad) //这是一个局部条目，说明用途的最小值为0xe0。实际上是键盘左Ctrl键。 //具体的用途值可在HID用途表中查看。 0x19, 0xe0, // USAGE_MINIMUM (Keyboard LeftControl) //这是一个局部条目，说明用途的最大值为0xe7。实际上是键盘右GUI键。 0x29, 0xe7, // USAGE_MAXIMUM (Keyboard Right GUI) //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值） //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。 0x15, 0x00, // LOGICAL_MINIMUM (0) //这是一个全局条目，说明逻辑值最大为1。 0x25, 0x01, // LOGICAL_MAXIMUM (1) //这是一个全局条目，说明数据域的数量为八个。 0x95, 0x08, // REPORT_COUNT (8) //这是一个全局条目，说明每个数据域的长度为1个bit。 0x75, 0x01, // REPORT_SIZE (1) //这是一个主条目，说明有8个长度为1bit的数据域（数量和长度 //由前面的两个全局条目所定义）用来做为输入， //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示 //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。 //这样定义的结果就是，当某个域的值为1时，就表示对应的键按下。 //bit0就对应着用途最小值0xe0，bit7对应着用途最大值0xe7。 0x81, 0x02, // INPUT (Data,Var,Abs) //这是一个全局条目，说明数据域数量为1个 0x95, 0x01, // REPORT_COUNT (1) //这是一个全局条目，说明每个数据域的长度为8bit。 0x75, 0x08, // REPORT_SIZE (8) //这是一个主条目，输入用，由前面两个全局条目可知，长度为8bit， //数量为1个。它的属性为常量（即返回的数据一直是0）。 //该字节是保留字节（保留给OEM使用）。 0x81, 0x03, // INPUT (Cnst,Var,Abs) //这是一个全局条目。定义位域数量为6个。 0x95, 0x06, // REPORT_COUNT (6) //这是一个全局条目。定义每个位域长度为8bit。 //其实这里这个条目不要也是可以的，因为在前面已经有一个定义 //长度为8bit的全局条目了。 0x75, 0x08, // REPORT_SIZE (8) //这是一个全局条目，定义逻辑最小值为0。 //同上，这里这个全局条目也是可以不要的，因为前面已经有一个 //定义逻辑最小值为0的全局条目了。 0x15, 0x00, // LOGICAL_MINIMUM (0) //这是一个全局条目，定义逻辑最大值为255。 0x25, 0xFF, // LOGICAL_MAXIMUM (255) //这是一个全局条目，选择用途页为键盘。 //前面已经选择过用途页为键盘了，所以该条目不要也可以。 0x05, 0x07, // USAGE_PAGE (Keyboard/Keypad) //这是一个局部条目，定义用途最小值为0（0表示没有键按下） 0x19, 0x00, // USAGE_MINIMUM (Reserved (no event indicated)) //这是一个局部条目，定义用途最大值为0x65 0x29, 0x65, // USAGE_MAXIMUM (Keyboard Application) //这是一个主条目。它说明这六个8bit的数据域是输入用的， //属性为：Data,Ary,Abs。Data说明数据是可以变的，Ary说明 //这些数据域是一个数组，即每个8bit都可以表示某个键值， //如果按下的键太多（例如超过这里定义的长度或者键盘本身无法 //扫描出按键情况时），则这些数据返回全1（二进制），表示按键无效。 //Abs表示这些值是绝对值。 0x81, 0x00, // INPUT (Data,Ary,Abs) //以下为输出报告的描述 //逻辑最小值前面已经有定义为0了，这里可以省略。 //这是一个全局条目，说明逻辑值最大为1。 0x25, 0x01, // LOGICAL_MAXIMUM (1) //这是一个全局条目，说明数据域数量为5个。 0x95, 0x05, // REPORT_COUNT (5) //这是一个全局条目，说明数据域的长度为1bit。 0x75, 0x01, // REPORT_SIZE (1) //这是一个全局条目，说明使用的用途页为指示灯（LED） 0x05, 0x08, // USAGE_PAGE (LEDs) //这是一个局部条目，说明用途最小值为数字键盘灯。 0x19, 0x01, // USAGE_MINIMUM (Num Lock) //这是一个局部条目，说明用途最大值为Kana灯。 0x29, 0x05, // USAGE_MAXIMUM (Kana) //这是一个主条目。定义输出数据，即前面定义的5个LED。 0x91, 0x02, // OUTPUT (Data,Var,Abs) //这是一个全局条目。定义位域数量为1个。 0x95, 0x01, // REPORT_COUNT (1) //这是一个全局条目。定义位域长度为3bit。 0x75, 0x03, // REPORT_SIZE (3) //这是一个主条目，定义输出常量，前面用了5bit，所以这里需要 //3个bit来凑成一字节。 0x91, 0x03, // OUTPUT (Cnst,Var,Abs) //下面这个主条目用来关闭前面的集合。bSize为0，所以后面没数据。 0xc0, // END_COLLECTION//以下注释不包括第一字节报告ID。//通过上面的报告描述符的定义，我们知道返回的输入报告具有8字节。//第一字节的8个bit用来表示特殊键是否按下（例如Shift、Alt等键）。//第二字节为保留值，值为常量0。第三到第八字节是一个普通键键值的//数组，当没有键按下时，全部6个字节值都为0。当只有一个普通键按下时，//这六个字节中的第一字节值即为该按键的键值（具体的键值请看HID的//用途表文档），当有多个普通键同时按下时，则同时返回这些键的键值。//如果按下的键太多，则这六个字节都为0xFF（不能返回0x00，这样会让//操作系统认为所有键都已经释放）。至于键值在数组中的先后顺序是//无所谓的，操作系统会负责检查是否有新键按下。我们应该在中断端点1//中按照上面的格式返回实际的键盘数据。另外，报告中还定义了一个字节//的输出报告，是用来控制LED情况的。只使用了低7位，高1位是保留值0。//当某位的值为1时，则表示对应的LED要点亮。操作系统会负责同步各个//键盘之间的LED，例如你有两块键盘，一块的数字键盘灯亮时，另一块//也会跟着亮。键盘本身不需要判断各种LED应该何时亮，它只是等待主机//发送报告给它，然后根据报告值来点亮相应的LED。我们在端点1输出中断//中读出这1字节的输出报告，然后对它取反（因为学习板上的LED是低电平时//亮），直接发送到LED上。这样main函数中按键点亮LED的代码就不需要了。/************************USB鼠标部分报告描述符**********************//*******************************************************************/ //这是一个全局（bType为1）条目，选择用途页为普通桌面Generic Desktop Page(0x01) 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //这是一个局部（bType为2）条目，说明接下来的应用集合用途用于鼠标 0x09, 0x02, // USAGE (Mouse) //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示 //该集合是一个应用集合。它的性质在前面由用途页和用途定义为 //普通桌面用的鼠标。 0xa1, 0x01, // COLLECTION (Application) //报告ID，这里定义鼠标报告的ID为2 0x85, 0x02, //Report ID (2) //这是一个局部条目。说明用途为指针集合 0x09, 0x01, // USAGE (Pointer) //这是一个主条目，开集合，后面跟的数据0x00表示该集合是一个 //物理集合，用途由前面的局部条目定义为指针集合。 0xa1, 0x00, // COLLECTION (Physical) //这是一个全局条目，选择用途页为按键（Button Page(0x09)） 0x05, 0x09, // USAGE_PAGE (Button) //这是一个局部条目，说明用途的最小值为1。实际上是鼠标左键。 0x19, 0x01, // USAGE_MINIMUM (Button 1) //这是一个局部条目，说明用途的最大值为3。实际上是鼠标中键。 0x29, 0x03, // USAGE_MAXIMUM (Button 3) //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值啦） //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。 0x15, 0x00, // LOGICAL_MINIMUM (0) //这是一个全局条目，说明逻辑值最大为1。 0x25, 0x01, // LOGICAL_MAXIMUM (1) //这是一个全局条目，说明数据域的数量为三个。 0x95, 0x03, // REPORT_COUNT (3) //这是一个全局条目，说明每个数据域的长度为1个bit。 0x75, 0x01, // REPORT_SIZE (1) //这是一个主条目，说明有3个长度为1bit的数据域（数量和长度 //由前面的两个全局条目所定义）用来做为输入， //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示 //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。 //这样定义的结果就是，第一个数据域bit0表示按键1（左键）是否按下， //第二个数据域bit1表示按键2（右键）是否按下，第三个数据域bit2表示 //按键3（中键）是否按下。 0x81, 0x02, // INPUT (Data,Var,Abs) //这是一个全局条目，说明数据域数量为1个 0x95, 0x01, // REPORT_COUNT (1) //这是一个全局条目，说明每个数据域的长度为5bit。 0x75, 0x05, // REPORT_SIZE (5) //这是一个主条目，输入用，由前面两个全局条目可知，长度为5bit， //数量为1个。它的属性为常量（即返回的数据一直是0）。 //这个只是为了凑齐一个字节（前面用了3个bit）而填充的一些数据 //而已，所以它是没有实际用途的。 0x81, 0x03, // INPUT (Cnst,Var,Abs) //这是一个全局条目，选择用途页为普通桌面Generic Desktop Page(0x01) 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //这是一个局部条目，说明用途为X轴 0x09, 0x30, // USAGE (X) //这是一个局部条目，说明用途为Y轴 0x09, 0x31, // USAGE (Y) //这是一个局部条目，说明用途为滚轮 0x09, 0x38, // USAGE (Wheel) //下面两个为全局条目，说明返回的逻辑最小和最大值。 //因为鼠标指针移动时，通常是用相对值来表示的， //相对值的意思就是，当指针移动时，只发送移动量。 //往右移动时，X值为正；往下移动时，Y值为正。 //对于滚轮，当滚轮往上滚时，值为正。 0x15, 0x81, // LOGICAL_MINIMUM (-127) 0x25, 0x7f, // LOGICAL_MAXIMUM (127) //这是一个全局条目，说明数据域的长度为8bit。 0x75, 0x08, // REPORT_SIZE (8) //这是一个全局条目，说明数据域的个数为3个。 0x95, 0x03, // REPORT_COUNT (3) //这是一个主条目。它说明这三个8bit的数据域是输入用的， //属性为：Data,Var,Rel。Data说明数据是可以变的，Var说明 //这些数据域是独立的，即第一个8bit表示X轴，第二个8bit表示 //Y轴，第三个8bit表示滚轮。Rel表示这些值是相对值。 0x81, 0x06, // INPUT (Data,Var,Rel) //下面这两个主条目用来关闭前面的集合用。 //我们开了两个集合，所以要关两次。bSize为0，所以后面没数据。 0xc0, // END_COLLECTION 0xc0 // END_COLLECTION//以下注释不包括第一字节报告ID。//通过上面的报告描述符的定义，我们知道返回的输入报告具有4字节。//第一字节的低3位用来表示按键是否按下的，高5位为常数0，无用。//第二字节表示X轴改的变量，第三字节表示Y轴的改变量，第四字节表示//滚轮的改变量。我们在中断端点1中应该要按照上面的格式返回实际的//鼠标数据。&#125;;//由于该报告使用了报告ID，因此报告在返回时，需要在最前面增加//一字节的报告ID。当报告ID为1时，返回的数据是键盘数据；//当报告ID为2时，返回的数据是鼠标数据。 由于多了一个Report ID，所以构造report的时候是9个字节，而不是之前的8个字节。 方法二：两个接口、各一个HID描述符、各一个报告描述符使用两个接口，每个接口实现一个HID设备。这样每个接口需要一个报告描述符。12345678910graph LRA[配置描述符集合] --&gt; B(配置描述符)B --&gt; C[第一个接口描述符]B --&gt; D[第二个接口描述符]C--&gt; G[HID描述符]C--&gt; H[输入端点描述符]C--&gt; I[输出端点描述符]D--&gt; J[HID描述符]D--&gt; K[输入端点描述符]D--&gt; L[输出端点描述符] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219//USB配置描述符集合的定义//配置描述符总长度为9+9+9+7+7+9+9+7字节code uint8 ConfigurationDescriptor[9+9+9+7+7+9+9+7]=&#123; /***************配置描述符***********************/ //bLength字段。配置描述符的长度为9字节。 0x09, //bDescriptorType字段。配置描述符编号为0x02。 0x02, //wTotalLength字段。配置描述符集合的总长度， //包括配置描述符本身、接口描述符、类描述符、端点描述符等。 sizeof(ConfigurationDescriptor)&amp;0xFF, //低字节 (sizeof(ConfigurationDescriptor)&gt;&gt;8)&amp;0xFF, //高字节 //bNumInterfaces字段。该配置包含的接口数，有两个接口。 0x02, //bConfiguration字段。该配置的值为1。 0x01, //iConfigurationz字段，该配置的字符串索引。这里没有，为0。 0x00, //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的， //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。 0x80, //bMaxPower字段，该设备需要的最大电流量。由于我们的板子 //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位 //电流为2mA，所以这里设置为50(0x32)。 0x32, /*******************第一个接口描述符*********************/ //bLength字段。接口描述符的长度为9字节。 0x09, //bDescriptorType字段。接口描述符的编号为0x04。 0x04, //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。 0x00, //bAlternateSetting字段。该接口的备用编号，为0。 0x00, //bNumEndpoints字段。非0端点的数目。由于USB键盘需要二个 //中断端点（一个输入一个输出），因此该值为2。 0x02, //bInterfaceClass字段。该接口所使用的类。USB键盘是HID类， //HID类的编码为0x03。 0x03, //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中， //只规定了一种子类：支持BIOS引导启动的子类。 //USB键盘、鼠标属于该子类，子类代码为0x01。 0x01, //bInterfaceProtocol字段。如果子类为支持引导启动的子类， //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。 0x01, //iConfiguration字段。该接口的字符串索引值。这里没有，为0。 0x00, /******************HID描述符************************/ //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。 0x09, //bDescriptorType字段。HID描述符的编号为0x21。 0x21, //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。 0x10, 0x01, //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。 0x21, //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。 0x01, //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。 0x22, //bDescriptorLength字段。 //下级描述符的长度。下级描述符为键盘报告描述符。 sizeof(KeyboardReportDescriptor)&amp;0xFF, (sizeof(KeyboardReportDescriptor)&gt;&gt;8)&amp;0xFF, /**********************输入端点描述符***********************/ //bLength字段。端点描述符长度为7字节。 0x07, //bDescriptorType字段。端点描述符编号为0x05。 0x05, //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。 //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。 0x81, //bmAttributes字段。D1~D0为端点传输类型选择。 //该端点为中断端点。中断端点的编号为3。其它位保留为0。 0x03, //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。 //注意低字节在先。 0x10, 0x00, //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。 0x0A, /**********************输出端点描述符***********************/ //bLength字段。端点描述符长度为7字节。 0x07, //bDescriptorType字段。端点描述符编号为0x05。 0x05, //bEndpointAddress字段。端点的地址。我们使用D12的输出端点1。 //D7位表示数据方向，输出端点D7为0。所以输出端点1的地址为0x01。 0x01, //bmAttributes字段。D1~D0为端点传输类型选择。 //该端点为中断端点。中断端点的编号为3。其它位保留为0。 0x03, //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。 //注意低字节在先。 0x10, 0x00, //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。 0x0A, /*******************第二个接口描述符*********************/ //bLength字段。接口描述符的长度为9字节。 0x09, //bDescriptorType字段。接口描述符的编号为0x04。 0x04, //bInterfaceNumber字段。该接口的编号，第二个接口，编号为1。 0x01, //bAlternateSetting字段。该接口的备用编号，为0。 0x00, //bNumEndpoints字段。非0端点的数目。由于USB鼠标需要一个 //中断输入端点，因此该值为1。 0x01, //bInterfaceClass字段。该接口所使用的类。USB键盘是HID类， //HID类的编码为0x03。 0x03, //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中， //只规定了一种子类：支持BIOS引导启动的子类。 //USB键盘、鼠标属于该子类，子类代码为0x01。 0x01, //bInterfaceProtocol字段。如果子类为支持引导启动的子类， //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。 0x02, //iConfiguration字段。该接口的字符串索引值。这里没有，为0。 0x00, /******************HID描述符************************/ //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。 0x09, //bDescriptorType字段。HID描述符的编号为0x21。 0x21, //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。 0x10, 0x01, //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。 0x21, //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。 0x01, //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。 0x22, //bDescriptorLength字段。 //下级描述符的长度。下级描述符为鼠标报告描述符。 sizeof(MouseReportDescriptor)&amp;0xFF, (sizeof(MouseReportDescriptor)&gt;&gt;8)&amp;0xFF, /**********************输入端点描述符***********************/ //bLength字段。端点描述符长度为7字节。 0x07, //bDescriptorType字段。端点描述符编号为0x05。 0x05, //bEndpointAddress字段。端点的地址。我们使用D12的输入端点2。 //D7位表示数据方向，输入端点D7为1。所以输入端点2的地址为0x82。 0x82, //bmAttributes字段。D1~D0为端点传输类型选择。 //该端点为中断端点。中断端点的编号为3。其它位保留为0。 0x03, //wMaxPacketSize字段。该端点的最大包长。端点2的最大包长为64字节。 //注意低字节在先。 0x40, 0x00, //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。 0x0A&#125;; 三、QAQ:无A:无]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USB笔记2_HID]]></title>
    <url>%2F2020%2F08%2F17%2FUSB%E7%AC%94%E8%AE%B02-HID%2F</url>
    <content type="text"><![CDATA[USB笔记2_HID本篇主要浅谈HID Report 一、报告描述符简介1.1 Item介绍报告描述符比较复杂，它是以item形式排列组合而成，无固定长度，用户可以自定义长度以及每一bit的含义。item类型分三种：main，global和local，每种类型又可以分为多个tag： main： Input、Output、Feature、Collection、End Collection global： Usage Page、Logical Minimum、Logical Maximum、Physical Minimum、Physical Maximum、Unit Exponent、Unit、Report Size、Report ID、Report Count、Push、Pop local： Usage、Usage Minimum、Usage Maximum、Designator Index、Designator Minimum、Designator Maximum、String Index、String Minimum、String Maximum、Delimiter、Reserved 1.2 Item之间的关系Main项目中的 input,ouput,feature三个卷标用来表示报告中数据的种类，这些是报告描述符中最主要的项目，其他项目都是用来修饰这三种项目。 Input 项：表示设备操作输入到主机的数据模式。这个数据格式就形成一个输入报告，虽然输入报告可以用控制型管线以get report（input）来传输，但是通常用中断型输入管线来传输以确保在每一固定周期内都能将更新的输入报告传给主机。 Output 项：表示由主机输出到装置操作的数据格式。这个数据格式就形成一个输出报告。输出报告通常不适用轮询的方式来传送给设备，而是由应用软件依实际需求以传令方式要求送出输出报告，所以大多用控制型管线以set report(output)指令来将报告送到设备。当然也可以选择用中断型输出管线来传送，只是通常不建议这样用。 Feature 项：表示由主机送到设备的组态所需数据的数据格式。这个数据模式就形成一个特征报告。特征报告只能用控制型管线以get report(feature)和set report(feature)指令分别来取得和设定设备的特征值 主项目用来定义报告中数据的种类和格式，而说明主项目之意义与用途为全局项目和区域项目。顾名思义，区域性项目只能适用于列于其下的第一个主项目，不适用于其他主项目，若一个主项目之上有几个不同的卷标的区域性项目，则这些区域性项目皆适用于描述该主项目。相反，全局性项目适用于其下方的所有主项目，除非另一个相同卷标的全局性项目出现！！！ 1.3 实例以下是单点触摸屏的示例报告描述符和格式：123456789101112131415161718192021222324252627282930310x05, 0x0D, // Usage Page (Digitizer)0x09, 0x04, // Usage (Touch Screen)0xA1, 0x01, // Collection (Application)0x05, 0x0D, // Usage Page (Digitizer)0x09, 0x22, // Usage (Finger)0xA1, 0x02, // Collection (Logical)0x05, 0x0D, // Usage Page (Digitizer)0x09, 0x33, // Usage (Touch)0x15, 0x00, // Logical Minimum......... (0)0x25, 0x01, // Logical Maximum......... (1)0x75, 0x01, // Report Size............. (1)0x95, 0x01, // Report Count............ (1)0x81, 0x02, // Input...................(Data, Variable, Absolute)0x75, 0x07, // Report Size............. (7)0x95, 0x01, // Report Count............ (1)0x81, 0x01, // Input...................(Constant)0x05, 0x01, // Usage Page (Generic Desktop)0x09, 0x30, // Usage (X)0x15, 0x00, // Logical Minimum......... (0)0x26, 0x20, 0x03, // Logical Maximum......... (800)0x75, 0x10, // Report Size............. (16)0x95, 0x01, // Report Count............ (1)0x81, 0x02, // Input...................(Data, Variable, Absolute)0x09, 0x31, // Usage (Y)0x15, 0x00, // Logical Minimum......... (0)0x26, 0xE0, 0x01, // Logical Maximum......... (480)0x75, 0x10, // Report Size............. (16)0x95, 0x01, // Report Count............ (1)0x81, 0x02, // Input...................(Data, Variable, Absolute)0xC0, // End Collection0xC0, // End Collection 单点触摸屏的输入报告布局示例：12345|Touch | X | Y |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| 0 | 1 | 2 | 3 | 4 | 二、主机和设备之间的通信2.1 获取报告描述符 HID类请求（命令）包格式 偏移量 域 大小 说明 0 bmRequestType 1 HID设备类请求特性如下： 位7： 0＝从USB HOST到USB设备 1＝从USB设备到USB HOST 位6~5： 01＝请求类型为设备类请求 位4~0： 0001＝请求对象为接口（interface）因而，针对HID的设备类请求，仅仅10100001和00100001有效 1 bRequest 1 HID类请求（参考下表） 2 wValue 2 高字节说明描述符的类型0x21：HID描述符 0x22：报告描述符 0x23：物理描述符低字节为非0值时被用来选定实体描述符。 4 wIndex 2 2字节数值，根据不同的bRequest有不同的意义 6 wLength 2 该请求的数据段长度 2.2 实例2.2.1 主机端获取报告描述符（该描述符来自UsbMouse）123456789101112131415USB端点0输出中断。读端点0缓冲区8字节。0x81 0x06 0x00 0x22 0x00 0x00 0x34 0x00 // 来自主机端的请求，HID类请求（命令）包，8个字节USB标准输入请求：获取描述符——报告描述符。 // 报告描述符 52个字节写端点0缓冲区16字节。0x05 0x01 0x09 0x02 0xA1 0x01 0x09 0x01 0xA1 0x00 0x05 0x09 0x19 0x01 0x29 0x03 USB端点0输入中断。写端点0缓冲区16字节。0x15 0x00 0x25 0x01 0x95 0x03 0x75 0x01 0x81 0x02 0x95 0x01 0x75 0x05 0x81 0x03 USB端点0输入中断。写端点0缓冲区16字节。0x05 0x01 0x09 0x30 0x09 0x31 0x09 0x38 0x15 0x81 0x25 0x7F 0x75 0x08 0x95 0x03 USB端点0输入中断。写端点0缓冲区4字节。0x81 0x06 0xC0 0xC0 描述符相关的操作是通过端点0进行通信的，也是USB协议中必须要存在的端点。 2.2.2 设备端输入HID Report123USB端点1输入中断。写端点1缓冲区4字节。0x00 0x00 0x01 0x00 2.2.2 设备端输入HID Report123USB端点1输出中断。读端点1缓冲区4字节。0x00 0x00 0x01 0x00 Host端如果是Linux，调用接口libusb_interrupt_transfer()。可以看出HID控制消息是通过端点1来通信的。 这里的端点1是之前配置描述符中定义的，用于传输真实数据的端点。主机端通过lsusb也可以看到对应的消息：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960root@atlas7-arm:~# lsusb -vd 8888:0001Bus 002 Device 004: ID 8888:0001 Device Descriptor: bLength 18 bDescriptorType 1 bcdUSB 1.10 bDeviceClass 0 (Defined at Interface level) bDeviceSubClass 0 bDeviceProtocol 0 bMaxPacketSize0 16 idVendor 0x8888 idProduct 0x0001 bcdDevice 1.00 iManufacturer 1 iProduct 2 iSerial 3 bNumConfigurations 1 Configuration Descriptor: bLength 9 bDescriptorType 2 wTotalLength 34 bNumInterfaces 1 bConfigurationValue 1 iConfiguration 0 bmAttributes 0x80 (Bus Powered) MaxPower 100mA Interface Descriptor: bLength 9 bDescriptorType 4 bInterfaceNumber 0 bAlternateSetting 0 bNumEndpoints 1 bInterfaceClass 3 Human Interface Device bInterfaceSubClass 1 Boot Interface Subclass bInterfaceProtocol 2 Mouse iInterface 0 HID Device Descriptor: bLength 9 bDescriptorType 33 bcdHID 1.10 bCountryCode 33 US bNumDescriptors 1 bDescriptorType 34 Report wDescriptorLength 52 Report Descriptors: ** UNAVAILABLE ** Endpoint Descriptor: bLength 7 bDescriptorType 5 bEndpointAddress 0x81 EP 1 IN bmAttributes 3 Transfer Type Interrupt Synch Type None Usage Type Data wMaxPacketSize 0x0010 1x 16 bytes bInterval 10Device Status: 0x1fd8 (Bus Powered) Debug Mode 三、QAQ:内核报错usb 1-1: can’t set config #1, error -110A:设备端没有处理主机端发送过来的消息，收到消息需要回复ack SETUP数据包（SET_CONFIGURATION） 正常： 0x00 0x09 0x01 0x00 0x00 0x00 0x00 0x00 异常： 0xC0 0x33 0x00 0x00 0x00 0x00 0x02 0x00]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USB笔记1_UsbMouse]]></title>
    <url>%2F2020%2F08%2F11%2FUSB%E7%AC%94%E8%AE%B01-UsbMouse%2F</url>
    <content type="text"><![CDATA[USB笔记1_UsbMouse本篇主要来自《圈圈教你玩usb》的UsbMouse实例 一、USB枚举过程1.1 Device设备端代码片段12345678910111213141516while(1) //死循环&#123; if(D12GetIntPin()==0) //如果有中断发生 &#123; D12WriteCommand(READ_INTERRUPT_REGISTER); //写读中断寄存器的命令 InterruptSource=D12ReadByte(); //读回第一字节的中断寄存器 if(InterruptSource&amp;0x80)UsbBusSuspend(); //总线挂起中断处理 if(InterruptSource&amp;0x40)UsbBusReset(); //总线复位中断处理 if(InterruptSource&amp;0x01)UsbEp0Out(); //端点0输出中断处理 if(InterruptSource&amp;0x02)UsbEp0In(); //端点0输入中断处理 if(InterruptSource&amp;0x04)UsbEp1Out(); //端点1输出中断处理 if(InterruptSource&amp;0x08)UsbEp1In(); //端点1输入中断处理 if(InterruptSource&amp;0x10)UsbEp2Out(); //端点2输出中断处理 if(InterruptSource&amp;0x20)UsbEp2In(); //端点2输入中断处理 &#125;&#125; 1.2 Device设备端日志1.2.1 SETUP数据包，获取设备描述符123456789USB端点0输出中断。 // host端带返回值的请求，device需要知道输出什么，所以先读8字节读端点0缓冲区8字节。0x80 0x06 0x00 0x01 0x00 0x00 0x40 0x00 USB标准输入请求：获取描述符——设备描述符。 // 设备描述符有18个字节写端点0缓冲区16字节。 // PDIUSBD12的端点0大小的16字节0x12 0x01 0x10 0x01 0x00 0x00 0x00 0x10 0x88 0x88 0x01 0x00 0x00 0x01 0x01 0x02 USB端点0输入中断。写端点0缓冲区2字节。 // 发送剩余的2个字节0x03 0x01 日志显示已经成功接收到主机发送过来的8字节数据。在第一次接收到数据后，会停顿一段时间。这段时间主机一直在请求输入。但是目前还没有返回数据，所以D12一直在回答NAK，即没有数据准备好。结果USB主机经过一段时间的等待之后，终于不耐烦了，发送了一次总线复位，然后又重新输出这8个字节的数据，然后又是等待输入数据。尝试几次后主机只好无奈的放弃了。这是改USB端口上不再有数据活动，从而D12进入了挂起状态。同时在计算机端弹出无法识别的USB设备对话框。 主机端内核日志： [ 9536.933549] usb 2-1: new full-speed USB device number 16 using ci_hdrc [ 9542.053622] usb 2-1: device descriptor read/64, error -110 #define ETIMEDOUT 110 /* Connection timed out */ 1.2.2 设置地址1234567USB总线复位。USB端点0输出中断。读端点0缓冲区8字节。0x00 0x05 0x06 0x00 0x00 0x00 0x00 0x00 USB标准输出请求：设置地址。地址为：0x06 写端点0缓冲区0字节。USB端点0输入中断。 1.2.3 SETUP数据包，基于新地址，重新获取设备描述符123456789USB端点0输出中断。读端点0缓冲区8字节。0x80 0x06 0x00 0x01 0x00 0x00 0x12 0x00 USB标准输入请求：获取描述符——设备描述符。写端点0缓冲区16字节。0x12 0x01 0x10 0x01 0x00 0x00 0x00 0x10 0x88 0x88 0x01 0x00 0x00 0x01 0x01 0x02 USB端点0输入中断。写端点0缓冲区2字节。0x03 0x01 二、描述符2.1 各描述符之间的关系设备描述符（Device Descriptor） 配置描述符（Configuration Descriptor） 接口描述符（Interface Descriptor） HID描述符（HID Device Descriptor） 报告描述符（Report Descriptor） 一个设备描述符可以包含多个配置描述符，通常1个一个配置描述符可以包含多个接口描述符。一个接口描述符可以包含多个端点描述符。 接口描述符跟着配置描述符走的，无法单独存在。 2.2 各描述符简介：2.2.1 设备描述符（Device Descriptor）Device Descriptor: bLength 18 bDescriptorType 1 bcdUSB 1.10 bDeviceClass 0 (Defined at Interface level) bDeviceSubClass 0 bDeviceProtocol 0 bMaxPacketSize0 16 idVendor 0x8888 idProduct 0x0001 bcdDevice 1.00 iManufacturer 1 iProduct 2 iSerial 3 bNumConfigurations 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//USB设备描述符的定义code uint8 DeviceDescriptor[]= //设备描述符为18字节&#123;//bLength字段。设备描述符的长度为18(0x12)字节 0x12,//bDescriptorType字段。设备描述符的编号为0x01 0x01,//bcdUSB字段。这里设置版本为USB1.1，即0x0110。//由于是小端结构，所以低字节在先，即0x10，0x01。 0x10, 0x01,//bDeviceClass字段。我们不在设备描述符中定义设备类，//而在接口描述符中定义设备类，所以该字段的值为0。 0x00,//bDeviceSubClass字段。bDeviceClass字段为0时，该字段也为0。 0x00,//bDeviceProtocol字段。bDeviceClass字段为0时，该字段也为0。 0x00,//bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。 0x10,//idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。//实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。//注意小端模式，低字节在先。 0x88, 0x88,//idProduct字段。产品ID号，由于是第一个实验，我们这里取0x0001。//注意小端模式，低字节应该在前。 0x01, 0x00,//bcdDevice字段。我们这个USB鼠标刚开始做，就叫它1.0版吧，即0x0100。//小端模式，低字节在先。 0x00, 0x01,//iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，//字符串索引就从1开始吧。 0x01,//iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。//注意字符串索引值不要使用相同的值。 0x02,//iSerialNumber字段。设备的序列号字符串索引值。//这里取3就可以了。 0x03,//bNumConfigurations字段。该设备所具有的配置数。//我们只需要一种配置就行了，因此该值设置为1。 0x01&#125;; 2.2.2 配置描述符（Configuration Descriptor）- 接口描述符（Interface Descriptor） - HID描述符（HID Device Descriptor）Configuration Descriptor: bLength 9 bDescriptorType 2 wTotalLength 34 bNumInterfaces 1 bConfigurationValue 1 iConfiguration 0 bmAttributes 0x80 (Bus Powered) MaxPower 100mA Interface Descriptor: bLength 9 bDescriptorType 4 bInterfaceNumber 0 bAlternateSetting 0 bNumEndpoints 1 bInterfaceClass 3 Human Interface Device bInterfaceSubClass 1 Boot Interface Subclass bInterfaceProtocol 2 Mouse iInterface 0 HID Device Descriptor: bLength 9 bDescriptorType 33 bcdHID 1.10 bCountryCode 33 US bNumDescriptors 1 bDescriptorType 34 Report wDescriptorLength 52 Report Descriptor: (length is 52) 略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//USB配置描述符集合的定义//配置描述符总长度为9+9+9+7字节code uint8 ConfigurationDescriptor[9+9+9+7]=&#123; /***************配置描述符***********************/ //bLength字段。配置描述符的长度为9字节。 0x09, //bDescriptorType字段。配置描述符编号为0x02。 0x02, //wTotalLength字段。配置描述符集合的总长度， //包括配置描述符本身、接口描述符、类描述符、端点描述符等。 sizeof(ConfigurationDescriptor)&amp;0xFF, //低字节 (sizeof(ConfigurationDescriptor)&gt;&gt;8)&amp;0xFF, //高字节 //bNumInterfaces字段。该配置包含的接口数，只有一个接口。 0x01, //bConfiguration字段。该配置的值为1。 0x01, //iConfigurationz字段，该配置的字符串索引。这里没有，为0。 0x00, //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的， //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。 0x80, //bMaxPower字段，该设备需要的最大电流量。由于我们的板子 //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位 //电流为2mA，所以这里设置为50(0x32)。 0x32, /*******************接口描述符*********************/ //bLength字段。接口描述符的长度为9字节。 0x09, //bDescriptorType字段。接口描述符的编号为0x04。 0x04, //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。 0x00, //bAlternateSetting字段。该接口的备用编号，为0。 0x00, //bNumEndpoints字段。非0端点的数目。由于USB鼠标只需要一个 //中断输入端点，因此该值为1。 0x01, //bInterfaceClass字段。该接口所使用的类。USB鼠标是HID类， //HID类的编码为0x03。 0x03, //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中， //只规定了一种子类：支持BIOS引导启动的子类。 //USB键盘、鼠标属于该子类，子类代码为0x01。 0x01, //bInterfaceProtocol字段。如果子类为支持引导启动的子类， //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。 0x02, //iConfiguration字段。该接口的字符串索引值。这里没有，为0。 0x00, /******************HID描述符************************/ //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。 0x09, //bDescriptorType字段。HID描述符的编号为0x21。 0x21, //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。 0x10, 0x01, //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。 0x21, //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。 0x01, //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。 0x22, //bDescriptorLength字段。下级描述符的长度。下级描述符为报告描述符。 sizeof(ReportDescriptor)&amp;0xFF, (sizeof(ReportDescriptor)&gt;&gt;8)&amp;0xFF, /**********************端点描述符***********************/ //bLength字段。端点描述符长度为7字节。 0x07, //bDescriptorType字段。端点描述符编号为0x05。 0x05, //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。 //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。 0x81, //bmAttributes字段。D1~D0为端点传输类型选择。 //该端点为中断端点。中断端点的编号为3。其它位保留为0。 0x03, //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。 //注意低字节在先。 0x10, 0x00, //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。 0x0A&#125;; 2.2.3 报告描述符（Report Descriptor）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//USB报告描述符的定义code uint8 ReportDescriptor[]=&#123; //每行开始的第一字节为该条目的前缀，前缀的格式为： //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。 //这是一个全局（bType为1）条目，选择用途页为普通桌面Generic Desktop Page(0x01) //后面跟一字节数据（bSize为1），后面的字节数就不注释了， //自己根据bSize来判断。 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //这是一个局部（bType为2）条目，说明接下来的应用集合用途用于鼠标 0x09, 0x02, // USAGE (Mouse) //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示 //该集合是一个应用集合。它的性质在前面由用途页和用途定义为 //普通桌面用的鼠标。 0xa1, 0x01, // COLLECTION (Application) //这是一个局部条目。说明用途为指针集合 0x09, 0x01, // USAGE (Pointer) //这是一个主条目，开集合，后面跟的数据0x00表示该集合是一个 //物理集合，用途由前面的局部条目定义为指针集合。 0xa1, 0x00, // COLLECTION (Physical) //这是一个全局条目，选择用途页为按键（Button Page(0x09)） 0x05, 0x09, // USAGE_PAGE (Button) //这是一个局部条目，说明用途的最小值为1。实际上是鼠标左键。 0x19, 0x01, // USAGE_MINIMUM (Button 1) //这是一个局部条目，说明用途的最大值为3。实际上是鼠标中键。 0x29, 0x03, // USAGE_MAXIMUM (Button 3) //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值啦） //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。 0x15, 0x00, // LOGICAL_MINIMUM (0) //这是一个全局条目，说明逻辑值最大为1。 0x25, 0x01, // LOGICAL_MAXIMUM (1) //这是一个全局条目，说明数据域的数量为三个。 0x95, 0x03, // REPORT_COUNT (3) //这是一个全局条目，说明每个数据域的长度为1个bit。 0x75, 0x01, // REPORT_SIZE (1) //这是一个主条目，说明有3个长度为1bit的数据域（数量和长度 //由前面的两个全局条目所定义）用来做为输入， //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示 //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。 //这样定义的结果就是，第一个数据域bit0表示按键1（左键）是否按下， //第二个数据域bit1表示按键2（右键）是否按下，第三个数据域bit2表示 //按键3（中键）是否按下。 0x81, 0x02, // INPUT (Data,Var,Abs) //这是一个全局条目，说明数据域数量为1个 0x95, 0x01, // REPORT_COUNT (1) //这是一个全局条目，说明每个数据域的长度为5bit。 0x75, 0x05, // REPORT_SIZE (5) //这是一个主条目，输入用，由前面两个全局条目可知，长度为5bit， //数量为1个。它的属性为常量（即返回的数据一直是0）。 //这个只是为了凑齐一个字节（前面用了3个bit）而填充的一些数据 //而已，所以它是没有实际用途的。 0x81, 0x03, // INPUT (Cnst,Var,Abs) //这是一个全局条目，选择用途页为普通桌面Generic Desktop Page(0x01) 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //这是一个局部条目，说明用途为X轴 0x09, 0x30, // USAGE (X) //这是一个局部条目，说明用途为Y轴 0x09, 0x31, // USAGE (Y) //这是一个局部条目，说明用途为滚轮 0x09, 0x38, // USAGE (Wheel) //下面两个为全局条目，说明返回的逻辑最小和最大值。 //因为鼠标指针移动时，通常是用相对值来表示的， //相对值的意思就是，当指针移动时，只发送移动量。 //往右移动时，X值为正；往下移动时，Y值为正。 //对于滚轮，当滚轮往上滚时，值为正。 0x15, 0x81, // LOGICAL_MINIMUM (-127) 0x25, 0x7f, // LOGICAL_MAXIMUM (127) //这是一个全局条目，说明数据域的长度为8bit。 0x75, 0x08, // REPORT_SIZE (8) //这是一个全局条目，说明数据域的个数为3个。 0x95, 0x03, // REPORT_COUNT (3) //这是一个主条目。它说明这三个8bit的数据域是输入用的， //属性为：Data,Var,Rel。Data说明数据是可以变的，Var说明 //这些数据域是独立的，即第一个8bit表示X轴，第二个8bit表示 //Y轴，第三个8bit表示滚轮。Rel表示这些值是相对值。 0x81, 0x06, // INPUT (Data,Var,Rel) //下面这两个主条目用来关闭前面的集合用。 //我们开了两个集合，所以要关两次。bSize为0，所以后面没数据。 0xc0, // END_COLLECTION 0xc0 // END_COLLECTION&#125;;//通过上面的报告描述符的定义，我们知道返回的输入报告具有4字节。//第一字节的低3位用来表示按键是否按下的，高5位为常数0，无用。//第二字节表示X轴改的变量，第三字节表示Y轴的改变量，第四字节表示//滚轮的改变量。我们在中断端点1中应该要按照上面的格式返回实际的//鼠标数据。 三、QAQ:lsusb获取Report Descriptor异常A:Report Descriptors: UNAVAILABLE 获取Report Descriptorshttp://www.slashdev.ca/2010/05/08/get-usb-report-descriptor-with-linux/]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USB学习]]></title>
    <url>%2F2020%2F07%2F27%2FUSB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[USB学习1. 动机从事汽车电子行业以来，了解到了诸多之前没有接触过的领域，对于一个一直从事中间件开发的我来说，受益匪浅。工作的中心主要是手机互联相关业务，所涉及的领域比较多，多媒体，gstreamer，alsa，USB驱动，iap协议等。自觉除了USB驱动，其他内容都有略知一二，出问题都能从容应对，唯有USB驱动仍是软肋，一直在心中作梗。遂借工作之余，打算探个究竟。 2. 方法应用出生，当然是从应用入手，大概了解了内核驱动实现之后，觉得对USB的理解还是稍有欠缺。遂想到一句古话：纸上得来终觉浅，绝知此事要躬行。 USB in a NutShell https://www.beyondlogic.org/usbnutshell/usb1.shtml 大概了解USB的整体框架 《圈圈教你玩USB》 不可多得的好书，不过并不适合的零基础的人。要有51单片机的基础，USB相关知识。 参考该书实现一个USB外设，对USB有了更深的了解。做一个外设并不容易，还需要参考 《PDIUSBD12》和《AT89C52》手册，弄懂芯片的协议。 《Linux那些事儿之我是USB》 说实话，作者可能很懂USB，但是讲的内容并不像书的名字这么通俗易懂，可能驱动层就是这么难懂吧。可以协助阅读内核相关代码。 《usb_20》 当然，终极目标解释理解spec了，其他都是实现，这个还是内功。 3. 感悟说实话，互联网所谓的全栈工程师，跟嵌入式相比，感觉还是小巫见大巫了。单讲USB，从应用 - 驱动 - USB器件 - MCU(固件) - 设备(LED)。没有点基础还真吃不消。USB整体框图：]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以二项式系数概括]]></title>
    <url>%2F2019%2F03%2F19%2F%E4%BB%A5%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%E6%A6%82%E6%8B%AC%2F</url>
    <content type="text"><![CDATA[Fair Coin: Flip 4 times获得1个Head的概率P(exactly 1 “heads”) = P(HTTT) +P(THTT)+P(TTHT)+P(TTTH)= $\frac{1}{16}$+$\frac{1}{16}$+$\frac{1}{16}$+$\frac{1}{16}$=1/4 获得2个Head的概率4次里面选2次 $C_4^2=\frac{43}{21} = 6$P(exactly 2 “heads”) =$\frac{C_4^2}{16}$ = 3/8 Fair Coin: Flip 5 flips获得3个Head的概率5次里面选3次 $C_5^3=\frac{543}{321} = 10$P(exactly 3 “heads”) =$\frac{C_5^3}{32} $ = 5/16 Fair Coin: Flip n flips获得k个Head的概率n次里面选k次 $C_n^k= \frac{\frac{n!}{(n-k!)}}{k!}=\frac{n(n-1)…(n-k+1)}{k(k-1)…1}$all the probability = $2^{n}$P(exactly k “heads”) =$\frac{n(n-1)…(n-k+1)}{2^{n}k*(k-1)…1}$]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本概率]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%9F%BA%E6%9C%AC%E6%A6%82%E7%8E%87%2F</url>
    <content type="text"><![CDATA[ProbabilityP(H) = # of possibility that meet by condition / # of equally likely possibility]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扑克中的概率和文氏图]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%89%91%E5%85%8B%E4%B8%AD%E7%9A%84%E6%A6%82%E7%8E%87%E5%92%8C%E6%96%87%E6%B0%8F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[扑克中的概率P(Jack) = 4/52 = 1/13 P(♥) = 13/52 = 1/4 P(J and ♥) = 1/52 p(J or ♥) = (4+13-1)/52 = 16/52 = 4/13 文氏图1234567891011121314151617181920'''' # of Jacks / / +---------/--------------------------+ | / 52 | | /--/--\ | | | 4 | | | | /-----------\ | | \---|./ | | | ,'` 13 | | | _-` | | | | .' \--------\--/ | ,-` \ | # of J -` | \ | and ♥ | \ | +---------------------\--------------+ \ # of ♥ '''']]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率相加]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%A6%82%E7%8E%87%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[概率相加P(A or B) = P(A) + P(B) - P(A and B) 文氏图12345678910111213141516171819''' +-----------------------------------------+ | | | /----------------\ | | | | | | | A | | | | /--------------------\ | | | | A | | | | | | and | B | | | | | B | | | | | | | | | | \----------|-----/ | | | | | | | | | | | \--------------------/ | | | +-----------------------------------------+ ''']]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列组合]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[定义排列排列的定义：从n个不同元素中，任取m(m≤n,m与n均为自然数,下同）个元素按照一定的顺序排成一列，叫做从n个不同元素中取出m个元素的一个排列；从n个不同元素中取出m(m≤n）个元素的所有排列的个数，叫做从n个不同元素中取出m个元素的排列数，用符号 A(n,m）表示。$$计算公式：A^m_n = n(n-1)(n-2)…（n-m+1）=\frac{n!}{(n-m)!}$$ 组合组合的定义：从n个不同元素中，任取m(m≤n）个元素并成一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m≤n）个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数。用符号 C(n,m) 表示。$$计算公式：C^m_n =C^nr=C^n{n-r}=\frac{A^m_n}{m!}=\frac{n!}{m!(n-m)!};C(n,m)=C(n,n-m).n&gt;=m\C^r_n =\binom{n}{r}=\dbinom{n}{n-r}$$]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立事件]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8B%AC%E7%AB%8B%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Find the probability of getting exactly two “head” when flipping three coins. HHH THH HHT THT HTH TTH HTT TTT $$p(2’H’) = \frac{3}{8}$$ 计算骰子的概率两个骰子一次投掷得到的数值和：方法1：枚举| | 1 | 2 | 3 | 4 | 5 | 6 || —- | —- | —- | —- | —- | —- | —- || 1 | 2 | 3 | 4 | 5 | 6 | 7 || 2 | 3 | 4 | 5 | 6 | 7 | 8 || 3 | 4 | 5 | 6 | 7 | 8 | 9 || 4 | 5 | 6 | 7 | 8 | 9 | 10 || 5 | 6 | 7 | 8 | 9 | 10 | 11 || 6 | 7 | 8 | 9 | 10 | 11 | 12 |P(7) = 6/36方法2：P(5) = 4 / 36| D1 | D2 || —- | —- || 1 | 4 || 2 | 3 || 3 | 2 || 4 | 1 |]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相依事件的概率]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%9B%B8%E4%BE%9D%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%A6%82%E7%8E%87%2F</url>
    <content type="text"><![CDATA[剩下的35张取到1的概率36张卡片，分别1-9的四种花色(方块，红桃，梅花，黑桃)的卡片。随机取出9张，其中有四张是1的概率是多少？ 解法1P(all 4 cards is 1 in my hand of 9) = (# of ways in which event can happened)/(the total # of hands) total # of hands = $\frac{363534333231302928}{987654321}$ the # of hands with 4 1’s = $\frac{11113231302928}{54321}$ P(all 4 cards is 1 in my hand of 9) = $\frac{11113231302928}{54321} \frac{987654321}{3635343332313029*28}$= $\frac{2}{935}$ 解法2 取到一张1的概率 剩下的35张取到1的概率 剩下的34张取到1的概率 剩下的33张取到1的概率 $\frac{1}{36}*9$ $\frac{1}{35}*8$ $\frac{1}{34}*7$ $\frac{1}{33}*6$]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立事件的组合概率]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8B%AC%E7%AB%8B%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%84%E5%90%88%E6%A6%82%E7%8E%87%2F</url>
    <content type="text"><![CDATA[独立事件的组合概率P(H)= 1/2 P(T) = 1/2 Two way to figure out the result1. 枚举出所有的情况P(H,H) = 1/4 (H,H ; H,T ; T,H ; T,T) 2. 每次事件都是独立的，计算独立事件都发生的概率P(H,H) = P(H) P(H) = (1/2) (1/2) = 1/4 P(T,H,T) = P(T) P(H) P(T) = (1/2) (1/2) (1/2) = 1/8]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝叶斯定理]]></title>
    <url>%2F2019%2F03%2F19%2F%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[贝叶斯定理:$$P(b|a) = \frac{P(a|b)P(b)}{P(a)}$$证明：$P(a \cap b) = P(a|b)P(b)$$P(a \cap b) = P(b \cap a) = P(b|a)P(a)$$P(a|b)P(b) = P(b|a)P(a)$$P(b|a) = \frac{P(a|b)P(b)}{P(a)}$ Ex1:一个袋子里有：5个均匀的硬币，10个不均匀的硬币(0.8 H, 0.2 T)求：取6枚4枚是Head，都是去的均匀硬币的概率。即：P(Fair|4/6 Heads)$P(Fair|4/6 Heads) = \frac{P(4/6 Heads|Fair)P(Fair)}{P(4/6 Heads)}$ Ex2:一个班上有30个学生，至少2个同学生日是同一天的概率。解：P(至少2个同学生日是同一天) = 1 - P(没有同学生日在同一天)P(没有同学生日在同一天) = $\frac{A^{30}_{365}}{365^{30}}$]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i.Max6移植Movidius]]></title>
    <url>%2F2019%2F01%2F14%2Fi.Max6%E7%A7%BB%E6%A4%8DMovidius%2F</url>
    <content type="text"><![CDATA[0、概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时隔半年有余，由于工作的原因没能更新机器学习方面的内容。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之间林林总总，看完了《UNIX网络编程卷1：套接字联网API（第3版）》，《Linux多线程服务端编程：使用muduo C++网络库》和《Netty权威指南》的部分章节，完成了Tbox Telemetics模块的设计和编码，在这之前其实已对网络编程有所了解，也尝试用MFC编写过类QQ的sample，只是功能简单，单客户端/单服务端之间的通信，然真正用于网络通信的协议未曾染指。网络编程方面的知识，在这次的开发工作中得以锻炼，略有心得一二。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更换项目的间隙，中间有空闲二周，正直双十一，遂购架构书籍数本，看完《架构整洁之道》开始对于软件架构有了进一步的了解，科室读书会分享之，感觉功力倍增。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新年交替之际，开始AI实验室的预研，主要针对边缘计算，驾驶行为分析。嵌入式的硬件限制，只能外挂计算棒，开始研究Intel的Movidius，接触到了OpenVINO工具套件。本篇主要就是介绍一下NCS2在树莓派上的移植。 1、环境搭建 树莓派。系统Raspbian* 9 OS，官网下载最新版本即可。 The Intel™ Distribution of OpenVINO™ for Raspbian OS package to download is here and the Installation document here. 2、步骤IntroductionThis guide applies to 32-bit Raspbian 9 OS, which is an official OS for Raspberry Pi boards. IMPORTANT: All steps in this guide are required unless otherwise stated. The Intel® Distribution of OpenVINO™ toolkit for Raspbian* OS includes the MYRIAD plugin &gt;only. You can use it with the Intel® Movidius™ Neural Compute Stick (Intel® NCS) or the Intel® &gt;Neural Compute Stick 2 plugged in one of USB ports. ###About the Intel® Distribution of OpenVINO™ ToolkitThe Intel® Distribution of OpenVINO™ toolkit quickly deploys applications and solutions that emulate human vision. Based on Convolutional Neural Networks (CNN), the toolkit extends computer vision (CV) workloads across Intel® hardware, maximizing performance. The Intel Distribution of OpenVINO toolkit includes the Intel® Deep Learning Deployment Toolkit (Intel® DLDT). ###Included in the Installation PackageThe Intel Distribution of OpenVINO toolkit for Raspbian OS is an archive with pre-installed header files and libraries. The following components are installed by default: Component Description Inference Engine This is the engine that runs the deep learning model. It includes a set of libraries for an easy inference integration into your applications. OpenCV* version 4.0 OpenCV* community version compiled for Intel® hardware. Sample Applications A set of simple console applications demonstrating how to use the Inference Engine in your applications. ###System Requirements ###Hardware: Raspberry Pi* board with ARMv7-A CPU architectureOne of Intel® Movidius™ Visual Processing Units (VPU):Intel® Movidius™ Neural Compute StickIntel® Neural Compute Stick 2 ###Operating Systems: Raspbian* Stretch, 32-bit Install the PackageOpen the Terminal* or your preferred console application.Go to the directory in which you downloaded the Intel Distribution of OpenVINO toolkit. This document assumes this is your ~/Downloads directory. If not, replace ~/Downloads with the directory where the file is located. cd ~/Downloads/ By default, the package file is saved as l_openvino_toolkit_iep.tgz.Unpack the archive: tar -xf l_openvino_toolkit_iep.tgz Modify the setupvars.sh script by replacing with the absolute path to the installation folder: sed -i “s||$(pwd)/inference_engine_vpu_arm|” inference_engine_vpu_arm/bin/setupvars.shNow the Intel Distribution of OpenVINO toolkit is ready to be used. Continue to the next sections to configure the environment and set up USB rules. Set the Environment VariablesYou must update several environment variables before you can compile and run Intel Distribution of OpenVINO toolkit applications. Run the following script to temporarily set the environment variables: source inference_engine_vpu_arm/bin/setupvars.sh (Optional) The Intel Distribution of OpenVINO environment variables are removed when you close the shell. As an option, you can permanently set the environment variables as follows: Open the .bashrc file in : vi /.bashrc Add this line to the end of the file: source ~/Downloads/inference_engine_vpu_arm/bin/setupvars.sh Save and close the file: press Esc and type :wq.To test your change, open a new terminal.You will see the following: [setupvars.sh] OpenVINO environment initialized Add USB RulesAdd the current Linux user to the users group: sudo usermod -a -G users “$(whoami)” Log out and log in for it to take effect. To perform inference on the Intel® Movidius™ Neural Compute Stick or Intel® Neural Compute Stick 2, install the USB rules as follows: sh inference_engine_vpu_arm/install_dependencies/install_NCS_udev_rules.sh Build and Run Object Detection SampleFollow the next steps to run pre-trained Face Detection network using samples from Intel Distribution of OpenVINO toolkit: Go to the folder with samples source code: cd inference_engine_vpu_arm/deployment_tools/inference_engine/samples Create build directory: mkdir build &amp;&amp; cd build Build the Object Detection Sample: cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=”-march=armv7-a”make -j2 object_detection_sample_ssd Download the pre-trained Face Detection model or copy it from a host machine:To download the .bin file with weights: wget –no-check-certificate https://download.01.org/openvinotoolkit/2018_R4/open_model_zoo/face-detection-adas-0001/FP16/face-detection-adas-0001.bin To download the .xml file with the network topology: wget –no-check-certificate https://download.01.org/openvinotoolkit/2018_R4/open_model_zoo/face-detection-adas-0001/FP16/face-detection-adas-0001.xml Run the sample with specified path to the model:Copy Code ./armv7l/Release/object_detection_sample_ssd -m face-detection-adas-0001.xml -d MYRIAD -i Run Face Detection Model Using OpenCV* APITo validate OpenCV installation, you may try to run OpenCV’s deep learning module with Inference Engine backend. Here is a Python sample, which works with Face Detection model: Download the pre-trained Face Detection model or copy it from a host machine:To download the .bin file with weights: wget –no-check-certificate https://download.01.org/openvinotoolkit/2018_R4/open_model_zoo/face-detection-adas-0001/FP16/face-detection-adas-0001.bin To download the .xml file with the network topology: wget –no-check-certificate https://download.01.org/openvinotoolkit/2018_R4/open_model_zoo/face-detection-adas-0001/FP16/face-detection-adas-0001.xml Create a new Python file named as openvino_fd_myriad.py and copy the following script there:12345678910111213141516171819202122232425262728import cv2 as cv# Load the model net = cv.dnn.readNet('face-detection-adas-0001.xml', 'face-detection-adas-0001.bin') # Specify target device net.setPreferableTarget(cv.dnn.DNN_TARGET_MYRIAD) # Read an image frame = cv.imread('/path/to/image') # Prepare input blob and perform an inference blob = cv.dnn.blobFromImage(frame, size=(672, 384), ddepth=cv.CV_8U) net.setInput(blob) out = net.forward() # Draw detected faces on the frame for detection in out.reshape(-1, 7): confidence = float(detection[2]) xmin = int(detection[3] * frame.shape[1]) ymin = int(detection[4] * frame.shape[0]) xmax = int(detection[5] * frame.shape[1]) ymax = int(detection[6] * frame.shape[0]) if confidence &gt; 0.5: cv.rectangle(frame, (xmin, ymin), (xmax, ymax), color=(0, 255, 0))# Save the frame to an image file cv.imwrite('out.png', frame) Run the script: python3 openvino_fd_myriad.py In this script, OpenCV* loads the Face Detection model in the Intermediate Representation (IR) format and an image. Then it runs the model and saves an image with detected faces. 3、i.Max6移植&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理论上树莓派上编译的产物可以直接拷贝到相同处理器架构的i.Max6上(CPU都是ARMv7)，不过由于各个公司BSP对内核裁剪和集成编译的时候包含的软件包不同，需要修改的内容也不尽相同。这里写的是本司的开发板环境缺少的依赖： python3 lsb_release libstdc++ -&gt; 3.4.22 vi inference_engine_vpu_arm/install_dependencies/install_NCS_udev_rules.sh:%s/sudo//g #删除所有的sudo touch /etc/ld.so.conf 4、总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初步了解OpenVINO发现其是一大宝藏，里面包含了几十种流行模型的，并且有大量sample可以参考学习，可以通过组合各个模型实现自己想要的功能。增加对机器学习的实战经验，加深对机器学习的理解。遗憾的是Intel的NCS2目前貌似只支持深度学习的预测，之于一般的机器学习模型是否也支持，有待考证。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld驱动模块]]></title>
    <url>%2F2018%2F09%2F17%2FHelloWorld%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[0、概述本章主要通过一个简单的实例，实现驱动模块的加载和卸载，并不实现具体的功能。 1、介绍1.1、编写hello.c1234567891011121314151617#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;MODULE_LICENSE("Dual BSD/GPL");static int hello_init(void)&#123; printk(KERN_ALERT "Hello, world\n");&#125;static void hello_exit(void)&#123; printk(KERN_ALERT "Goodbye, cruel world\n");&#125;module_init(hello_init);module_exit(hello_exit); 这个模块定义了两个函数，一个在模块加载到内核时被调用（hello_init），一个在模块去除时被调用（hello_exit）。module_init和module_exit这几行使用了特别的内核宏来指出这两个函数的角色。另一个特别的宏（MODULE_LICENSE）是用来告知内核，该模块带有一个自由的许可证，没有这样的说明，在模块加载时内核会报错。 printk函数在Linux内核中定义并且对模块可用，它与标准C库函数printf的行为相似。内核需要它自己的打印函数，因为没有C库的支持。字串KERN_ALERT是消息的优先级。在此模块中指定了一个高优先级，因为使用默认优先级的消息可能不会直接显示，这依赖于运行的内核版本、klogd守护进程的版本以及配置。 1.2、编写Makefile为了编译模块文件，有两种方法创建Makefile文件可以实现:1、只需一行即可，命令如下： obj-m := hello.o obj-m指出将要编译成的内核模块列表。.o 格式文件会自动地由相应的 .c 文件生成（不需要显式地罗列所有源代码文件）如果要把上述程序编译为一个运行时加载和删除的模块，则编译命令如下所示。 make -C /usr/src/kernels/2.6.25-14.fc9.i686 M=$PWD modules 这个命令首先是改变目录到用 -C 选项指定的位置（即内核源代码目录，这个参数要根据自己的情况而定）。这个 M= 选项使Makefile在构造modules目标前，返回到模块源码目录。然后，modules目标指向obj-m变量中设定的模块。这里的编译规则的意思是：在包含内核源代码位置的地方进行make，然后再编译 $PWD （当前）目录下的modules。这里允许我们使用所有定义在内核源代码树下的所有规则来编译我们的内核模块。 2、使用下面的Makefile来实现：12345678ifneq ($(KERNELRELEASE),) obj-m := hello.oelse KERNELDIR ?= /lib/modules/$(shell uname -r)/build PWD :=$(shell pwd)default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modulesendif 然后保存后，使用make命令。编译完毕之后，就会在源代码目录下生成hello.ko文件，这就是内核驱动模块了。我们使用下面的命令来加载hello模块。 1.3、效果 dmesg | tail 这时，在终端里就会打印出内核信息了。同时，也可以使用lsmod命令来查看是否有加载了 xuleilx@xuleilx-MS-7817:/opt# lsmodModule Size Used byhelloworld 12448 0 至此，一个最简单的内核模块驱动程序就完成了。^_^ 2、总结至此，打开通往内核的大门。 下一步计划：编写字符设备驱动，可以存放一些数值。]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AndroidFramework学习之旅]]></title>
    <url>%2F2018%2F09%2F11%2FAndroidFrameWork%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[作为一名开发者，Linux内核源码必定是其追求的终极目标。自觉愚钝，一直未敢染指Linux 内核源码。工作八年有余，解决Bug无数，设计模式，重构，STL库等也熟知一二，然对于一 些涉及底层的问题未能深入剖析，自觉功力不足。 近几年机器学习嫣然成为风口浪尖的弄潮儿，于是自学半年有余，略有心得，自觉入门。然在 实际工作和运用中缺乏实战机会，且与自己的职业生涯规划略有出入，遂放缓脚步，寻找更好 的学习点。 Android系统一直是Linux开发者鄙夷的对象，愚随大流，以勉Android代码为耻，然 Android数年以来表现依然如此强势，尤近年来车载行业对于Android系统的接纳，传统车载 行业必然会受到一定的冲击，Android系统的架构也是经受过数年的考验，其架构的成熟性以 及通用性耳目共睹，遂决定开始学习Android系统架构。 于是开始我的Android系统的学习之旅，对于学习这件事，随着年龄的增长，也有了自己独特 的一套方法。一般会去知乎上搜索一些对于一门技术的学习方法或是推荐书籍，于是检索到： https://www.zhihu.com/question/19759722 看完这些文章所说的对于C/C++和Linux系统知识 的要求后信心倍增，自觉对于这些方面的知识很有自信。 第一阶段打算跟着&quot;老罗的Android之旅&quot;，学完之后也应该有自己的一套知识体系了。先从内 核入手，不求甚解，能够摸索出内核代码的阅读方法，就已经足够，也不指望看一遍书就能摸 透。根据 老罗的Android之旅 提到的《Linux Kernel Development》、 《Understanding the Linux Kernel》、《Linux Device Drivers》和 《Linux内核源代码情景分析》开始入手内核。 分成两个阶段：内核学习，安卓FrameWork 第一阶段，开始我的内核学习之旅： 1.编译Android系统代码 2018/08/27 ~ 2.《Linux Kernel Development》 2018/08/27 ~ 2018/09/07 3.字符设备驱动程序 2018/09/11 ~ 4.《LDD3》 2018/09/11 ~]]></content>
      <tags>
        <tag>AndroidFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataVisualisation]]></title>
    <url>%2F2018%2F06%2F28%2FDataVisualisation%2F</url>
    <content type="text"><![CDATA[0、概述本阶段完成了关于数据可视化的学习，这部分的学习为我打开了一扇通往新世界的大门。 一个人如果能再某个领域成为专家就已经是一件很了不起的事情了，对于MachineLearner来说，将会面对不同领域的问题，需要具备不同的DomainKnowledge是一件几乎不可能的事情，可能我们通过几周或者甚至几天的学习，对问题领域有个大概的了解，但是对不同的Feature之间的关系，影响可能就无法知晓了，当然我们可以通过咨询相应领域的专家，不过这实际上也是一件相当不易的事情。 数据可视化就想武器中的瑞士军刀，它将数据以图表的形式展现在MachineLearner的面前，通过观察图表，我们可以知道数据与数据之间的联系，可以连接到数据的走上，范围，概率分布等。通过这些，我们可以方便的挑选适合我们模型的Features。 1、思维导图 2、使用方法2.1、Univariate plotting with pandas1234567891011121314151617181920import pandas as pdreviews = pd.read_csv("../input/wine-reviews/winemag-data_first150k.csv", index_col=0)reviews.head(3)# Bar Chat# Good for nominal and small ordinal categorical data.reviews['province'].value_counts().head(10).plot.bar()(reviews['province'].value_counts().head(10) / len(reviews)).plot.bar()reviews['points'].value_counts().sort_index().plot.bar()# Line charts# Good for ordinal categorical and interval data.reviews['points'].value_counts().sort_index().plot.line()# Area charts# Good for ordinal categorical and interval data.reviews['points'].value_counts().sort_index().plot.area()# Histogram# Good for interval data.reviews[reviews['price'] &lt; 200]['price'].plot.hist() 2.2、Bivariate plotting with pandas1234567891011121314151617181920212223import pandas as pdreviews = pd.read_csv("../input/wine-reviews/winemag-data_first150k.csv", index_col=0)reviews.head()# Scatter Plot# Good for interval and some nominal categorical data.reviews[reviews['price'] &lt; 100].sample(100).plot.scatter(x='price', y='points')# Hex Plot# Good for interval and some nominal categorical data.reviews[reviews['price'] &lt; 100].plot.hexbin(x='price', y='points', gridsize=15)# Stacked Bar Chart# Good for nominal and ordinal categorical data.wine_counts = pd.read_csv("../input/most-common-wine-scores/top-five-wine-score-counts.csv",index_col=0)wine_counts.head()wine_counts.plot.bar(stacked=True)wine_counts.plot.area()# Bivariate Line Chart# Good for ordinal categorical and interval data.wine_counts.plot.line() 2.3、Multivariate plotting with pandas123456789101112131415161718192021222324252627282930import pandas as pdpd.set_option('max_columns', None)df = pd.read_csv("../input/fifa-18-demo-player-dataset/CompleteDataset.csv", index_col=0)import reimport numpy as npfootballers = df.copy()footballers['Unit'] = df['Value'].str[-1]footballers['Value (M)'] = np.where(footballers['Unit'] == '0', 0, footballers['Value'].str[1:-1].replace(r'[a-zA-Z]',''))footballers['Value (M)'] = footballers['Value (M)'].astype(float)footballers['Value (M)'] = np.where(footballers['Unit'] == 'M', footballers['Value (M)'], footballers['Value (M)']/1000)footballers = footballers.assign(Value=footballers['Value (M)'], Position=footballers['Preferred Positions'].str.split().str[0])# Parallel Coordinatesfrom pandas.plotting import parallel_coordinatesf = ( footballers.iloc[:, 12:17] .loc[footballers['Position'].isin(['ST', 'GK'])] .applymap(lambda v: int(v) if str.isdecimal(v) else np.nan) .dropna())f['Position'] = footballers['Position']f = f.sample(200)parallel_coordinates(f, 'Position') 2.4、Plotting with seaborn123456789101112131415161718192021222324252627282930313233343536import pandas as pdreviews = pd.read_csv("../input/wine-reviews/winemag-data_first150k.csv", index_col=0)import seaborn as sns# Count (Bar) Plot# Good for nominal and small ordinal categorical data.sns.countplot(reviews['points'])# KDE Plot# Good for interval data.sns.kdeplot(reviews.query('price &lt; 200').price)sns.kdeplot(reviews[reviews['price'] &lt; 200].loc[:, ['price', 'points']].dropna().sample(5000))# Distplotsns.distplot(reviews['points'], bins=10, kde=False)# Joint (Hex) Plot# Good for interval and some nominal categorical data.sns.jointplot(x='price', y='points', data=reviews[reviews['price'] &lt; 100])sns.jointplot(x='price', y='points', data=reviews[reviews['price'] &lt; 100], kind='hex', gridsize=20)# Boxplot and violin plot# Good for interval data and some nominal categorical data.df = reviews[reviews.variety.isin(reviews.variety.value_counts().head(5).index)]sns.boxplot( x='variety', y='points', data=df)sns.violinplot( x='variety', y='points', data=reviews[reviews.variety.isin(reviews.variety.value_counts()[:5].index)]) 2.5、Faceting with seaborn1234567891011121314151617# Facet Grid# Good for data with at least two categorical variables.import seaborn as snsdf = footballers[footballers['Position'].isin(['ST', 'GK'])]g = sns.FacetGrid(df, col="Position")g.map(sns.kdeplot, "Overall")g = sns.FacetGrid(df, col="Position", col_wrap=6)g.map(sns.kdeplot, "Overall")df = df[df['Club'].isin(['Real Madrid CF', 'FC Barcelona', 'Atlético Madrid'])]g = sns.FacetGrid(df, row="Position", col="Club")g.map(sns.violinplot, "Overall")# Pair Plot# Good for exploring most kinds of data.sns.pairplot(footballers[['Overall', 'Potential', 'Value']]) 2.6、Multivariate plotting with seaborn1234567891011121314151617181920212223# Multivariate Scatter Plotsns.lmplot(x='Value', y='Overall', markers=['o', 'x', '*'], hue='Position', data=footballers.loc[footballers['Position'].isin(['ST', 'RW', 'LW'])], fit_reg=False )# Grouped Box Plotf = (footballers .loc[footballers['Position'].isin(['ST', 'GK'])] .loc[:, ['Value', 'Overall', 'Aggression', 'Position']] )f = f[f["Overall"] &gt;= 80]f = f[f["Overall"] &lt; 85]f['Aggression'] = f['Aggression'].astype(float)sns.boxplot(x="Overall", y="Aggression", hue='Position', data=f)# Heatmapf = ( footballers.loc[:, ['Acceleration', 'Aggression', 'Agility', 'Balance', 'Ball control']] .applymap(lambda v: int(v) if str.isdecimal(v) else np.nan) .dropna()).corr()sns.heatmap(f, annot=True) 3、总结通过这一阶段的学习，掌握了主流的python库pandas，seaborn的绘图方法，之前学习的matplotlib的知识也在这段时间稍微复习了一下，希望在今后的实践中好好运用数据可视化这部分的知识。并且帮助评价训练出来的模型。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas总结]]></title>
    <url>%2F2018%2F06%2F25%2Fpandas%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0、概述 这段时间主要学习了kaggle网站上的“pandas”的部分。俗话说的好：学过的东西通过 自己的理解转换成自己的东西才算是学会。所以说每学完一个知识点都要做一个总结，依赖理 清自己的只是结构，而来温故而知新。网址：https://www.kaggle.com/learn/pandas 最近刚从知乎上看到一个帖子，主要是讲如何学习，成为别人眼中的学霸。总结了一下主 要有以下四点（排名不分先后）：1、自律 2、目标 3、计划 4、理解。所以逼着自己学 完一个知识点写总结，旅游要写游记。与自己死磕到底。 1、思维导图 2、使用方法 本阶段刚刚接触Pandas不久，给我总体的印象是不需要专门的学习，pandas只是工 具，需要的时候可以网上查询，一般的需求这样就可以满足了。如果想对数据进行分析就需要 系统的学习一下，很多功能网上说的不清楚，一些学的半斤八两的人喜欢发这些玩意儿，学一 下官网的Tutorials和Cookbook。网址：http://pandas.pydata.org/pandas-docs/stable/ 3、总结 回想4,5年前在FNST使用Ruby制作语音播报工具，学到的东西还是挺多的，接触到了 CSV/EXCEL文件操作，面向对象语言的进一步理解，lambda，无数据类型语言，TTS等。现 在感叹为啥不适用Python啊，现在就不要学了，不过Python和Ruby很像，学起来很快就上 手了。CSV/EXCEL文件操作不就是现在学的pandas嘛。哈哈~ 学无止境，学海无涯。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习总结]]></title>
    <url>%2F2018%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0、概述 这段时间主要学习了kaggle网站上的“机器学习”的部分。之前很长一段时间都是在学习 理论，没有机会实践，Kaggle是个不错的平台，有很多使用的难题等待着全世界聪敏的头脑 去解决。通过本篇的学习，很好的将理论知识用到了实践当中，比如之前学习到的绘制模型在 样本集和测试集上的准确率，防止模型过拟合和欠拟合，选择最优的点。还有之前不明白交叉 验证的作用，以及实际效果。网址：https://www.kaggle.com/learn/machine-learning 1、思维导图 2、步骤2.1、分析数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354############## 观察数据 ##############import pandas as pd# save filepath to variable for easier accessmelbourne_file_path = '../input/melbourne-housing-snapshot/melb_data.csv'# read the data and store data in DataFrame titled melbourne_datamelbourne_data = pd.read_csv(melbourne_file_path) # print a summary of the data in Melbourne dataprint(melbourne_data.describe())print(melbourne_data.columns)############## 选择过滤数据 ############### store the series of prices separately as melbourne_price_data.melbourne_price_data = melbourne_data.Price# the head command returns the top few lines of data.print(melbourne_price_data.head())columns_of_interest = ['Landsize', 'BuildingArea']two_columns_of_data = melbourne_data[columns_of_interest]two_columns_of_data.describe()y = melbourne_data.Pricemelbourne_predictors = ['Rooms', 'Bathroom', 'Landsize', 'Lattitude', 'Longtitude']X = melbourne_data[melbourne_predictors]############## Partial Dependence Plots ##############import pandas as pdfrom sklearn.ensemble import GradientBoostingRegressor, GradientBoostingClassifierfrom sklearn.ensemble.partial_dependence import partial_dependence, plot_partial_dependencefrom sklearn.preprocessing import Imputercols_to_use = ['Distance', 'Landsize', 'BuildingArea']def get_some_data(): data = pd.read_csv('../input/melbourne-housing-snapshot/melb_data.csv') y = data.Price X = data[cols_to_use] my_imputer = Imputer() imputed_X = my_imputer.fit_transform(X) return imputed_X, y X, y = get_some_data()my_model = GradientBoostingRegressor()my_model.fit(X, y)my_plots = plot_partial_dependence(my_model, features=[0,2], X=X, feature_names=cols_to_use, grid_resolution=10)############## Data Leakage ############### Leaky Predictors# 数据集中包含预测时不可用的数据。比如，患有癌症的病人，使用了抗生素。# Leaky Validation Strategy# 检验策略有问题。或者测试集的数据影响了验证集数据。比如，调用train_test_split之前运行预处理（如为缺失值拟合Imputer）。 2.2、数据处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697############## 检查数据是否有空项 ##############print(data.isnull().sum())############## 丢掉含有空的数据列 ##############cols_with_missing = [col for col in X_train.columns if X_train[col].isnull().any()]reduced_X_train = X_train.drop(cols_with_missing, axis=1)reduced_X_test = X_test.drop(cols_with_missing, axis=1)print("Mean Absolute Error from dropping columns with Missing Values:")print(score_dataset(reduced_X_train, reduced_X_test, y_train, y_test))############## 填充空的数据列 ##############from sklearn.preprocessing import Imputermy_imputer = Imputer()imputed_X_train = my_imputer.fit_transform(X_train)imputed_X_test = my_imputer.transform(X_test)print("Mean Absolute Error from Imputation:")print(score_dataset(imputed_X_train, imputed_X_test, y_train, y_test))############## 扩展填充空的数据列 ##############imputed_X_train_plus = X_train.copy()imputed_X_test_plus = X_test.copy()cols_with_missing = (col for col in X_train.columns if X_train[col].isnull().any())for col in cols_with_missing: imputed_X_train_plus[col + '_was_missing'] = imputed_X_train_plus[col].isnull() imputed_X_test_plus[col + '_was_missing'] = imputed_X_test_plus[col].isnull()# Imputationmy_imputer = Imputer()imputed_X_train_plus = my_imputer.fit_transform(imputed_X_train_plus)imputed_X_test_plus = my_imputer.transform(imputed_X_test_plus)print("Mean Absolute Error from Imputation while Track What Was Imputed:")print(score_dataset(imputed_X_train_plus, imputed_X_test_plus, y_train, y_test))############## 将非数值列One-Hot Encoding ############### Read the dataimport pandas as pdtrain_data = pd.read_csv('../input/train.csv')test_data = pd.read_csv('../input/test.csv')# Drop houses where the target is missingtrain_data.dropna(axis=0, subset=['SalePrice'], inplace=True)target = train_data.SalePrice# Since missing values isn't the focus of this tutorial, we use the simplest# possible approach, which drops these columns. # For more detail (and a better approach) to missing values, see# https://www.kaggle.com/dansbecker/handling-missing-valuescols_with_missing = [col for col in train_data.columns if train_data[col].isnull().any()] candidate_train_predictors = train_data.drop(['Id', 'SalePrice'] + cols_with_missing, axis=1)candidate_test_predictors = test_data.drop(['Id'] + cols_with_missing, axis=1)# "cardinality" means the number of unique values in a column.# We use it as our only way to select categorical columns here. This is convenient, though# a little arbitrary.low_cardinality_cols = [cname for cname in candidate_train_predictors.columns if candidate_train_predictors[cname].nunique() &lt; 10 and candidate_train_predictors[cname].dtype == "object"]numeric_cols = [cname for cname in candidate_train_predictors.columns if candidate_train_predictors[cname].dtype in ['int64', 'float64']]my_cols = low_cardinality_cols + numeric_colstrain_predictors = candidate_train_predictors[my_cols]test_predictors = candidate_test_predictors[my_cols]print(train_predictors.dtypes.sample(10))one_hot_encoded_training_predictors = pd.get_dummies(train_predictors)from sklearn.model_selection import cross_val_scorefrom sklearn.ensemble import RandomForestRegressordef get_mae(X, y): # multiple by -1 to make positive MAE score instead of neg value returned as sklearn convention return -1 * cross_val_score(RandomForestRegressor(50), X, y, scoring = 'neg_mean_absolute_error').mean()predictors_without_categoricals = train_predictors.select_dtypes(exclude=['object'])mae_without_categoricals = get_mae(predictors_without_categoricals, target)mae_one_hot_encoded = get_mae(one_hot_encoded_training_predictors, target)print('Mean Absolute Error when Dropping Categoricals: ' + str(int(mae_without_categoricals)))print('Mean Abslute Error with One-Hot Encoding: ' + str(int(mae_one_hot_encoded)))############## 多个文件join ##############one_hot_encoded_training_predictors = pd.get_dummies(train_predictors)one_hot_encoded_test_predictors = pd.get_dummies(test_predictors)final_train, final_test = one_hot_encoded_training_predictors.align(one_hot_encoded_test_predictors, join='left', axis=1) 2.3、选择模型1234567891011121314151617181920212223242526272829303132333435363738############## 决策树回归 ##############from sklearn.tree import DecisionTreeRegressor# Define modelmelbourne_model = DecisionTreeRegressor()# Fit modelmelbourne_model.fit(X, y)print("Making predictions for the following 5 houses:")print(X.head())print("The predictions are")print(melbourne_model.predict(X.head()))############## 随机森林 ##############from sklearn.ensemble import RandomForestRegressorfrom sklearn.metrics import mean_absolute_errorforest_model = RandomForestRegressor()forest_model.fit(train_X, train_y)melb_preds = forest_model.predict(val_X)print(mean_absolute_error(val_y, melb_preds))############## XGBoost ##############from xgboost import XGBRegressormy_model = XGBRegressor()# Add silent=True to avoid printing out updates with each cyclemy_model.fit(train_X, train_y, verbose=False)############## PipeLines ##############from sklearn.ensemble import RandomForestRegressorfrom sklearn.pipeline import make_pipelinefrom sklearn.preprocessing import Imputermy_pipeline = make_pipeline(Imputer(), RandomForestRegressor())my_pipeline.fit(train_X, train_y)predictions = my_pipeline.predict(test_X) 2.4、验证模型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768############## 模型在测试集上的误差 ##############from sklearn.model_selection import train_test_split# split data into training and validation data, for both predictors and target# The split is based on a random number generator. Supplying a numeric value to# the random_state argument guarantees we get the same split every time we# run this script.train_X, val_X, train_y, val_y = train_test_split(X, y,random_state = 0)# Define modelmelbourne_model = DecisionTreeRegressor()# Fit modelmelbourne_model.fit(train_X, train_y)# get predicted prices on validation dataval_predictions = melbourne_model.predict(val_X)print(mean_absolute_error(val_y, val_predictions))############## 绘制不同个数叶子节点的误差 ##############from sklearn.metrics import mean_absolute_errorfrom sklearn.tree import DecisionTreeRegressordef get_mae(max_leaf_nodes, predictors_train, predictors_val, targ_train, targ_val): model = DecisionTreeRegressor(max_leaf_nodes=max_leaf_nodes, random_state=0) model.fit(predictors_train, targ_train) preds_val = model.predict(predictors_val) mae = mean_absolute_error(targ_val, preds_val) return(mae) # Data Loading Code Runs At This Pointimport pandas as pd # Load datamelbourne_file_path = '../input/melbourne-housing-snapshot/melb_data.csv'melbourne_data = pd.read_csv(melbourne_file_path) # Filter rows with missing valuesfiltered_melbourne_data = melbourne_data.dropna(axis=0)# Choose target and predictorsy = filtered_melbourne_data.Pricemelbourne_predictors = ['Rooms', 'Bathroom', 'Landsize', 'BuildingArea', 'YearBuilt', 'Lattitude', 'Longtitude']X = filtered_melbourne_data[melbourne_predictors]from sklearn.model_selection import train_test_split# split data into training and validation data, for both predictors and targettrain_X, val_X, train_y, val_y = train_test_split(X, y,random_state = 0)# compare MAE with differing values of max_leaf_nodesplot_x = []plot_y = []for max_leaf_nodes in np.arange(10,1000,5): my_mae = get_mae(max_leaf_nodes, train_X, test_X, train_y, test_y) print("Max leaf nodes: %d \t\t Mean Absolute Error: %d" %(max_leaf_nodes, my_mae)) plot_x.append(max_leaf_nodes) plot_y.append(my_mae)plt.plot(plot_x, plot_y)print("index:%f,nodes:%f"%(plot_y.index(min(plot_y)),plot_x[plot_y.index(min(plot_y))]))plt.show()############## Cross Validation ##############from sklearn.ensemble import RandomForestRegressorfrom sklearn.pipeline import make_pipelinefrom sklearn.preprocessing import Imputermy_pipeline = make_pipeline(Imputer(), RandomForestRegressor())from sklearn.model_selection import cross_val_scorescores = cross_val_score(my_pipeline, X, y, scoring='neg_mean_absolute_error')print('Mean Absolute Error %2f' %(-1 * scores.mean())) 3、总结机器学习是一种数据处理的科学，采用科学的分析方式调整模型的参数，试验的数据，达到提高识别率的目的。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DigitRecognizer]]></title>
    <url>%2F2018%2F06%2F12%2FDigitRecognizer%2F</url>
    <content type="text"><![CDATA[0、概述本篇主要记录本人在Kaggle的Digit Recognizer比赛中学习和用到的知识。 1、介绍 首先介绍一下数字识别(Digit Recognizer)，数字识别堪称机器学习领域的&quot;Hello World&quot;，几乎可以说是每个学习机器学习的入门指南。不过，这个入门还是有门槛的，不像 学习编程语言的&quot;Hello World&quot;，如果一开始就一头扎进来，可能会摸不着头脑。 一开始接触机器学习的是看到有朋友圈里有人发TensorFlow相关的东西，于是在0基础 的情况下，配置TensorFlow环境，模仿TensorFlow的例子开始了Digit Recognizer的 实践，发现做下来不知道自己在做什么，例子的每一步不知道是在干什么，一头雾水。 后来看了一位朋友的博客，分享的是他本人学习机器学习的心路历程，以及一些推荐的公 开课和书籍，撸完Coursera上吴恩达的视频后对机器学习有了初步认识，接着撸了李宏毅的 台大课程，感觉思路豁然开朗，顿时理解了吴恩达讲解的很多内容，毕竟是国语嘛，学起来就 是快。最近开始撸线代和概率论，但是总觉得缺点什么，想想大概是缺少实践吧。 寻找实践的突破口，发现项目中出现的Bug分配到各个担当是个费时费力的工作，如果能 够通过Bug描述自动分类那不就可以节省大量人力成本了嘛。于是说干就干，撸起膀子加油 干。文章分类很快想到了吴恩达老师讲的垃圾邮件分类问题，果断朴素贝叶斯算法。中文与英 文不一样，英文通过空格可以分词，中文就没有那么简单了，于是调研了一下，发现github 上有个很好的中文分分词库jieba。试了用一个项目的数据训练后去测试另一个项目的数据， 准确率也就在50%左右，这样的准确率是无法忍受的，至少在90%以上的准确率才能当做产品 使用吧。这个时候体会到了吴恩达老师的那句话，其实到最后机器学习工作者不是去实现什么 牛逼的算法，因为已经有一大批专门研究算法的人每天从事着这样的工作，用实现好的算法库 比自己实现的效率高，性能好。机器学习工作者主要的工作是：选择数据，选择模型，优化数 据，优化配置，提高准确率。 于是参加了Kaggle比赛，学习各路大神是如何玩转机器学习的。说了这么多，回到我们 的主题Digit Recognizer，分类的方法很多，我们将一一道来。 2、实现2.1、SVM 实现数字识别(scikit-learn)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import pandas as pdimport matplotlib.pyplot as pltfrom sklearn.model_selection import train_test_splitfrom sklearn import svm,metrics# 将图片数据可视化def showImgByRow(row,num=1): ''' show pixel :param row:pixel row np.array :return: null ''' picture = row.reshape((num*28,28)) plt.imshow(picture,cmap='gray') plt.axis('off') plt.show()# 读取训练数据trainFile = r'digit-recognizer/train.csv'trainDF = pd.read_csv(trainFile)# 为了save your life，我们只取前500组数据。其实这样做是可能有问题的，# 如果数据不是随机分布的，前5000个数据都是某个数字，那就game over了# 所以无论做何种预测，最好打印出所有的数据分布。images = trainDF.iloc[0:5000,1:]labels = trainDF.iloc[0:5000,:1]train_images, test_images,train_labels, test_labels = train_test_split(images, labels, train_size=0.8, random_state=0)# 处理输入数据X = train_imagesy = train_labels.values.ravel()# regularization 正规化，归一化# 对于数字识别来说，像素点的为0与非0是完全不同的意义，# 如果取0~255，可能会让算法过渡关注数字的大小，导致识别率的下降X[X&gt;0] = 1 #X/=255# 创建分类器clf = svm.SVC(decision_function_shape='ovr',C = 7,gamma = 0.009)# 喂数据clf.fit(X, y)# 处理测试数据test_images[test_images&gt;0] = 1 #test_images/=255# 预测数据predicted = clf.predict(test_images)expected = test_labels#准确率print(clf.score(test_images,test_labels))print("Classification report for classifier %s:\n%s\n" % (clf, metrics.classification_report(expected, predicted)))print("Confusion matrix:\n%s" % metrics.confusion_matrix(y, y)) 2.2、MLP（DNN）实现数字识别(scikit-learn)1234from sklearn.neural_network import MLPClassifierclf = MLPClassifier(hidden_layer_sizes=(50,), max_iter=10, alpha=1e-4, solver='sgd', verbose=10, tol=1e-4, random_state=1, learning_rate_init=.1) 2.3、DNN实现数字识别(keras)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import pandas as pdimport matplotlib.pyplot as pltfrom sklearn.model_selection import train_test_splitfrom keras.models import Sequentialfrom keras.layers import Dense,Activationfrom keras.utils import to_categorical# 读取训练数据trainFile = r'digit-recognizer/train.csv'trainDF = pd.read_csv(trainFile)# 为了save your life，我们只取前500组数据。其实这样做是可能有问题的，# 如果数据不是随机分布的，前5000个数据都是某个数字，那就game over了# 所以无论做何种预测，最好打印出所有的数据分布。images = trainDF.iloc[0:,1:]labels = trainDF.iloc[0:,:1]train_images, test_images,train_labels, test_labels = train_test_split(images, labels, train_size=0.9, random_state=0)# 处理输入数据X = imagesy = labels.values.ravel()# regularization 正规化，归一化# 对于数字识别来说，像素点的为0与非0是完全不同的意义，# 如果取0~255，可能会让算法过渡关注数字的大小，导致识别率的下降X/=255 #X[X&gt;0] = 1# 创建分类器clf = Sequential()clf.add(Dense(output_dim=64,input_dim=784))clf.add(Activation("relu"))clf.add(Dense(output_dim=10))clf.add(Activation("softmax"))clf.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=['accuracy'])# Convert labels to categorical one-hot encodingone_hot_labels = to_categorical(y, num_classes=10)# Train the model, iterating on the data in batches of 32 samples# 喂数据clf.fit(X, one_hot_labels, epochs=10, batch_size=32)# 处理测试数据test_images/=255 #test_images[test_images&gt;0] = 1# evaluate数据expected = test_labelsone_hot_test_labels = to_categorical(expected, num_classes=10)score = clf.evaluate(test_images, one_hot_test_labels)print(score) 2.4、CNN实现数字识别(keras)参考李宏毅老师的教学视频，自己实现的卷积神经网络12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.model_selection import train_test_splitfrom keras.models import Sequentialfrom keras.layers.core import Dense,Activationfrom keras.layers import MaxPooling2D,Convolution2D,Flattenfrom keras.utils.np_utils import to_categorical# 读取训练数据trainFile = r'digit-recognizer/train.csv'trainDF = pd.read_csv(trainFile)# 为了save your life，我们只取前500组数据。其实这样做是可能有问题的，# 如果数据不是随机分布的，前5000个数据都是某个数字，那就game over了# 所以无论做何种预测，最好打印出所有的数据分布。images = trainDF.iloc[0:5000,1:]labels = trainDF.iloc[0:5000,:1]train_images, test_images,train_labels, test_labels = train_test_split(images, labels, train_size=0.8, random_state=5)# 处理输入数据X = train_images.valuesy = train_labels.values.ravel()# regularization 正规化，归一化# 对于数字识别来说，像素点的为0与非0是完全不同的意义，# 如果取0~255，可能X会让算法过渡关注数字的大小，导致识别率的下降# 此处采用正规化处理，减去平局值，除以标准差mean_px = X.mean().astype(np.float32)std_px = X.std().astype(np.float32)def standardize(x): return (x-mean_px)/std_pxX = standardize(X)# 创建模型model = Sequential()# 25个filter，每个大小是3*3.这样会得到25张图片，去掉边角图片变成26*26model.add(Convolution2D(25,3,3,input_shape=(28,28,1)))# 用2*2的框去取最大值。13*13*25model.add(MaxPooling2D((2,2)))# 越接近Output Filter越多，图包含的信息越多。11*11*50model.add(Convolution2D(50,3,3))# 用2*2的框去取最大值。5*5*50. 比如：去掉一半的像素点，不会改变原图像。model.add(MaxPooling2D((2,2)))# 将图像拉直成1Dmodel.add(Flatten())# 以上是卷积过程，下面是DNN。100个neuron全连接model.add(Dense(output_dim=100))model.add(Activation('relu'))model.add(Dense(output_dim=10))model.add(Activation('softmax'))model.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=['accuracy'])# Convert labels to categorical one-hot encodingone_hot_labels = to_categorical(y, num_classes=10)# Train the model, iterating on the data in batches of 32 samples# 喂数据model.fit(X.reshape(X.shape[0],28,28,1), one_hot_labels, epochs=30, batch_size=64)# 处理测试数据test_images = test_images.valuestest_images = standardize(test_images)# valuationexpected = test_labelsone_hot_test_labels = to_categorical(expected, num_classes=10)score = model.evaluate(test_images.reshape(test_images.shape[0],28,28,1), one_hot_test_labels)print(score) Kaggle上Digit_Recognizer 的Kernel中评分最高的实现，主要的改善有： Dropout 随机丢掉若干神经元 ReduceLROnPlateau当算法在最低点徘徊时，降低LR ImageDataGenerator手动创建更多的学习样本。★关键 分别在训练和测试集上绘制loss和accuracy，观察算法的学习情况。★调整学习方法的依据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport matplotlib.image as mpimgimport seaborn as snsnp.random.seed(2)from sklearn.model_selection import train_test_splitfrom sklearn.metrics import confusion_matriximport itertoolsfrom keras.utils.np_utils import to_categorical # convert to one-hot-encodingfrom keras.models import Sequentialfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2Dfrom keras.optimizers import RMSpropfrom keras.preprocessing.image import ImageDataGeneratorfrom keras.callbacks import ReduceLROnPlateausns.set(style='white', context='notebook', palette='deep')# Load the datatrain = pd.read_csv(r"digit-recognizer/train.csv")test = pd.read_csv(r"digit-recognizer/test.csv")Y_train = train["label"]# Drop 'label' columnX_train = train.drop(labels = ["label"],axis = 1)# free some spacedel train# g = sns.countplot(Y_train)Y_train.value_counts()# plt.show()# Check the dataprint(X_train.isnull().any().describe())print(test.isnull().any().describe())# Normalize the dataX_train = X_train / 255.0test = test / 255.0# Reshape image in 3 dimensions (height = 28px, width = 28px , canal = 1)X_train = X_train.values.reshape(-1,28,28,1)test = test.values.reshape(-1,28,28,1)# Encode labels to one hot vectors (ex : 2 -&gt; [0,0,1,0,0,0,0,0,0,0])Y_train = to_categorical(Y_train, num_classes = 10)# Set the random seedrandom_seed = 2# Split the train and the validation set for the fittingX_train, X_val, Y_train, Y_val = train_test_split(X_train, Y_train, test_size = 0.1, random_state=random_seed)# Some examples# g = plt.imshow(X_train[0][:,:,0])## plt.show()# Set the CNN model# my CNN architechture is In -&gt; [[Conv2D-&gt;relu]*2 -&gt; MaxPool2D -&gt; Dropout]*2 -&gt; Flatten -&gt; Dense -&gt; Dropout -&gt; Outmodel = Sequential()model.add(Conv2D(filters = 32, kernel_size = (5,5),padding = 'Same', activation ='relu', input_shape = (28,28,1)))model.add(Conv2D(filters = 32, kernel_size = (5,5),padding = 'Same', activation ='relu'))model.add(MaxPool2D(pool_size=(2,2)))model.add(Dropout(0.25))model.add(Conv2D(filters = 64, kernel_size = (3,3),padding = 'Same', activation ='relu'))model.add(Conv2D(filters = 64, kernel_size = (3,3),padding = 'Same', activation ='relu'))model.add(MaxPool2D(pool_size=(2,2), strides=(2,2)))model.add(Dropout(0.25))model.add(Flatten())model.add(Dense(256, activation = "relu"))model.add(Dropout(0.5))model.add(Dense(10, activation = "softmax"))# Define the optimizeroptimizer = RMSprop(lr=0.001, rho=0.9, epsilon=1e-08, decay=0.0)# Compile the modelmodel.compile(optimizer = optimizer , loss = "categorical_crossentropy", metrics=["accuracy"])# Set a learning rate annealerlearning_rate_reduction = ReduceLROnPlateau(monitor='val_acc', patience=3, verbose=1, factor=0.5, min_lr=0.00001)epochs = 1 # Turn epochs to 30 to get 0.9967 accuracybatch_size = 64# With data augmentation to prevent overfitting (accuracy 0.99286)datagen = ImageDataGenerator( featurewise_center=False, # set input mean to 0 over the dataset samplewise_center=False, # set each sample mean to 0 featurewise_std_normalization=False, # divide inputs by std of the dataset samplewise_std_normalization=False, # divide each input by its std zca_whitening=False, # apply ZCA whitening rotation_range=10, # randomly rotate images in the range (degrees, 0 to 180) zoom_range = 0.1, # Randomly zoom image width_shift_range=0.1, # randomly shift images horizontally (fraction of total width) height_shift_range=0.1, # randomly shift images vertically (fraction of total height) horizontal_flip=False, # randomly flip images vertical_flip=False) # randomly flip imagesdatagen.fit(X_train)# Fit the modelhistory = model.fit_generator(datagen.flow(X_train,Y_train, batch_size=batch_size), epochs = epochs, validation_data = (X_val,Y_val), verbose = 2, steps_per_epoch=X_train.shape[0] // batch_size , callbacks=[learning_rate_reduction])# Plot the loss and accuracy curves for training and validationfig, ax = plt.subplots(2,1)ax[0].plot(history.history['loss'], color='b', label="Training loss")ax[0].plot(history.history['val_loss'], color='r', label="validation loss",axes =ax[0])legend = ax[0].legend(loc='best', shadow=True)ax[1].plot(history.history['acc'], color='b', label="Training accuracy")ax[1].plot(history.history['val_acc'], color='r',label="Validation accuracy")legend = ax[1].legend(loc='best', shadow=True)# Plot the confusion_matrix# confusion_mtx = confusion_matrix(expected, predicted)# df_cm = pd.DataFrame(confusion_mtx, index = [i for i in range(0,10)], columns = [i for i in range(0,10)])# plt.figure(figsize = (6,5))# conf_mat = sns.heatmap(df_cm, annot=True, cmap='Blues', fmt='g', cbar = False)# conf_mat.set(xlabel='Predicts', ylabel='True')# plt.show() 2.5、kNN实现数字识别此处不再赘述，请参考前文：https://xuleilx.github.io/2018/04/12/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/ 3、总结机器学习把复杂的数字识别问题的变成了简单的分类问题。通过本文可以发现同一个问题可以 由不同的算法解决。本文主要用的是SVM、DNN、CNN、kNN四种算法，分别采用刚刚接触的 Scikit-learn和Keras实现。这里尤其要说明一点的是，神经网络将传统机器学习的函数模 型选择问题变成了搭建神经网络结构的问题。通过对loss和accuracy在样本集和测试集上的 表现权衡bias和variance，成功图像识别问题变成了数据分析问题。这大概就是机器学习的 魅力所在，将无形变成有形。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logistic回归]]></title>
    <url>%2F2018%2F05%2F29%2FLogistic%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[0、概述0.1、回归的含义 高尔顿（Frramcia Galton,1882-1911）早年在剑桥大学学习医学，但医生的职业对 他并无吸引力，后来他接受了一笔遗产，这使他可以放弃医生的生涯，并与 1850－1852年期 间去非洲考察，他所取得的成就使其在1853年获得英国皇家地理学会的金质奖章。此后他研究 过多种学科（气象学、心理学、社会学、 教育学和指纹学等），在1865年后他的主要兴趣转 向遗传学，这也许是受他表兄达尔文的影响。 从19世纪80年代高尔顿就开始思考父代和子代相似，如身高、性格及其它种种特制的相似 性问题。于是他选择了父母平均身高X与其一子身高Y的关系作为研究对象。他观察了1074对 父母及每对父母的一个儿子，将结果描成散点图，发现趋势近乎一条直 线。总的来说是父母 平均身高X增加时，其子的身高Y也倾向于增加，这是意料中的结果。但有意思的是高尔顿发现 这1074对父母平均身高的平均值为68 英寸（英国计量单位，1 英寸=2.54cm）时，1074个 儿子的平均身高为69 英寸，比父母平均身高大1 英寸 ，于是他推想，当父母平均身高为64 英寸时，1074个儿子的平均身高应为64+1=65 英寸；若父母的身高为72 英寸时，他们儿子 的平均身高应为72=1=73 英寸，但观察结果确与此不符。高尔顿发现前一种情况是儿子的平 均身高为67 英寸，高于父母平均值达3 英寸，后者儿子的平均身高为71英寸，比父母的平均 身高低1 英寸。 高尔顿对此研究后得出的解释是自然界有一种约束力，使人类身高在一定时期是相对稳定 的。如果父 母身高（或矮了），其子女比他们更高（矮），则人类身材将向高、矮两个极端 分化。自然界不这样做，它让身高有一种回归到中心的作用。例如，父母平均身高 72 英寸， 这超过了平均值68英寸，表明这些父母属于高的一类，其儿子也倾向属于高的一类（其平均身 高71 英寸 大于子代69 英寸），但不像父母离子代那么远（71-69&lt;72-68）。反之，父母 平均身高64 英寸，属于矮的一类，其儿子也倾向属于矮的一类（其平均67 英寸，小于子代 的平均数69 英寸），但不像父母离中心那么远（69 -67&lt; 68-64）。 因此，身高有回归于中心的趋势，由于这个性质，高尔顿就把“回归”这个词引进到问题 的讨论中，这就是“回归”名称的由来，逐渐背后人沿用成习了。 0.2、线性回归线性回归实际上就是找到一条直线 $$y = W^{T}x + b$$ ，使得该直线尽可能的拟合样本数据。 0.3、Logistic回归Logistic回归其实不是线性回归求预测值的问题，而是二分类问题。首先我们的线性回归模型输出的预测值，连续的数值，我们想用它解决分类问题，就需要让连续的数值转换到0/1就可以了,这里引入一个新的函数sigmoid $$y=\frac{1}{1+e^{-z}}$$ 函数，其中 $$z = W^{T}x + b$$ 。图像是这样的： 0.4、Softmax回归In mathematics, the softmax function, or normalized exponential function,[1]:198 is ageneralization of the logistic function that “squashes” a K-dimensional vector $$\mathbf {z}$$ ofarbitrary real values to a K-dimensional vector $$\sigma (\mathbf {z} )$$ of real values, where eachentry is in the range (0, 1), and all the entries adds up to 1. The function is given by$${\displaystyle \sigma :\mathbb {R} ^{K}\to \left{\sigma \in \mathbb {R} ^{K}|\sigma {i}&gt;0,\sum {i=1}^{K}\sigma {i}=1\right}}$$$$\sigma (\mathbf {z} ){j}={\frac {e^{z{j}}}{\sum {k=1}^{K}e^{z{k}}}} for j = 1, …, K.$$举个栗子：假设模型的输入样本是I，讨论一个3分类问题（类别用1，2，3表示），样本I的真实类别是2，那么这个样本I经过网络所有层到达 softmax 层之前就得到了 $$W^{T}x$$，也就是说 $$W^{T}x$$ 是一个3 * 1的向量，那么上面公式中的 $$a{j}$$ 就表示这个3 1的向量中的第 j 个值; 而分母中的 $$a_{k}$$ 则表示3 1的向量中的3个值，所以会有个求和符号。 因为 $$e^{x}$$ 恒大于0，所以分子永远是正数，分母又是多个正数的和，所以分母也肯定是正数，因此 $$\sigma (\mathbf {z} )_{j}$$ 是正数，而且范围是(0,1)。如果现在不是在训练模型，而是在测试模型，那么当一个样本经过 softmax 层并输出一个K * 1的向量时，就会取这个向量中值最大的那个数的index作为这个样本的预测标签。 总结一下：sigmoid将一个real value映射到（0,1）的区间（当然也可以是（-1,1）），这样可以用来做二分类。softmax把一个k维的real value向量（a1,a2,a3,a4….）映射成一个（b1,b2,b3,b4….）其中bi是一个0-1的常数，然后可以根据bi的大小来进行多分类的任务，如取权重最大的一维。 1、介绍1.1、工作原理1.2、优点，缺点，适用范围优点：计算代价不高，易于理解和实现。 缺点：容易欠拟合，分类精度可能不高。 适用范围：标称型数据，标称型数据。 1.3、一般流程收集数据：可以使用任何方法。 准备数据：由于需要进行距离计算，因此要求数据类型为数值型。另外，结构化数据格式则最佳。 分析数据：采用任意方法对数据进行分析。 训练算法：大部分时间用于训练，训练的目的是为了找到最佳的分类回归系数。 测试算法：一旦训练步骤完成，分类将会很快。 使用算法：首先，我们需要输入一些数据，并将其装换成对应的结构化数字；接着基于训练好的回归系数就可以对这些数据进行简单的回归计算，判定它们属于哪个类别；在此之后，我们就可以在输出的类别上做一些其他分析工作。 2、实现2.1、梯度下降梯度：对于可微的数量场f(x,y,z)，以 $$\left ( \partial f /\partial x, \partial f /\partial y, \partial f /\partial z\right )$$ 为分量的向量场称为f的梯度或斜量。梯度下降法(gradient descent)是一个最优化算法，常用于机器学习和人工智能当中用来递归性地逼近最小偏差模型。 对于只含有一组数据的训练样本，我们可以得到更新weights的规则为：$$\theta {j} := \theta {j} + \alpha ( y^{i} - h{\theta }(x^{i}))x{j}^{(i)}$$扩展到多组数据样本，更新公式为：Repeat until convergence {$$\theta {j} := \theta {j} + \alpha \sum{i=1}^{m} ( y^{i} - h{\theta }(x^{i}))x{j}^{(i)} (for every j)$$}称为批处理梯度下降算法，这种更新算法所需要的运算成本很高，尤其是数据量较大时。考虑下面的更新算法：Loop { for i=1 to m,{$$\theta {j} := \theta {j} + \alpha ( y^{i} - h{\theta }(x^{i}))x_{j}^{(i)} (for every j)$$​ }}该算法又叫做随机梯度下降法，这种算法不停的更新weights，每次使用一个样本数据进行更新。当数据量较大时，一般使用后者算法进行更新。 2.2、伪代码123456#随机梯度上升算法可以写成如下的伪代码：所有回归系数初始化为1对数据集中每个样本 计算该样本的梯度 使用alpha * gradient更新回归系数返回回归系数 2.3、python实现1234567891011121314151617181920212223242526272829303132333435363738# 梯度上升算法def gradAscent(dataMatIn,classLabels): ''' :param dataMatIn: 输入数据 :param classLabels: 每行数据对应的标签 :return: ''' dataMatrix = mat(dataMatIn) labelMat = mat(classLabels).transpose() # m*n 矩阵 m,n = shape(dataMatrix) alpha = 0.001 maxCycles = 500 # n所有的Feature，都有weight weights = ones((n,1)) for k in range(maxCycles): h = sigmoid(dataMatrix*weights) # 计算实际值与预测值之间的差值 error = (labelMat - h) # 梯度上升，对sigmoid函数一阶偏导 weights = weights + alpha*dataMatrix.transpose()*error return weights# 随机梯度上升算法def stocGradAscent1(dataMatrix, classLabels, numIter=150): m,n = shape(dataMatrix) weights = ones(n) #initialize to all ones for j in range(numIter): dataIndex = list(range(m)) for i in range(m): alpha = 4/(1.0+j+i)+0.0001 #apha decreases with iteration randIndex = int(random.uniform(0,len(dataIndex)))#Does not go to 0 because of the constant h = sigmoid(sum(dataMatrix[randIndex]*weights)) error = classLabels[randIndex] - h # 梯度下降是预测值-实际值，h - y weights = weights + alpha * error * float64(dataMatrix[randIndex]) del(dataIndex[randIndex]) return weights 3、总结本算法接触到了机器学习的一个核心算法，梯度下降(上升)算法，改算法贯穿机器学习的各种算法，使用该算法可以快速求得最小偏差，得到我们建模的参数(w,b)。Logistic回归(逻辑回归)是个分类问题，使用微分知识对函数sigmoid $$y=\frac{1}{1+e^{-z}}$$ 求偏微分，不需要直接求导，而是用偏微分计算。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素贝叶斯]]></title>
    <url>%2F2018%2F05%2F06%2F%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%2F</url>
    <content type="text"><![CDATA[0、概述朴素贝叶斯是贝叶斯理论的一部分，所以讲述这部分内容之前首先需要了解一下贝叶斯定理。 贝叶斯定理是关于随机事件A和B的条件概率（或边缘概率）的一则定理。其中P(A|B)是在B发 生的情况下A发生的可能性。 描述两个条件概率之间的关系，比如 P(A|B) 和 P(B|A)。 按照乘法法则，可以立刻导出： P(A∩B) = P(A)*P(B|A) = P(B)*P(A|B) 如上公式也可变形为： P(B|A) = P(A|B)*P(B)/P(A) 朴素贝叶斯分类器基于一个简单的假定：给定目标值时属性之间相互条件独立。 1、介绍1.1、工作原理假设每个特征对于决定样本属于哪一类都同等重要。给定一个测试样本w，计算它属于c的概 率，只需要计算出训练样本中类别c的每个特征类型的概率p(w|c)，所有训练样本中类别c的 概率p(c)，测试样本w的概率(实际使用中比较样本w属于哪个类别的可能性更大，等号两边相等) p(c|w) = p(w|c)p(c)/p(w) 1.2、优点，缺点，适用范围优点：在数据较少的情况下仍然有效，可以处理多类别问题。 缺点：对于输入数据的准备方式较为敏感。 适用范围：标称型数据。 1.3、一般流程收集数据：可以使用任何方法。 准备数据：需要数值型或者布尔型数据。 分析数据：有大量特征时，绘制特征作用不大，此时使用直方图效果更好。 训练算法：计算不同的独立特征的条件概率。 测试算法：计算错误率。 使用算法：常用于文档分类。可以在任意的分类场景中使用朴素贝叶斯分类器，不一定非要是文本。 2、实现2.1、伪代码123456789计算每个类别中的文档数目对每篇训练文档： 对每个类别： 如果词条出现文档中 -&gt; 增加该词条的计数值 增加所有词条的计数值 对每个类别： 对每个词条： 将该词条的数目数除以总词条数目得到条件概率 返回每个类别的条件概率 2.2、python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172def createVocabList(dataSet): vocabSet = set([]) for document in dataSet: vocabSet = vocabSet | set(document) return list(vocabSet)def setOfWords2Vec(vocabList,inputSet): returnVec = [0]*len(vocabList) for word in inputSet: if word in vocabList: returnVec[vocabList.index(word)] = 1 else: print("the word: %s is no in my Vocabulary!"%word) return returnVecdef bagOfWords2VecMN(vocabList,inputSet): ''' 单个单词出现多次的场景 :param vocabList:单词集合 :param inputSet:输入的句子 :return: ''' returnVec = [0]*len(vocabList) for word in inputSet: if word in vocabList: returnVec[vocabList.index(word)] += 1 else: print("the word: %s is no in my Vocabulary!" % word) return returnVecdef trainNB0(trainMatrix,trainCategory): ''' :param trainMatrix:文档矩阵 :param trainCategory:文档标签向量 :return: ''' # 计算样本数 numTrainDocs = len(trainMatrix) # 计算单词数 numWords = len(trainMatrix[0]) # 计算所有样本中侮辱言论的概率 pAbusive = sum(trainCategory)/float(numTrainDocs) # 避免个别单词不出现，导致计算概率为0，默认都出现一次。 p0Num = ones(numWords);p1Num = ones(numWords) p0Denom = 2.0; p1Denom = 2.0 for i in range(numTrainDocs): # 轮询所有样本 if trainCategory[i] == 1: # 所有侮辱性言论 # 侮辱性言论中，每个单词使用的次数 p1Num += trainMatrix[i] # 侮辱性言论中，所有单词的出现次数 p1Denom += sum(trainMatrix[i]) else: # 所有正常言论 # 正常言论中，每个单词使用的次数 p0Num += trainMatrix[i] # 正常言论中，所有单词的出现次数 p0Denom += sum(trainMatrix[i]) p1Vect = log(p1Num / p1Denom) p0Vect = log(p0Num / p0Denom) return p0Vect,p1Vect,pAbusivedef classifyNB(vec2Classify,p0Vec,p1Vec,pClass1): # p(c1|w) = p(w|c1)p(c1)/p(w) # p(c0|w) = p(w|c0)p(c0)/p(w) # p0Vec,p1Vec已经log过的。此处缺少除以单词本身出现的概率p(w)。p0,p1都需要除以p(w)可约去 p1 = sum(vec2Classify * p1Vec)+log(pClass1) p0 = sum(vec2Classify * p0Vec)+log(1 - pClass1) if p1 &gt; p0: return 1 else: return 0 3、总结巧妙的运用概率的方法解决分类问题，朴素贝叶斯降低了条件概率计算的复杂度，并且正确率很好。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树算法]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0、概述分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点和有向边组成。 结点有两种类型：内部节点和叶节点，内部节点表示一个特征或属性，叶节点表示一个类。 分类的时候，从根节点开始，对实例的某一个特征进行测试，根据测试结果，将实例分配到其子结点； 此时，每一个子结点对应着该特征的一个取值。如此递归向下移动，直至达到叶结点，最后将实例分配到叶结点的类中。 1、介绍1.1、工作原理对训练数据进行建模，决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程。 它可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。 1.2、优点，缺点，适用范围优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据。 缺点：可能会产生过渡匹配问题。 适用范围：数值型和标称型 1.3、一般流程收集数据：可以使用任何方法。 准备数据：树构造算法只适用于标称型数据，因此数值型数据必须离散化。 分析数据：可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期。 训练算法：构造树的数据结构。 测试算法：使用经验树计算错误率。 使用算法：此步骤可以适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。 2、实现2.1、伪代码123456789# 创建分支伪代码函数createBranch()如下所示： if so return 类标签; else 寻找划分数据集的最好特征 划分数据集 创建分支节点 for 每个划分的子集 调用函数createBranch()并增加结果到分支节点中 return 分支节点 2.2、信息增益划分数据集的大原则是：将无序的数据变得更加有序。决策树是通过什么来选择树根，树枝，叶子的呢？这里不得提到两个概念：信息增益和熵。信息增益：在划分数据集之前之后信息发生的变化称为信息增益。熵：集合信息的度量方式称为熵。如果待分类的事务可能分在多个分类之中，则符号x${i}$的信息定义为：$$l(x{i}) = - \log2 p(x{i})$$其中p(x${i}$)是选择该分类的概率。为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，公式如下：$$H = -\sum{i=1}^{n}p(x_{i})\log2 p(x{i})$$ 2.3、python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118def calcShannoEnt(dataSet): ''' 计算给定数据集的香农熵。注意是所有数据的集合，不是单个样本。 1. get last current ShannoEnt :param dataSet:数据集 :return: 计算结果 ''' numEntries = len(dataSet) labelCounts = &#123;&#125; # 遍历每个实例，统计标签的频数 for featVec in dataSet: # 获取单个样本的标签列(样本的最后一列为标签列) currentLabel = featVec[-1] # 为单个分类创建字典 if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 shannonEnt = 0.0 # 计算所有类别所有可能值包含的信息期望值 for key in labelCounts: prob = float(labelCounts[key])/numEntries shannonEnt -= prob*log(prob,2) return shannonEnt def splitDataSet(dataSet,axis,value): ''' 按照给定特征划分数据集。最终获得一个子集。举个栗子： [[1,1,'yes'] [1,1,'yes'] [1,0,'no'] [0,1,'no'] [0,1,'no']] 如果以第二例作为axis，特征值为1，得到下面的子集： [[1,'yes'] [1,'yes'] [0,'no'] [0,'no']] 1. find the value row 2. del the value from the row 3. return all the row as [] :param dataSet:待划分的数据集 :param axis:划分数据集的特征 :param value: 需要split的特征值 :return: 划分结果列表 ''' retDataSet = [] for featVec in dataSet: if featVec[axis] == value: reduceFeatVec = featVec[:axis] reduceFeatVec.extend(featVec[axis+1:]) retDataSet.append(reduceFeatVec) return retDataSet def chooseBestFeatureToSplit(dataSet): ''' 1.每个特征中的每个特征值分类 2.计算划分后的香农熵，找出最大熵 3.得出划分后香农熵最大的特征作为最好的分类特征 :param dataSet:数据集 :return:返回分类最好的特征 ''' numFeatures = len(dataSet[0]) - 1 baseEntropy = calcShannoEnt(dataSet) bestInfoGain = 0.0;bestFeature = -1 for i in range(numFeatures): featList = [example[i] for example in dataSet] uniqueVals = set(featList) newEntropy = 0.0 for value in uniqueVals: subDataSet = splitDataSet(dataSet,i,value) prob = len(subDataSet)/float(len(dataSet)) newEntropy += prob*calcShannoEnt(subDataSet) infoGain = baseEntropy - newEntropy if(infoGain &gt; bestInfoGain): bestInfoGain = infoGain bestFeature = i return bestFeature def majorityCnt(classList): ''' 采用多数表决的方法决定叶结点的分类 :param: 所有的 类标签 列表 :return: 出现次数最多的类 ''' classCount=&#123;&#125; for vote in classList: # 统计所有类标签的频数 if vote not in classCount.keys(): classCount[vote]=0 classCount[vote] += 1 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1),reverse=True) return sortedClassCount[0][0] def createTree(dataSet,labels): ''' 创建决策树 :param: dataSet:训练数据集 :return: labels:所有的类标签 ''' classList = [example[-1] for example in dataSet] # 所有的标签都相同，直接返回该标签 if classList.count(classList[0]) == len(classList): return classList[0] # 遍历完所有特征，仍不能把数据划分为仅包含唯一类别的分组，返回出现次数最多的 if len(dataSet[0]) == 1: return majorityCnt(classList) # 找到最好的Feature，函数名称感觉有点问题，跟ToSplit没有关系 bestFeat = chooseBestFeatureToSplit(dataSet) # 找到对应的标签 bestFeatLabel = labels[bestFeat] # 将当前最好的Feature放到决策树 myTree = &#123;bestFeatLabel:&#123;&#125;&#125; del(labels[bestFeat]) featValues = [example[bestFeat] for example in dataSet] uniqueVals = set(featValues) # 一个Feature里面有多个值，按不同的值进行构建树的分支 for value in uniqueVals: subLabels = labels[:] myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet,bestFeat,value),subLabels) return myTree 3、总结决策树算法稍微有点复杂，后面还会涉及到剪枝。目前只接触到二叉树，也就是说一个特征值 要么是，要么否，不知道支不支持多分支，看算应该是支持多分支的，有待继续学习。深刻感 觉到理论的重要性，香农熵的概念是这个算法的核心，如果没有选择最优特征值的算法，无法 确定最优二叉树。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k-近邻算法]]></title>
    <url>%2F2018%2F04%2F12%2Fk-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0、概述 1、介绍 1.1、工作原理 1.2、优点，缺点，适用范围 1.3、一般流程 2、实现 2.1、伪代码 2.2、python实现 3、总结 0、概述简单的说，k-近邻算法是一种分类算法，采用测量测试用例与样本用例不同特征值之间的距离，选取距离最小的样本所属的分类作为测试用例的分类。 1、介绍1.1、工作原理工作原理：存在一个样本数据集，也称作训练样本集，并且样本集中每个数据都存在标签，即我们都知道样本集中每个数据与所属分类的对应关系。 输入没有标签的新数据后，将新数据的每个特征与样本集中的数据对应的特征比较，然后算法提取样本集中特征最相似数据(最近邻)的分类标签。 一般来说，我们只选择样本数据集中前K个最相似的数据，这就是k-近邻算法中的k的出处，通常k是不大于20的整数。 最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类 1.2、优点，缺点，适用范围优点：精度高、对异常值不敏感、无数据输入假定。 缺点：计算复杂度高、空间复杂度高。（每个测试用例都要计算与所有样本用例的每个特征值的距离） 适用范围：数值型和标称型 1.3、一般流程收集数据：可以使用任何方法。 准备数据：距离计算所需要的数值，最好是结构化的数据格式。 分析数据：可以使用任何方法。 训练算法：N/A 测试算法：计算错误率。 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类， 最后应用对计算出的分类执行后续的处理。 2、实现2.1、伪代码N/A 2.2、python实现12345678910111213141516171819202122232425262728293031323334from numpy import *import operatorfrom os import listdirdef classify0(inX, dataSet, labels, k): ''' kNN: k Nearest Neighbors Input: inX: vector to compare to existing dataset (1xN) dataSet: size m data set of known vectors (NxM) labels: data set labels (1xM vector) k: number of neighbors to use for comparison (should be an odd number) Output: the most popular class label ''' # 获取样本数，即M dataSetSize = dataSet.shape[0] # 将单个样本拉成M行矩阵，矩阵相减，得到测试用例特征值与每个样本用例的特征值的差 diffMat = tile(inX, (dataSetSize,1)) - dataSet # 特征值差的平方。此处是array sqDiffMat = diffMat**2 # 每个样本所有特征值差和 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 # 排序，按照数组所在的编号输出 sortedDistIndicies = distances.argsort() classCount=&#123;&#125; for i in range(k): # 获取前k个的标签 voteIlabel = labels[sortedDistIndicies[i]] # 计算相同标签数 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 # 按照标签个数排序 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] 3、总结k-近邻算法是分类数据最简单最有效的算法。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习15之Animation动画]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A015%E4%B9%8BAnimation%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npfrom matplotlib import animationfig,ax = plt.subplots()# 数据是一个0~2π内的正弦曲线x = np.arange(0,2*np.pi,0.1)y= np.sin(x)line, = ax.plot(x,y)# 采用np.pi*i/30 方式更新，更流畅def animate(i): line.set_ydata(np.sin(x+np.pi*i/30)) return line,def init(): line.set_ydata(np.sin(x)) return line,# https://matplotlib.org/api/animation_api.htmlani = animation.FuncAnimation(fig=fig,func=animate,frames=30,init_func=init,blit=True)# https://stackoverflow.com/questions/25140952/matplotlib-save-animation-in-gif-errorani.save('/home/xuleilx/workspace/github/github_pages/public/images/animation.gif', writer='imagemagick', fps=30)plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习14之次坐标轴]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A014%E4%B9%8B%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npx = np.arange(0,10,0.1)y1 = 0.05*x**2y2 = -1*y1# 获取figure默认的坐标系 ax1# fig,ax1 = plt.subplots()ax1 = plt.subplot()# 对ax1调用twinx()方法，生成如同镜面效果后的ax2ax2 = ax1.twinx()ax1.plot(x,y1,'g-')ax2.plot(x,y2,'b--')ax1.set_xlabel('X data')ax1.set_ylabel('Y1',color='g')ax2.set_ylabel('Y2',color='b')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subaxes.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习13之图中图]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A013%E4%B9%8B%E5%9B%BE%E4%B8%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfig = plt.figure()x = [1,2,3,4,5,6,7]y = [1,3,4,2,5,8,6]# 4个值都是占整个figure坐标系的百分比。在这里，假设figure的大小是10x10，# 那么大图就被包含在由(1, 1)开始，宽8，高8的坐标系内。left,bottom,width,height=0.1,0.1,0.8,0.8ax1 = fig.add_axes([left,bottom,width,height])ax1.plot(x,y,'r')ax1.set_xlabel('X')ax1.set_ylabel('Y')ax1.set_title('title')left,bottom,width,height=0.2,0.6,0.25,0.25ax2 = fig.add_axes([left,bottom,width,height])ax2.plot(y,x,'b--')ax2.set_xlabel('X')ax2.set_ylabel('Y')ax2.set_title('title inside 1')# 采用一种更简单方法，即直接往plt里添加新的坐标系left,bottom,width,height=0.6,0.2,0.25,0.25plt.axes([left,bottom,width,height])plt.plot(y[::-1],x,'g-.') # 注意对y进行了逆序处理plt.xlabel('X')plt.ylabel('Y')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/plotinplot.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习12之Subplot多合一显示2]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A012%E4%B9%8BSubplot%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA2%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspec# method 1:subplot2grid#############################plt.figure()ax1 = plt.subplot2grid((3,3),(0,0),colspan=3,rowspan=1)ax1.plot([1,2],[1,2])ax1.set_title('ax1_title')ax2 = plt.subplot2grid((3,3),(1,0),colspan=2)ax3 = plt.subplot2grid((3,3),(1,2),rowspan=2)ax4 = plt.subplot2grid((3,3),(2,0))ax5 = plt.subplot2grid((3,3),(2,1))# method 2:gridspec############################## plt.figure()# gs = gridspec.GridSpec(3,3)# ax1 = plt.subplot(gs[0,:])# ax2 = plt.subplot(gs[1,:2])# ax3 = plt.subplot(gs[1:,2])# ax4 = plt.subplot(gs[2,0])# ax5 = plt.subplot(gs[2,1])# method 3:easy to define structure############################## f,axes = plt.subplots(2,2,sharex=True)# axes[0,0].scatter([1,2],[1,2])plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subplot_method1.png")plt.tight_layout()plt.show() 结果：Method1:Method2:Method3:]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习12之Subplot多合一显示]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A012%E4%B9%8BSubplot%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfig = plt.figure()# 使用plt.subplot(2,1,1)将整个图像窗口分为2行1列, 当前位置为1.# 使用plt.plot([0,1],[0,1])在第1个位置创建一个小图.plt.subplot(211)plt.plot([0,1],[0,1])# 使用plt.subplot(2,3,4)将整个图像窗口分为2行3列, 当前位置为4.# 使用plt.plot([0,1],[0,2])在第4个位置创建一个小图.## 这里需要解释一下为什么第4个位置放第2个小图. 上一步中使用plt.subplot(2,1,1)将整个图像窗口分为2行1列,# 第1个小图占用了第1个位置, 也就是整个第1行. 这一步中使用plt.subplot(2,3,4)将整个图像窗口分为2行3列,# 于是整个图像窗口的第1行就变成了3列, 也就是成了3个位置, 于是第2行的第1个位置是整个图像窗口的第4个位置.plt.subplot(234)plt.plot([0,1],[0,2])plt.subplot(235)plt.plot([0,1],[0,3])plt.subplot(236)plt.plot([0,1],[0,4])plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subplot.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习11之3D图像]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A011%E4%B9%8B3D%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)# X,Y valuex = np.arange(-4,4,0.25)y = np.arange(-4,4,0.25)X,Y = np.meshgrid(x,y)# x-y 平面的网格R = np.sqrt(X**2+Y**2)# height valueZ = np.sin(R)# rstride 和 cstride 分别代表 row 和 column 的跨度ax.plot_surface(X,Y,Z,rstride=1,cstride=1,cmap='rainbow',edgecolor='black')# 添加 XY 平面的等高线ax.contourf(X,Y,Z,zdir='z',offset=-2,cmap='rainbow')ax.set_zlim(-2,2)plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/3d_data.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习9之Image图片]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A010%E4%B9%8BImage%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npa = np.linspace(0,1,9).reshape(3,3)# 三行三列的格子，a代表每一个值，图像右边有一个注释，白色代表值最大的地方，颜色越深值越小。plt.imshow(a,interpolation='nearest',cmap='bone',origin='lower')# 添加一个colorbar ，其中我们添加一个shrink参数，使colorbar的长度变短为原来的92%plt.colorbar(shrink=.92)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/image.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习9Contours等高线图]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A09%E4%B9%8BContours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npdef f(x,y): # the height function return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)n = 256x = np.linspace(-3,3,n)y = np.linspace(-3,3,n)# 编织成栅格X,Y = np.meshgrid(x,y)# use plt.contourf to filling contours# X,Y and value for (X,Y) pointplt.contourf(X,Y,f(X,Y),8,alpha=.75,cmap=plt.cm.hot)C = plt.contour(X,Y,f(X,Y),8,colors='black',linewidth=.5)# 添加label，隐藏坐标轴plt.clabel(C,inline=True,fontsize=10)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/contours.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习8之bar柱状图]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A08%E4%B9%8Bbar%E6%9F%B1%E7%8A%B6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npn = 10X = np.arange(n)# 均匀分布Y1 = (1-X/float(n))*np.random.uniform(0.5,1,n)Y2 = (1-X/float(n))*np.random.uniform(0.5,1,n)plt.bar(X,+Y1,facecolor='#9999ff',edgecolor='white')plt.bar(X,-Y2,facecolor='#ff9999',edgecolor='white')for x,y in zip(X,Y1): # ha: horizontal alignment # va: vertical alignment plt.text(x,y,'%.2f'%y,ha='center',va='bottom')for x,y in zip(X,Y2): plt.text(x,-y,'%.2f'%y,ha='center',va='top')#设置显示范围plt.xlim(-.5,n)plt.ylim(-1.25,1.25)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/bar_map.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习7之散点图]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A07%E4%B9%8B%E6%95%A3%E7%82%B9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npn = 1024# 高斯分布 http://blog.csdn.net/lanchunhui/article/details/50163669X = np.random.normal(0,1,n)Y = np.random.normal(0,1,n)T = np.arctan2(Y,X)# for color valueplt.scatter(X,Y,s=75,c=T,alpha=0.5)#设置显示范围plt.xlim(-1.5,1.5)plt.ylim(-1.5,1.5)# 去坐标plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/dot_map.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习6之tick能见度]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A06%E4%B9%8Btick%E8%83%BD%E8%A7%81%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y = 0.1*xplt.figure(num=1,figsize=(8,5))# 单纯直线plt.plot(x,y,linewidth=10,zorder=1)plt.ylim(-2,2)# gca = 'get current axis'# 移动坐标轴位置ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))# 当坐标轴的数字被遮挡时，调整线的透明度for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.7, zorder=2))plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/tick.png")#显示plt.show()]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习5之标注annotate]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A05%E4%B9%8B%E6%A0%87%E6%B3%A8annotate%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y = 2*x + 1plt.figure(num=1,figsize=(8,5))# 单纯直线plt.plot(x,y)# gca = 'get current axis'# 移动坐标轴位置ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))x0 = 1y0 = 2*x0+1# x:[x0,x0],y:[0,y0] 矩阵运算plt.plot([x0,x0],[0,y0],'k--',linewidth=2.5)# set dot stylesplt.scatter([x0,],[y0,],s=50,color='b')# 添加标注# method1plt.annotate(r'$2x+1=%s$'%y0, xy=(x0,y0), xycoords='data', xytext=(+30,-30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle='-&gt;', connectionstyle='arc3,rad=.2'))# method2plt.text(-1,3, r'$\mu\ \sigma_i\ \alpha_t$', fontdict=&#123;'size':16,'color':'r'&#125;)plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/annotation.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习4之legend]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A04%E4%B9%8Blegend%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])# 单纯直线l1, = plt.plot(x,y2,label='up')# 指定线的颜色, 宽度和类型l2, = plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--',label='bottom')plt.legend(handles=[l1,l2],labels=['aaa','bbb'],loc='best')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/legend.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习3之axis2]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A03%E4%B9%8Baxis2%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 单纯直线plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--')# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])# gca = 'get current axis'ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/axis_2.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习3之axis]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A03%E4%B9%8Baxis%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 单纯直线plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--')# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])#显示plt.show() 输出结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习2之figure]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A02%E4%B9%8Bfigure%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2# figure 3，指定figure的编号并指定figure的大小plt.figure(num=3,figsize=(8,5))plt.plot(x,y1)plt.figure(&quot;f2&quot;)plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color=&apos;red&apos;,linewidth=5.0,linestyle=&apos;--&apos;)#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习1之直线曲线]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A01%E4%B9%8B%E7%9B%B4%E7%BA%BF%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[代码： 1234567891011121314151617# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-1,1,50)#绘制直线y = x + 1plt.plot(x,y)#绘制曲线y = x**2plt.plot(x,y)#显示plt.show() 显示结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow之二次曲线]]></title>
    <url>%2F2017%2F12%2F17%2Ftensorflow%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#coding:utf-8import tensorflow as tfimport numpy as npimport matplotlib.pyplot as plt# 构造添加神经层的函数def add_layer(inputs,in_size,out_size,activation_function=None): # 权重，in_size*out_size随机变量矩阵 Weights = tf.Variable(tf.random_normal([in_size,out_size])) # 偏差，1*out_size数组。 # 在机器学习中，biases的推荐值不为0，这里是在0向量的基础上+0.1 biases = tf.Variable(tf.zeros([1,out_size])+0.1) # y = Weights*x+biases 。 tf.matmul()是矩阵的乘法 Wx_plus_b = tf.matmul(inputs,Weights)+biases # 如果没有定义激励函数就是线性函数 if activation_function is None: outputs = Wx_plus_b else: outputs = activation_function(Wx_plus_b) return outputs# 生成x的值,类似# [[-1. ]# [-0.5]# [ 0. ]# [ 0.5]# [ 1. ]]x_data = np.linspace(-1,1,300)[:,np.newaxis]# 加了一个noise,这样看起来会更像真实情况.类型与x_data一样noise = np.random.normal(0,0.05,x_data.shape)# y = x**2 - 0.5 + noisey_data = np.square(x_data)-0.5+noise# 利用占位符定义我们所需的神经网络的输入。# tf.placeholder()就是代表占位符，这里的None代表无论输入有多少都可以，# 因为输入只有一个特征，所以这里是1xs=tf.placeholder(tf.float32,[None,1])ys=tf.placeholder(tf.float32,[None,1])# inputLayer hideLayer outputLayer# 1 10 1# hideLayerl1 = add_layer(xs,1,10,activation_function=tf.nn.relu)# outputLayerpredition = add_layer(l1,10,1,activation_function=None)# 误差的平方和，再求平均loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys-predition),reduction_indices=[1]))train_step=tf.train.GradientDescentOptimizer(0.1).minimize(loss)init = tf.global_variables_initializer()sess = tf.Session()sess.run(init)# 绘图fig = plt.figure()ax = fig.add_subplot(1,1,1)ax.scatter(x_data,y_data)plt.ion()plt.show()for i in range(1000): sess.run(train_step,feed_dict=&#123;xs:x_data,ys:y_data&#125;) if i % 50 == 0: #print sess.run(loss,feed_dict=&#123;xs:x_data,ys:y_data&#125;) predition_value= sess.run(predition,feed_dict=&#123;xs:x_data&#125;) lines =ax.plot(x_data,predition_value,'r-',lw=5) plt.pause(0.5) ax.lines.remove(lines[0])# input() 学习的结果：]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>

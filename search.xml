<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[朴素贝叶斯]]></title>
    <url>%2F2018%2F05%2F06%2F%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%2F</url>
    <content type="text"><![CDATA[0、概述朴素贝叶斯是贝叶斯理论的一部分，所以讲述这部分内容之前首先需要了解一下贝叶斯定理。 贝叶斯定理是关于随机事件A和B的条件概率（或边缘概率）的一则定理。其中P(A|B)是在B发生的情况下A发生的可能性。 描述两个条件概率之间的关系，比如 P(A|B) 和 P(B|A)。 按照乘法法则，可以立刻导出： P(A∩B) = P(A)*P(B|A) = P(B)*P(A|B) 如上公式也可变形为： P(B|A) = P(A|B)*P(B)/P(A) 朴素贝叶斯分类器基于一个简单的假定：给定目标值时属性之间相互条件独立。 1、介绍1.1、工作原理假设每个特征对于决定样本属于哪一类都同等重要。给定一个测试样本w，计算它属于c的概率，只需要计算出训练样本中类别c的每个特征类型的概率p(w|c)，所有训练样本中类别c的概率p(c)，测试样本w的概率(实际使用中比较样本w属于哪个类别的可能性更大，等号两边相等) p(c|w) = p(w|c)p(c)/p(w) 1.2、优点，缺点，适用范围优点：在数据较少的情况下仍然有效，可以处理多类别问题。 缺点：对于输入数据的准备方式较为敏感。 适用范围：标称型数据。 1.3、一般流程收集数据：可以使用任何方法。 准备数据：需要数值型或者布尔型数据。 分析数据：有大量特征时，绘制特征作用不大，此时使用直方图效果更好。 训练算法：计算不同的独立特征的条件概率。 测试算法：计算错误率。 使用算法：常用于文档分类。可以在任意的分类场景中使用朴素贝叶斯分类器，不一定非要是文本。 2、实现2.1、伪代码123456789计算每个类别中的文档数目对每篇训练文档： 对每个类别： 如果词条出现文档中 -&gt; 增加该词条的计数值 增加所有词条的计数值 对每个类别： 对每个词条： 将该词条的数目数除以总词条数目得到条件概率 返回每个类别的条件概率 2.2、python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172def createVocabList(dataSet): vocabSet = set([]) for document in dataSet: vocabSet = vocabSet | set(document) return list(vocabSet)def setOfWords2Vec(vocabList,inputSet): returnVec = [0]*len(vocabList) for word in inputSet: if word in vocabList: returnVec[vocabList.index(word)] = 1 else: print("the word: %s is no in my Vocabulary!"%word) return returnVecdef bagOfWords2VecMN(vocabList,inputSet): ''' 单个单词出现多次的场景 :param vocabList:单词集合 :param inputSet:输入的句子 :return: ''' returnVec = [0]*len(vocabList) for word in inputSet: if word in vocabList: returnVec[vocabList.index(word)] += 1 else: print("the word: %s is no in my Vocabulary!" % word) return returnVecdef trainNB0(trainMatrix,trainCategory): ''' :param trainMatrix:文档矩阵 :param trainCategory:文档标签向量 :return: ''' # 计算样本数 numTrainDocs = len(trainMatrix) # 计算单词数 numWords = len(trainMatrix[0]) # 计算所有样本中侮辱言论的概率 pAbusive = sum(trainCategory)/float(numTrainDocs) # 避免个别单词不出现，导致计算概率为0，默认都出现一次。 p0Num = ones(numWords);p1Num = ones(numWords) p0Denom = 2.0; p1Denom = 2.0 for i in range(numTrainDocs): # 轮询所有样本 if trainCategory[i] == 1: # 所有侮辱性言论 # 侮辱性言论中，每个单词使用的次数 p1Num += trainMatrix[i] # 侮辱性言论中，所有单词的出现次数 p1Denom += sum(trainMatrix[i]) else: # 所有正常言论 # 正常言论中，每个单词使用的次数 p0Num += trainMatrix[i] # 正常言论中，所有单词的出现次数 p0Denom += sum(trainMatrix[i]) p1Vect = log(p1Num / p1Denom) p0Vect = log(p0Num / p0Denom) return p0Vect,p1Vect,pAbusivedef classifyNB(vec2Classify,p0Vec,p1Vec,pClass1): # p(c1|w) = p(w|c1)p(c1)/p(w) # p(c0|w) = p(w|c0)p(c0)/p(w) # p0Vec,p1Vec已经log过的。此处缺少除以单词本身出现的概率p(w)。p0,p1都需要除以p(w)可约去 p1 = sum(vec2Classify * p1Vec)+log(pClass1) p0 = sum(vec2Classify * p0Vec)+log(1 - pClass1) if p1 &gt; p0: return 1 else: return 0 3、总结巧妙的运用概率的方法解决分类问题，朴素贝叶斯降低了条件概率计算的复杂度，并且正确率很好。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树算法]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0、概述分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点和有向边组成。 结点有两种类型：内部节点和叶节点，内部节点表示一个特征或属性，叶节点表示一个类。 分类的时候，从根节点开始，对实例的某一个特征进行测试，根据测试结果，将实例分配到其子结点； 此时，每一个子结点对应着该特征的一个取值。如此递归向下移动，直至达到叶结点，最后将实例分配到叶结点的类中。 1、介绍1.1、工作原理对训练数据进行建模，决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程。 它可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。 1.2、优点，缺点，适用范围优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据。 缺点：可能会产生过渡匹配问题。 适用范围：数值型和标称型 1.3、一般流程收集数据：可以使用任何方法。 准备数据：树构造算法只适用于标称型数据，因此数值型数据必须离散化。 分析数据：可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期。 训练算法：构造树的数据结构。 测试算法：使用经验树计算错误率。 使用算法：此步骤可以适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。 2、实现2.1、伪代码123456789# 创建分支伪代码函数createBranch()如下所示： if so return 类标签; else 寻找划分数据集的最好特征 划分数据集 创建分支节点 for 每个划分的子集 调用函数createBranch()并增加结果到分支节点中 return 分支节点 2.2、信息增益划分数据集的大原则是：将无序的数据变得更加有序。决策树是通过什么来选择树根，树枝，叶子的呢？这里不得提到两个概念：信息增益和熵。信息增益：在划分数据集之前之后信息发生的变化称为信息增益。熵：集合信息的度量方式称为熵。如果待分类的事务可能分在多个分类之中，则符号x$_{i}$的信息定义为：$$l(x_{i}) = - \log_2 p(x_{i})$$其中p(x$_{i}$)是选择该分类的概率。为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，公式如下：$$H = -\sum_{i=1}^{n}p(x_{i})\log_2 p(x_{i})$$ 2.3、python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118def calcShannoEnt(dataSet): ''' 计算给定数据集的香农熵。注意是所有数据的集合，不是单个样本。 1. get last current ShannoEnt :param dataSet:数据集 :return: 计算结果 ''' numEntries = len(dataSet) labelCounts = &#123;&#125; # 遍历每个实例，统计标签的频数 for featVec in dataSet: # 获取单个样本的标签列(样本的最后一列为标签列) currentLabel = featVec[-1] # 为单个分类创建字典 if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 shannonEnt = 0.0 # 计算所有类别所有可能值包含的信息期望值 for key in labelCounts: prob = float(labelCounts[key])/numEntries shannonEnt -= prob*log(prob,2) return shannonEnt def splitDataSet(dataSet,axis,value): ''' 按照给定特征划分数据集。最终获得一个子集。举个栗子： [[1,1,'yes'] [1,1,'yes'] [1,0,'no'] [0,1,'no'] [0,1,'no']] 如果以第二例作为axis，特征值为1，得到下面的子集： [[1,'yes'] [1,'yes'] [0,'no'] [0,'no']] 1. find the value row 2. del the value from the row 3. return all the row as [] :param dataSet:待划分的数据集 :param axis:划分数据集的特征 :param value: 需要split的特征值 :return: 划分结果列表 ''' retDataSet = [] for featVec in dataSet: if featVec[axis] == value: reduceFeatVec = featVec[:axis] reduceFeatVec.extend(featVec[axis+1:]) retDataSet.append(reduceFeatVec) return retDataSet def chooseBestFeatureToSplit(dataSet): ''' 1.每个特征中的每个特征值分类 2.计算划分后的香农熵，找出最大熵 3.得出划分后香农熵最大的特征作为最好的分类特征 :param dataSet:数据集 :return:返回分类最好的特征 ''' numFeatures = len(dataSet[0]) - 1 baseEntropy = calcShannoEnt(dataSet) bestInfoGain = 0.0;bestFeature = -1 for i in range(numFeatures): featList = [example[i] for example in dataSet] uniqueVals = set(featList) newEntropy = 0.0 for value in uniqueVals: subDataSet = splitDataSet(dataSet,i,value) prob = len(subDataSet)/float(len(dataSet)) newEntropy += prob*calcShannoEnt(subDataSet) infoGain = baseEntropy - newEntropy if(infoGain &gt; bestInfoGain): bestInfoGain = infoGain bestFeature = i return bestFeature def majorityCnt(classList): ''' 采用多数表决的方法决定叶结点的分类 :param: 所有的 类标签 列表 :return: 出现次数最多的类 ''' classCount=&#123;&#125; for vote in classList: # 统计所有类标签的频数 if vote not in classCount.keys(): classCount[vote]=0 classCount[vote] += 1 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1),reverse=True) return sortedClassCount[0][0] def createTree(dataSet,labels): ''' 创建决策树 :param: dataSet:训练数据集 :return: labels:所有的类标签 ''' classList = [example[-1] for example in dataSet] # 所有的标签都相同，直接返回该标签 if classList.count(classList[0]) == len(classList): return classList[0] # 遍历完所有特征，仍不能把数据划分为仅包含唯一类别的分组，返回出现次数最多的 if len(dataSet[0]) == 1: return majorityCnt(classList) # 找到最好的Feature，函数名称感觉有点问题，跟ToSplit没有关系 bestFeat = chooseBestFeatureToSplit(dataSet) # 找到对应的标签 bestFeatLabel = labels[bestFeat] # 将当前最好的Feature放到决策树 myTree = &#123;bestFeatLabel:&#123;&#125;&#125; del(labels[bestFeat]) featValues = [example[bestFeat] for example in dataSet] uniqueVals = set(featValues) # 一个Feature里面有多个值，按不同的值进行构建树的分支 for value in uniqueVals: subLabels = labels[:] myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet,bestFeat,value),subLabels) return myTree 3、总结决策树算法稍微有点复杂，后面还会涉及到剪枝。目前只接触到二叉树，也就是说一个特征值 要么是，要么否，不知道支不支持多分支，看算应该是支持多分支的，有待继续学习。深刻感 觉到理论的重要性，香农熵的概念是这个算法的核心，如果没有选择最优特征值的算法，无法 确定最优二叉树。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k-近邻算法]]></title>
    <url>%2F2018%2F04%2F12%2Fk-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0、概述 1、介绍 1.1、工作原理 1.2、优点，缺点，适用范围 1.3、一般流程 2、实现 2.1、伪代码 2.2、python实现 3、总结 0、概述简单的说，k-近邻算法是一种分类算法，采用测量测试用例与样本用例不同特征值之间的距离，选取距离最小的样本所属的分类作为测试用例的分类。 1、介绍1.1、工作原理工作原理：存在一个样本数据集，也称作训练样本集，并且样本集中每个数据都存在标签，即我们都知道样本集中每个数据与所属分类的对应关系。 输入没有标签的新数据后，将新数据的每个特征与样本集中的数据对应的特征比较，然后算法提取样本集中特征最相似数据(最近邻)的分类标签。 一般来说，我们只选择样本数据集中前K个最相似的数据，这就是k-近邻算法中的k的出处，通常k是不大于20的整数。 最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类 1.2、优点，缺点，适用范围优点：精度高、对异常值不敏感、无数据输入假定。 缺点：计算复杂度高、空间复杂度高。（每个测试用例都要计算与所有样本用例的每个特征值的距离） 适用范围：数值型和标称型 1.3、一般流程收集数据：可以使用任何方法。 准备数据：距离计算所需要的数值，最好是结构化的数据格式。 分析数据：可以使用任何方法。 训练算法：N/A 测试算法：计算错误率。 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类， 最后应用对计算出的分类执行后续的处理。 2、实现2.1、伪代码N/A 2.2、python实现12345678910111213141516171819202122232425262728293031323334from numpy import *import operatorfrom os import listdirdef classify0(inX, dataSet, labels, k): ''' kNN: k Nearest Neighbors Input: inX: vector to compare to existing dataset (1xN) dataSet: size m data set of known vectors (NxM) labels: data set labels (1xM vector) k: number of neighbors to use for comparison (should be an odd number) Output: the most popular class label ''' # 获取样本数，即M dataSetSize = dataSet.shape[0] # 将单个样本拉成M行矩阵，矩阵相减，得到测试用例特征值与每个样本用例的特征值的差 diffMat = tile(inX, (dataSetSize,1)) - dataSet # 特征值差的平方。此处是array sqDiffMat = diffMat**2 # 每个样本所有特征值差和 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 # 排序，按照数组所在的编号输出 sortedDistIndicies = distances.argsort() classCount=&#123;&#125; for i in range(k): # 获取前k个的标签 voteIlabel = labels[sortedDistIndicies[i]] # 计算相同标签数 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 # 按照标签个数排序 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] 3、总结k-近邻算法是分类数据最简单最有效的算法。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习15之Animation动画]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A015%E4%B9%8BAnimation%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npfrom matplotlib import animationfig,ax = plt.subplots()# 数据是一个0~2π内的正弦曲线x = np.arange(0,2*np.pi,0.1)y= np.sin(x)line, = ax.plot(x,y)# 采用np.pi*i/30 方式更新，更流畅def animate(i): line.set_ydata(np.sin(x+np.pi*i/30)) return line,def init(): line.set_ydata(np.sin(x)) return line,# https://matplotlib.org/api/animation_api.htmlani = animation.FuncAnimation(fig=fig,func=animate,frames=30,init_func=init,blit=True)# https://stackoverflow.com/questions/25140952/matplotlib-save-animation-in-gif-errorani.save('/home/xuleilx/workspace/github/github_pages/public/images/animation.gif', writer='imagemagick', fps=30)plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习14之次坐标轴]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A014%E4%B9%8B%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npx = np.arange(0,10,0.1)y1 = 0.05*x**2y2 = -1*y1# 获取figure默认的坐标系 ax1# fig,ax1 = plt.subplots()ax1 = plt.subplot()# 对ax1调用twinx()方法，生成如同镜面效果后的ax2ax2 = ax1.twinx()ax1.plot(x,y1,'g-')ax2.plot(x,y2,'b--')ax1.set_xlabel('X data')ax1.set_ylabel('Y1',color='g')ax2.set_ylabel('Y2',color='b')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subaxes.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习13之图中图]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A013%E4%B9%8B%E5%9B%BE%E4%B8%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfig = plt.figure()x = [1,2,3,4,5,6,7]y = [1,3,4,2,5,8,6]# 4个值都是占整个figure坐标系的百分比。在这里，假设figure的大小是10x10，# 那么大图就被包含在由(1, 1)开始，宽8，高8的坐标系内。left,bottom,width,height=0.1,0.1,0.8,0.8ax1 = fig.add_axes([left,bottom,width,height])ax1.plot(x,y,'r')ax1.set_xlabel('X')ax1.set_ylabel('Y')ax1.set_title('title')left,bottom,width,height=0.2,0.6,0.25,0.25ax2 = fig.add_axes([left,bottom,width,height])ax2.plot(y,x,'b--')ax2.set_xlabel('X')ax2.set_ylabel('Y')ax2.set_title('title inside 1')# 采用一种更简单方法，即直接往plt里添加新的坐标系left,bottom,width,height=0.6,0.2,0.25,0.25plt.axes([left,bottom,width,height])plt.plot(y[::-1],x,'g-.') # 注意对y进行了逆序处理plt.xlabel('X')plt.ylabel('Y')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/plotinplot.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习12之Subplot多合一显示2]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A012%E4%B9%8BSubplot%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA2%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspec# method 1:subplot2grid#############################plt.figure()ax1 = plt.subplot2grid((3,3),(0,0),colspan=3,rowspan=1)ax1.plot([1,2],[1,2])ax1.set_title('ax1_title')ax2 = plt.subplot2grid((3,3),(1,0),colspan=2)ax3 = plt.subplot2grid((3,3),(1,2),rowspan=2)ax4 = plt.subplot2grid((3,3),(2,0))ax5 = plt.subplot2grid((3,3),(2,1))# method 2:gridspec############################## plt.figure()# gs = gridspec.GridSpec(3,3)# ax1 = plt.subplot(gs[0,:])# ax2 = plt.subplot(gs[1,:2])# ax3 = plt.subplot(gs[1:,2])# ax4 = plt.subplot(gs[2,0])# ax5 = plt.subplot(gs[2,1])# method 3:easy to define structure############################## f,axes = plt.subplots(2,2,sharex=True)# axes[0,0].scatter([1,2],[1,2])plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subplot_method1.png")plt.tight_layout()plt.show() 结果：Method1:Method2:Method3:]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习12之Subplot多合一显示]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A012%E4%B9%8BSubplot%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfig = plt.figure()# 使用plt.subplot(2,1,1)将整个图像窗口分为2行1列, 当前位置为1.# 使用plt.plot([0,1],[0,1])在第1个位置创建一个小图.plt.subplot(211)plt.plot([0,1],[0,1])# 使用plt.subplot(2,3,4)将整个图像窗口分为2行3列, 当前位置为4.# 使用plt.plot([0,1],[0,2])在第4个位置创建一个小图.## 这里需要解释一下为什么第4个位置放第2个小图. 上一步中使用plt.subplot(2,1,1)将整个图像窗口分为2行1列,# 第1个小图占用了第1个位置, 也就是整个第1行. 这一步中使用plt.subplot(2,3,4)将整个图像窗口分为2行3列,# 于是整个图像窗口的第1行就变成了3列, 也就是成了3个位置, 于是第2行的第1个位置是整个图像窗口的第4个位置.plt.subplot(234)plt.plot([0,1],[0,2])plt.subplot(235)plt.plot([0,1],[0,3])plt.subplot(236)plt.plot([0,1],[0,4])plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subplot.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习11之3D图像]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A011%E4%B9%8B3D%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)# X,Y valuex = np.arange(-4,4,0.25)y = np.arange(-4,4,0.25)X,Y = np.meshgrid(x,y)# x-y 平面的网格R = np.sqrt(X**2+Y**2)# height valueZ = np.sin(R)# rstride 和 cstride 分别代表 row 和 column 的跨度ax.plot_surface(X,Y,Z,rstride=1,cstride=1,cmap='rainbow',edgecolor='black')# 添加 XY 平面的等高线ax.contourf(X,Y,Z,zdir='z',offset=-2,cmap='rainbow')ax.set_zlim(-2,2)plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/3d_data.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习9之Image图片]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A010%E4%B9%8BImage%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npa = np.linspace(0,1,9).reshape(3,3)# 三行三列的格子，a代表每一个值，图像右边有一个注释，白色代表值最大的地方，颜色越深值越小。plt.imshow(a,interpolation='nearest',cmap='bone',origin='lower')# 添加一个colorbar ，其中我们添加一个shrink参数，使colorbar的长度变短为原来的92%plt.colorbar(shrink=.92)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/image.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习9Contours等高线图]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A09%E4%B9%8BContours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npdef f(x,y): # the height function return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)n = 256x = np.linspace(-3,3,n)y = np.linspace(-3,3,n)# 编织成栅格X,Y = np.meshgrid(x,y)# use plt.contourf to filling contours# X,Y and value for (X,Y) pointplt.contourf(X,Y,f(X,Y),8,alpha=.75,cmap=plt.cm.hot)C = plt.contour(X,Y,f(X,Y),8,colors='black',linewidth=.5)# 添加label，隐藏坐标轴plt.clabel(C,inline=True,fontsize=10)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/contours.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习8之bar柱状图]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A08%E4%B9%8Bbar%E6%9F%B1%E7%8A%B6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npn = 10X = np.arange(n)# 均匀分布Y1 = (1-X/float(n))*np.random.uniform(0.5,1,n)Y2 = (1-X/float(n))*np.random.uniform(0.5,1,n)plt.bar(X,+Y1,facecolor='#9999ff',edgecolor='white')plt.bar(X,-Y2,facecolor='#ff9999',edgecolor='white')for x,y in zip(X,Y1): # ha: horizontal alignment # va: vertical alignment plt.text(x,y,'%.2f'%y,ha='center',va='bottom')for x,y in zip(X,Y2): plt.text(x,-y,'%.2f'%y,ha='center',va='top')#设置显示范围plt.xlim(-.5,n)plt.ylim(-1.25,1.25)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/bar_map.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习7之散点图]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A07%E4%B9%8B%E6%95%A3%E7%82%B9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npn = 1024# 高斯分布 http://blog.csdn.net/lanchunhui/article/details/50163669X = np.random.normal(0,1,n)Y = np.random.normal(0,1,n)T = np.arctan2(Y,X)# for color valueplt.scatter(X,Y,s=75,c=T,alpha=0.5)#设置显示范围plt.xlim(-1.5,1.5)plt.ylim(-1.5,1.5)# 去坐标plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/dot_map.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习6之tick能见度]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A06%E4%B9%8Btick%E8%83%BD%E8%A7%81%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y = 0.1*xplt.figure(num=1,figsize=(8,5))# 单纯直线plt.plot(x,y,linewidth=10,zorder=1)plt.ylim(-2,2)# gca = 'get current axis'# 移动坐标轴位置ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))# 当坐标轴的数字被遮挡时，调整线的透明度for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.7, zorder=2))plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/tick.png")#显示plt.show()]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习5之标注annotate]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A05%E4%B9%8B%E6%A0%87%E6%B3%A8annotate%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y = 2*x + 1plt.figure(num=1,figsize=(8,5))# 单纯直线plt.plot(x,y)# gca = 'get current axis'# 移动坐标轴位置ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))x0 = 1y0 = 2*x0+1# x:[x0,x0],y:[0,y0] 矩阵运算plt.plot([x0,x0],[0,y0],'k--',linewidth=2.5)# set dot stylesplt.scatter([x0,],[y0,],s=50,color='b')# 添加标注# method1plt.annotate(r'$2x+1=%s$'%y0, xy=(x0,y0), xycoords='data', xytext=(+30,-30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle='-&gt;', connectionstyle='arc3,rad=.2'))# method2plt.text(-1,3, r'$\mu\ \sigma_i\ \alpha_t$', fontdict=&#123;'size':16,'color':'r'&#125;)plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/annotation.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习4之legend]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A04%E4%B9%8Blegend%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])# 单纯直线l1, = plt.plot(x,y2,label='up')# 指定线的颜色, 宽度和类型l2, = plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--',label='bottom')plt.legend(handles=[l1,l2],labels=['aaa','bbb'],loc='best')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/legend.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习3之axis2]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A03%E4%B9%8Baxis2%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 单纯直线plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--')# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])# gca = 'get current axis'ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/axis_2.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习3之axis]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A03%E4%B9%8Baxis%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 单纯直线plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--')# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])#显示plt.show() 输出结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习2之figure]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A02%E4%B9%8Bfigure%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2# figure 3，指定figure的编号并指定figure的大小plt.figure(num=3,figsize=(8,5))plt.plot(x,y1)plt.figure(&quot;f2&quot;)plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color=&apos;red&apos;,linewidth=5.0,linestyle=&apos;--&apos;)#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习1之直线曲线]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A01%E4%B9%8B%E7%9B%B4%E7%BA%BF%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[代码： 1234567891011121314151617# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-1,1,50)#绘制直线y = x + 1plt.plot(x,y)#绘制曲线y = x**2plt.plot(x,y)#显示plt.show() 显示结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow学习之二次曲线]]></title>
    <url>%2F2017%2F12%2F17%2Ftensorflow%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#coding:utf-8import tensorflow as tfimport numpy as npimport matplotlib.pyplot as plt# 构造添加神经层的函数def add_layer(inputs,in_size,out_size,activation_function=None): # 权重，in_size*out_size随机变量矩阵 Weights = tf.Variable(tf.random_normal([in_size,out_size])) # 偏差，1*out_size数组。 # 在机器学习中，biases的推荐值不为0，这里是在0向量的基础上+0.1 biases = tf.Variable(tf.zeros([1,out_size])+0.1) # y = Weights*x+biases 。 tf.matmul()是矩阵的乘法 Wx_plus_b = tf.matmul(inputs,Weights)+biases # 如果没有定义激励函数就是线性函数 if activation_function is None: outputs = Wx_plus_b else: outputs = activation_function(Wx_plus_b) return outputs# 生成x的值,类似# [[-1. ]# [-0.5]# [ 0. ]# [ 0.5]# [ 1. ]]x_data = np.linspace(-1,1,300)[:,np.newaxis]# 加了一个noise,这样看起来会更像真实情况.类型与x_data一样noise = np.random.normal(0,0.05,x_data.shape)# y = x**2 - 0.5 + noisey_data = np.square(x_data)-0.5+noise# 利用占位符定义我们所需的神经网络的输入。# tf.placeholder()就是代表占位符，这里的None代表无论输入有多少都可以，# 因为输入只有一个特征，所以这里是1xs=tf.placeholder(tf.float32,[None,1])ys=tf.placeholder(tf.float32,[None,1])# inputLayer hideLayer outputLayer# 1 10 1# hideLayerl1 = add_layer(xs,1,10,activation_function=tf.nn.relu)# outputLayerpredition = add_layer(l1,10,1,activation_function=None)# 误差的平方和，再求平均loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys-predition),reduction_indices=[1]))train_step=tf.train.GradientDescentOptimizer(0.1).minimize(loss)init = tf.global_variables_initializer()sess = tf.Session()sess.run(init)# 绘图fig = plt.figure()ax = fig.add_subplot(1,1,1)ax.scatter(x_data,y_data)plt.ion()plt.show()for i in range(1000): sess.run(train_step,feed_dict=&#123;xs:x_data,ys:y_data&#125;) if i % 50 == 0: #print sess.run(loss,feed_dict=&#123;xs:x_data,ys:y_data&#125;) predition_value= sess.run(predition,feed_dict=&#123;xs:x_data&#125;) lines =ax.plot(x_data,predition_value,'r-',lw=5) plt.pause(0.5) ax.lines.remove(lines[0])# input() 学习的结果：]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

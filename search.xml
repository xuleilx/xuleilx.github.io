<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[经验分享：gcc编译参数stack-protector]]></title>
    <url>%2F2020%2F11%2F27%2F%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%EF%BC%9Agcc%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0stack-protector%2F</url>
    <content type="text"><![CDATA[经验分享：gcc编译参数stack-protector前言 1 目的指导针对gcc编译选项stack-protector产生的core的解析，解决产品中的Bug。 2 适用范围C/C++程序开发者。 3 职责与权限针对 stack smashing detected 错误，使开发工程师在开发调试时明确调试与修改方向。 4 正文内容4.1 stack-protector介绍Stack overflow攻击是一种很常见的代码攻击，armcc和gcc等编译器都实现了stack protector来避免stack overflow攻击。虽然armcc和gcc在汇编代码生成有些不同，但其原理是相同的。这篇文章以armcc为例，看一看编译器的stack protector。 armcc提供了三个编译选项来打开/关闭stack protector。 -fno-stack-protector 关闭stack protector man gcc没有找到，gcc版本相关？ -fstack-protector 为armcc认为危险的函数打开stack protector -fstack-protector-all 为所有的函数打开stack protector 4.2 如何防止stack overflow攻击？armcc在函数栈中的上下文和局部变量之间插入了一个数字来监控堆栈破坏，这个值一般被称作为canary word，在armcc中将这个值定义为stack_chk_guard。当函数返回之前，函数会去检查canary word是否被修改，如果canary word被修改了，那么证明函数栈被破坏了，这个时候armcc就会去调用一个函数来处理这种栈破坏行为，armcc为我们提供了stack_chk_fail这个回调函数来处理栈破坏。 因此，在armcc打开-fstack-protector之前需要在代码中设置stack_chk_guard和stack_chk_fail。我从ARM的官网上摘抄了一段它们的描述。1234567void *__stack_chk_guardYou must provide this variable with a suitable value, such as a random value. The value can change during the life of the program. For example, a suitable implementation might be to have the value constantly changed by another thread.void __stack_chk_fail(void)It is called by the checking code on detection of corruption of the guard. In general, such a function would exit, possibly after reporting a fault. 4.3 stack protector产生了什么代码来防止stack overflow？首先来看一下写的一个c代码片段， 代码很简单，stack_chk_guard 设置为一个常数，当然这只是一个例子，最好的方法是设置这个值为随机数。然后重写了stack_chk_fail这个回调接口。test_stack_overflow这个函数很简单，仅仅在函数栈上分配了i和c_arr这两个局部变量，并对部分成员赋值。12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;void __stack_chk_fail()&#123; printf("__stack_chk_fail()\n"); while(1);&#125;void *__stack_chk_guard = (void *)0;int test_stack_overflow(int a, int b, int c, int d, int e)&#123; int i; int c_arr[15]; int *p = c_arr; i = 15; c_arr[0] = 2; c_arr[1] = 3; return 0;&#125;int main(int argc,char* argv[]) &#123; printf("before test_stack_overflow\n"); test_stack_overflow(1, 2, 3, 4, 5); printf("after test_stack_overflow\n"); return 0;&#125; 没有打开-fstack-protector选项时：打开-fstack-protector选项时： 在函数返回的时候，检测__stack_chk_guard的值。 下图左边是没有打开-fstack-protector，右边是打开-fstack-protector的汇编代码： 4.4示例代码 test_overflow.c12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int check_password(char *password)&#123; int flag = 0; char buffer[20]; strcpy(buffer, password); if(strcmp(buffer, "mypass") == 0)&#123; flag = 1; &#125; if(strcmp(buffer, "yourpass") == 0)&#123; flag = 1; &#125; return flag;&#125;int main(int argc, char *argv[])&#123; if(argc &gt;= 2)&#123; if(check_password(argv[1]))&#123; printf("%s", "Access granted\n"); &#125;else&#123; printf("%s", "Access denied\n"); &#125; &#125;else&#123; printf("%s", "Please enter password!\n"); &#125;&#125; 编译：1# gcc test_overflow.c -g -fstack-protector]]></content>
      <tags>
        <tag>gdb,gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于StackSmashingDetected问题调查]]></title>
    <url>%2F2020%2F11%2F27%2F%E5%85%B3%E4%BA%8EStackSmashingDetected%E9%97%AE%E9%A2%98%E8%B0%83%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[关于StackSmashingDetected问题调查■现象密钥交换时报错： stack smashing detected ，产生CoreDump。 ■再现步骤1.密钥交换 ■根本原因使用解密函数写穿了局部变量的buffer，导致触发了stack protector机制。 代码分析：12345678910int RootKeyCmdDown::procMsg(std::shared_ptr&lt;ConnectionContext&gt; conn)&#123; logInfo("%s procMsg.", TAG.data()); vector&lt;BYTE&gt; dataVec; dataVec.resize(32); memset(&amp;dataVec[0], 0, 32); BYTE new_root_key[16] = &#123;0&#125;; get_new_rootkey(new_root_key); .......&#125; 1aes_decrypt((unsigned char*)new_root_key_aes,32,pMsgContainer-&gt;GetRootKeyVector(),aes_decrypt_buf); 12345678910int aes_decrypt(unsigned char* in, int len , unsigned char* key, unsigned char* out)&#123; AES_KEY aes; if(AES_set_decrypt_key(key, 128, &amp;aes) &lt; 0) return 0; for(int i = 0;i&lt;(len/16);i++) //循环调用两次，out处写了32个字节 &#123; AES_ecb_encrypt(in+i*16, out+i*16, &amp;aes , AES_DECRYPT); &#125; return 1;&#125; ■调查详细由于密钥交换触发条件比较麻烦，本示例使用的是测试程序，并非项目代码 1.打开产生Core文件选项123root@mdm9607-perf:~/work/stack-protector# ulimit -c unlimitedroot@mdm9607-perf:~/work/stack-protector# ulimit -cunlimited 2.查看Core产生路径12root@mdm9607-perf:~/work/stack-protector# cat /proc/sys/kernel/core_pattern core 相对路径core，代表Core文件生成在执行命令的当前目录下。 3.gdb调试3.1 打印堆栈回溯12345678910111213141516171819root@mdm9607-perf:~/work/stack-protector# ./test_overflow_smash xxxxxxxxxxxxxxxxxxxxx*** stack smashing detected ***: ./test_overflow_smash terminatedAborted (core dumped)root@mdm9607-perf:~/work/stack-protector# gdb ./test_overflow_smash coreReading symbols from ./test_overflow_smash...2502done.warning: core file may not match specified executable file.[New LWP 5939]Core was generated by `./test_overflow_smash xxxxxxxxxxxxxxxxxxxxx&apos;.Program terminated with signal SIGABRT, Aborted.#0 0x4c93cb94 in raise () from /lib/libc.so.6(gdb) bt#0 0x4c93cb94 in raise () from /lib/libc.so.6#1 0x4c940670 in abort () from /lib/libc.so.6#2 0x4c974998 in ?? () from /lib/libc.so.6Backtrace stopped: previous frame identical to this frame (corrupt stack?)(gdb) libc.so以后的堆栈回溯只能看到？号。百度一下，可能是libc.so的版本不对。也就是说集成环境的libc.so与我们编译的SDK中libc.so版本不一致。 3.2 拷贝SDK中的libc.so到环境中，编译时指定该目录123root@mdm9607-perf:~/work/stack-protector# lscore test_overflow_segvlibc.so.6 3.3 gdb中设置lib库的加载路径123456789101112131415161718(gdb) set solib-absolute-prefix "./"(gdb) set solib-search-path "./"warning: .dynamic section for "/home/root/work/stack-protector/libc.so.6" is not at the expected address (wrong library or version mismatch?)Reading symbols from /home/root/work/stack-protector/libc.so.6...done.Loaded symbols for /home/root/work/stack-protector/libc.so.6(gdb) bt#0 0x4c93cb94 in raise () from /home/root/work/stack-protector/libc.so.6#1 0x4c940670 in abort () from /home/root/work/stack-protector/libc.so.6#2 0x4c974998 in __libc_message () from /home/root/work/stack-protector/libc.so.6#3 0x4c9f042c in __fortify_fail () from /home/root/work/stack-protector/libc.so.6#4 0x4c9f03e8 in __stack_chk_fail () from /home/root/work/stack-protector/libc.so.6#5 0x0000862c in check_password (password=0xbebcfed8 'x' &lt;repeats 21 times&gt;) at test_overflow.c:19#6 0x00008674 in main (argc=2, argv=0xbebcfdc4) at test_overflow.c:23(gdb) 3.4 关于编译参数stack-protector介绍见《经验分享：gcc编译参数stack-protector》]]></content>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于gst_element_set_state死锁问题调查]]></title>
    <url>%2F2020%2F11%2F26%2F%E5%85%B3%E4%BA%8Egst-element-set-state%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E8%B0%83%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[关于gst_element_set_state死锁问题调查■现象gst_element_set_state 变更GST_STATE_NULL状态时deadlock。 ■再现步骤1.Carlife语音识别时说”鲜花”2.在VR语音提示音的时候播放过程中，按radio硬按键切源 更普遍的再现方法：(也就是说该问题是普遍性问题，与Carlife无直接关系)1.插入U盘播放音乐2.音乐播放过程中，点击暂停3.使用gst-launch-1.0 playbin uri=file:///media/disk/Track02.mp3 播放音乐4.步骤3音乐播放过程中按radio硬按键切源5.按Ctrl+C 结束步骤3的音乐播放，发现无法结束，终端输出以下内容后hangup。Setting pipeline to PAUSED … ■直接原因调用 gst_element_set_state() 函数暂停播放时会调用到alsasink的 gst_alsasink_reset() 函数来重置PCM流，该函数会获取alsa_lock锁，以保证当前正在处理的Buffer中的数据处理结束后重置PCM流。由于alsasink的 gst_alsasink_write() 函数获取alsa_lock锁之后，无法写入最后一包数据，导致该锁无法释放，最终导致 gst_element_set_state() 死锁。也就是说问题发生的时候，声卡的文件句柄无法正常写入。err = snd_pcm_writei() 的返回值是：-11。snd_strerror(err) 打印出来的含义是：”Resource temporarily unavailable”。 ■根本原因切源的时候DSP那边通路被切走，导致alsa的最后一包数据写不进去。此时可以关声卡，但是不能写入数据。通路再切回来就能正常写入，声卡就可以关闭结束。 ■调查详细1）由于Carlife服务线程较多，为了准确定位是哪个线程，设置了线程名”SetNameForA7”1234567891011(gdb) info threads Id Target Id Frame 15 Thread 0xb6588450 (LWP 2718) "SetNameForA7" 0xb6f6e6ee in recv () ★ at ../sysdeps/unix/syscall-template.S:81 14 Thread 0xb5d88450 (LWP 2719) "CarlifeDaemon" __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:43...略... 2 Thread 0xae47a450 (LWP 2993) "TinyVpuDec:src" __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:43* 1 Thread 0xb658a000 (LWP 2717) "CarlifeDaemon" __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:43 ★处是我们要找的”SetNameForA7”线程 2）正常情况下线程2718的状态1234567891011121314151617(gdb) thread 18[Switching to thread 18 (Thread 0xb6588450 (LWP 2718))]#0 0xb6f6e6ee in recv () at ../sysdeps/unix/syscall-template.S:8181 ../sysdeps/unix/syscall-template.S: No such file or directory.(gdb) bt#0 0xb6f6e6ee in recv () at ../sysdeps/unix/syscall-template.S:81#1 0xb6e64f64 in Socket::recv(unsigned char*, unsigned int) const () from /usr/app/carlife/lib/libcarlifevehicle.so ★#2 0xb6e639fa in CConnectManager::readCmdData(unsigned char*, unsigned int) () from /usr/app/carlife/lib/libcarlifevehicle.so...略...#10 0xb6d54ee4 in ?? () from /usr/app/carlife/lib/libboost_thread.so.1.59.0#11 0xb6f6845e in start_thread (arg=0xb6588910) at pthread_create.c:314#12 0xb6905d9c in ?? () at ../ports/sysdeps/unix/sysv/linux/arm/nptl/../clone.S:92 from /lib/arm-linux-gnueabihf/libc.so.6Backtrace stopped: previous frame identical to this frame (corrupt stack?) 该线程用于接收来自手机Carlife的命令通道的消息，recv是阻塞式函数，无消息时阻塞在recv处，属于正常情况。 3）出问题的时候，线程2718的状态123456789101112131415(gdb) thread 17[Switching to thread 17 (Thread 0xb6588450 (LWP 2718))]#0 __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:4343 in ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S(gdb) bt#0 __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:43#1 0xb6f6dffc in __lll_lock_wait (futex=futex@entry=0x835fd8, private=0) at ../ports/sysdeps/unix/sysv/linux/arm/nptl/lowlevellock.c:46#2 0xb6f6a3aa in __GI___pthread_mutex_lock (mutex=0x835fd8) at pthread_mutex_lock.c:134#3 0xb6b88de2 in g_mutex_lock () from /usr/lib/libglib-2.0.so.0 ★#4 0xae4e56a2 in ?? () from /usr/lib/gstreamer-1.0/libgstalsa.soBacktrace stopped: previous frame identical to this frame (corrupt stack?) 可以看出是libgstalsa.so中获取互斥锁的地方deadlock了，此时由于gstreamer的调试信息未打开，所以无法看到完整的调用关系。 4）重新编译gstreamer1.0-plugins-base插件，加-g参数增加调试信息，重新打印堆栈回溯12345678910111213141516171819202122232425(gdb) bt#0 __libc_do_syscall () at ../ports/sysdeps/unix/sysv/linux/arm/libc-do-syscall.S:43#1 0xb6eb0ffc in __lll_lock_wait (futex=futex@entry=0x1fe0f30, private=0) at ../ports/sysdeps/unix/sysv/linux/arm/nptl/lowlevellock.c:46#2 0xb6ead3aa in __GI___pthread_mutex_lock (mutex=0x1fe0f30) at pthread_mutex_lock.c:134#3 0xb6acbde2 in g_mutex_lock () from /usr/lib/libglib-2.0.so.0 ★#4 0xac4b86a2 in gst_alsasink_reset (asink=0x1fcede8) at /workspace/MR3/F516/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/ext/alsa/gstalsasink.c:1122#5 0xb03a3a1a in gst_audio_sink_ring_buffer_pause (buf=&lt;optimized out&gt;) at /workspace/MR3/F516/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/audio/gstaudiosink.c:545#6 0xb0387082 in gst_audio_ring_buffer_pause_unlocked ( buf=buf@entry=0x1fd4388) at /workspace/MR3/F516/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/audio/gstaudioringbuffer.c:1006#7 0xb038966c in gst_audio_ring_buffer_pause (buf=0x1fd4388) at /workspace/MR3/F516/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/audio/gstaudioringbuffer.c:1049#8 0xb03a0746 in gst_audio_base_sink_change_state (element=0x1fcede8, transition=GST_STATE_CHANGE_PLAYING_TO_PAUSED) at /workspace/MR3/F516/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gst---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---reamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/audio/gstaudiobasesink.c:2471#9 0xb6702ba2 in gst_element_change_state () from /usr/lib/libgstreamer-1.0.so.0#10 0xb6703004 in ?? () from /usr/lib/libgstreamer-1.0.so.0Backtrace stopped: previous frame identical to this frame (corrupt stack?) 此时可以看出完整的Gstreamer设置管道状态的调用顺序。 5）通过阅读alsasink插件的代码,发现只有gst_alsasink_write()，gst_alsasink_reset()两个函数会获取alsa_lock锁。通过代码分析，唯一可能的原因是 gst_alsasink_write() 中调用 snd_pcm_writei() 函数一直失败。 6）使用” export GST_DEBUG=3,alsa:7”打开alsa插件的日志，下面的日志证实了步骤5）的猜想。 ■附录：下面是 gst_alsasink_write() 和 gst_alsasink_reset() 函数的代码。12345678910111213141516171819202122232425262728293031323334static voidgst_alsasink_reset (GstAudioSink * asink)&#123; GstAlsaSink *alsa; gint err; alsa = GST_ALSA_SINK (asink); GST_ALSA_SINK_LOCK (asink); GST_DEBUG_OBJECT (alsa, "drop"); CHECK (snd_pcm_drop (alsa-&gt;handle), drop_error); GST_DEBUG_OBJECT (alsa, "prepare"); CHECK (snd_pcm_prepare (alsa-&gt;handle), prepare_error); GST_DEBUG_OBJECT (alsa, "reset done"); GST_ALSA_SINK_UNLOCK (asink); return; /* ERRORS */drop_error: &#123; GST_ERROR_OBJECT (alsa, "alsa-reset: pcm drop error: %s", snd_strerror (err)); GST_ALSA_SINK_UNLOCK (asink); return; &#125;prepare_error: &#123; GST_ERROR_OBJECT (alsa, "alsa-reset: pcm prepare error: %s", snd_strerror (err)); GST_ALSA_SINK_UNLOCK (asink); return; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static gintgst_alsasink_write (GstAudioSink * asink, gpointer data, guint length)&#123; GstAlsaSink *alsa; gint err; gint cptr; guint8 *ptr = data; alsa = GST_ALSA_SINK (asink); if (alsa-&gt;iec958 &amp;&amp; alsa-&gt;need_swap) &#123; guint i; guint16 *ptr_tmp = (guint16 *) ptr; GST_DEBUG_OBJECT (asink, "swapping bytes"); for (i = 0; i &lt; length / 2; i++) &#123; ptr_tmp[i] = GUINT16_SWAP_LE_BE (ptr_tmp[i]); &#125; &#125; GST_LOG_OBJECT (asink, "received audio samples buffer of %u bytes", length); cptr = length / alsa-&gt;bpf; GST_ALSA_SINK_LOCK (asink); while (cptr &gt; 0) &#123; /* start by doing a blocking wait for free space. Set the timeout * to 4 times the period time */ err = snd_pcm_wait (alsa-&gt;handle, (4 * alsa-&gt;period_time / 1000)); if (err &lt; 0) &#123; GST_DEBUG_OBJECT (asink, "wait error, %d", err); &#125; else &#123; GST_DELAY_SINK_LOCK (asink); err = snd_pcm_writei (alsa-&gt;handle, ptr, cptr); GST_DELAY_SINK_UNLOCK (asink); &#125; GST_DEBUG_OBJECT (asink, "written %d frames out of %d", err, cptr); if (err &lt; 0) &#123; GST_DEBUG_OBJECT (asink, "Write error: %s", snd_strerror (err)); if (err == -EAGAIN) &#123; continue; &#125; else if (err == -ENODEV) &#123; goto device_disappeared; &#125; else if (xrun_recovery (alsa, alsa-&gt;handle, err) &lt; 0) &#123; goto write_error; &#125; continue; &#125; ptr += snd_pcm_frames_to_bytes (alsa-&gt;handle, err); cptr -= err; &#125; GST_ALSA_SINK_UNLOCK (asink); return length - (cptr * alsa-&gt;bpf);write_error: &#123; GST_ALSA_SINK_UNLOCK (asink); return length; /* skip one period */ &#125;device_disappeared: &#123; GST_ELEMENT_ERROR (asink, RESOURCE, WRITE, (_("Error outputting to audio device. " "The device has been disconnected.")), (NULL)); goto write_error; &#125;&#125;]]></content>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局变量导致fwrite崩溃问题分析]]></title>
    <url>%2F2020%2F11%2F26%2F%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AF%BC%E8%87%B4fwrite%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[■问题描述项目Carlife语音识别率不高，录音有卡顿，偶发程序崩溃。 ■原因直接原因：fwrite的文件句柄被覆盖，写文件的时候引发程序崩溃。 根本原因：函数重入导致全局变量设定不正确。引起memcpy拷贝数据的时候将buffer数组写穿，内存越界。 ■分析过程好久没有Dump解析了，用这次机会来练练手，废话不多说，开搞。 1.解析Dump的第一步，不用说bt查看栈的回溯。12345678(gdb) bt#0 __GI__IO_fwrite (buf=0x6ab18 &lt;VrPackageBuffer&gt;, size=1, count=1024, fp=0xfb0afbc4) at iofwrite.c:41#1 0x0003200a in CarlifeMicComponent::CaptureCallBack ( pAppleHandle=&lt;optimized out&gt;, inBuffer=0xaf641050, inLen=4000) at /home/dingyu/Workspace/CarLifeDaemon/src/CarlifeMicComponent.cpp:84#2 0xb6d32e0a in ?? ()Backtrace stopped: previous frame identical to this frame (corrupt stack?) 这个结果看，fp=0xfb0afbc4很可疑，哪有文件句柄这么大的。 2.接下来我们看一下当前栈帧的寄存器信息。1234567891011121314151617181920212223(gdb) info rr0 0x6ab18 437016r1 0x1 1r2 0x400 1024r3 0xfb0afbc4 4211801028r4 0xfb0afbc4 4211801028r5 0x400 1024r6 0x0 0r7 0x6aa08 436744r8 0xfa0 4000r9 0xaf641050 2942570576r10 0x6ab18 437016r11 0x0 0r12 0x6a5c8 435656sp 0xab5ce6c0 0xab5ce6c0lr 0x3200b 204811pc 0xb6865bd4 0xb6865bd4 &lt;__GI__IO_fwrite+16&gt;cpsr 0x200f0030 537854000r12 0x6a5c8 435656sp 0xab5ce6c0 0xab5ce6c0lr 0x3200b 204811#pc 0xb6865bd4 0xb6865bd4 &lt;__GI__IO_fwrite+16&gt;cpsr 0x200f0030 537854000 3.下一跳是什么导致崩溃的。1234567891011121314(gdb) disassemble 0xb6865bd4Dump of assembler code for function __GI__IO_fwrite: 0xb6865bc4 &lt;+0&gt;: stmdb sp!, &#123;r4, r5, r6, r7, r8, r9, lr&#125; 0xb6865bc8 &lt;+4&gt;: mul.w r5, r2, r1 0xb6865bcc &lt;+8&gt;: sub sp, #12 0xb6865bce &lt;+10&gt;: cmp r5, #0 0xb6865bd0 &lt;+12&gt;: beq.n 0xb6865cb2 &lt;__GI__IO_fwrite+238&gt; 0xb6865bd2 &lt;+14&gt;: mov r4, r3#=&gt; 0xb6865bd4 &lt;+16&gt;: ldr r3, [r3, #0] 0xb6865bd6 &lt;+18&gt;: mov r6, r0 0xb6865bd8 &lt;+20&gt;: mov r8, r2 0xb6865bda &lt;+22&gt;: mov r7, r1 0xb6865bdc &lt;+24&gt;: ands.w r3, r3, #32768 ; 0x8000 0xb6865be0 &lt;+28&gt;: bne.n 0xb6865c22 &lt;__GI__IO_fwrite+94&gt; 这句话的意思是: 将存储器地址为r3+0的字数据读入寄存器r3 4.我们来访问一下寄存器r3中地址存放的东西。12(gdb) x/x 0xfb0afbc40xfb0afbc4: Cannot access memory at address 0xfb0afbc4 尼玛，居然不能访问，看来是文件句柄被什么覆盖了。 5.被什么覆盖了呢？这下我们要看一下文件句柄在代码里面的位置，无非是被它的邻居覆盖了。CarlifeMicComponent.cpp123456789static char SpeakerInBuffer[MIC_VCP_BUFFER_SIZE + 1];static char MicInBuffer[MIC_VCP_BUFFER_SIZE + 1];static char AecOutBuffer[MIC_VCP_BUFFER_SIZE + 1];static char VrPackageBuffer[DEF_VR_PACKAGE_LENTH + MIC_VCP_BUFFER_SIZE + 1];static FILE *fpMicOrg = NULL;static FILE *fpMicOut = NULL;static const char *pEnv = NULL; 文件句柄是全局静态变量，应该是全局区域的东西把它覆盖了，基本可以排除堆和栈上的数据覆盖文件句柄。上面4个静态全局数组的嫌疑最大。 6.接下来该干什么呢？毫无疑问，把内存中全局变量区域的内容都打印出来。怎么打印呢？还记得bt打印栈回溯额时候fwrite的入参吗？12#0 __GI__IO_fwrite (buf=0x6ab18 &lt;VrPackageBuffer&gt;, size=1, count=1024, fp=0xfb0afbc4) at iofwrite.c:41 这个不就是全局变量区域的地址嘛。好的，我们一步步吧所有变量的值都打印出来，方法比较死板，就是不停的打。往0x6ab18这块内存的上面，下面都打印出来看看。 打印出来整理一下，大概是这样的：(为了看的更清楚，字体隔行变灰)12345678910111213141516170x6aa08 &lt;_ZL11MicInBuffer&gt;: 0xfc98fda2......0x6ab08 &lt;_ZL11MicInBuffer+256&gt;: 0x00000100#0x6ab0c &lt;_ZL8fpMicOrg&gt;: 0xb0113b500x6ab10 &lt;_ZL11bECNREnable&gt;: 0x00000000#0x6ab14 &lt;_ZZN19CarlifeMicComponent15CaptureCallBackEPvPKviE12iVrDataIndex&gt;: 0x000006000x6ab18 &lt;_ZL15VrPackageBuffer&gt;: 0xfe32fa9f 0xfb05ff0b 0xfbdbfe75 0xfd14fdf7.......0x6b018 &lt;_ZL15VrPackageBuffer+1280&gt;: 0xfc98fda2 0xfd12fd81 0xfb0afbc4 0xfd94fbfe#0x6b020 &lt;_ZL8fpMicOut&gt;: 0xfb0afbc40x6b024 &lt;_ZZN19CarlifeMicComponent15CaptureCallBackEPvPKviE15iValidDataIndex&gt;: 0xfd94fbfe#0x6b028 &lt;_ZL15RecodeStartFlag&gt;: 0xfee7fc7e0x6b02c &lt;_ZL15pCarlifeService&gt;: 0xfff90124#0x6b030 &lt;_ZL4pEnv&gt;: 0xffc000e70x6b034 &lt;_ZL15SpeakerInBuffer&gt;: 0x00a50016......0x6b134 &lt;_ZL15SpeakerInBuffer+256&gt;: 0x00000000 凶手出来了iVrDataIndex 看代码这个变量不应该超过1024个字节，代码里面只有一处赋值，并且一到1024个字节就至0了。1234567891011121314151617181920&#123; //DEBUG("cpn: %d\n", MIC_VCP_BUFFER_SIZE); memcpy(VrPackageBuffer + iVrDataIndex, MicInBuffer, MIC_VCP_BUFFER_SIZE);&#125;iVrDataIndex += MIC_VCP_BUFFER_SIZE;if(iVrDataIndex &gt;= DEF_VR_PACKAGE_LENTH)&#123; DEBUG("%s: %d!\n", bECNREnable?"cpe":"cpn", DEF_VR_PACKAGE_LENTH); pTempInstance-&gt;sendVRRecordData(VrPackageBuffer, DEF_VR_PACKAGE_LENTH, 0); if((true == bSavePcmEnable) &amp;&amp; (NULL != fpMicOut)) &#123; PRINT("fp_write:%p\n",fpMicOut); fwrite(VrPackageBuffer, 1, DEF_VR_PACKAGE_LENTH, fpMicOut); //fwrite(MicInBuffer, 1, MIC_VCP_BUFFER_SIZE, fpMicOut); &#125; iVrDataIndex = 0;&#125; 唯一的可能性是这个函数被同时多次调用，又是全局变量惹的祸。 其实后面还有很多工作要做，比如证实iVrDataIndex变量没有问题，没有被覆盖。算一下0x00000600的十进制1536，正好是256的6倍。这下放心了。如果你是个完美主义者，可以这样做，打印从0x6ab18 地址往后打印1535个字节。你会发现最后停在SpeakerInBuffer数组中，之后的数据都是0，完全符合代码逻辑。 0x6ab14 : 0x00000600]]></content>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于解码Carlife的h264视频流时程序Dump的调查]]></title>
    <url>%2F2020%2F11%2F26%2F%E5%85%B3%E4%BA%8E%E8%A7%A3%E7%A0%81Carlife%E7%9A%84h264%E8%A7%86%E9%A2%91%E6%B5%81%E6%97%B6%E7%A8%8B%E5%BA%8FDump%E7%9A%84%E8%B0%83%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[关于解码Carlife的h264视频流时程序Dump的调查■现象carlife黑屏。 ■再现步骤1.Iphone手机carlife版本更新至6.0及以上（5.9版本的手机carlife没有此现象） 2.A7项目有carlife功能的车机 （目前尝试了其他项目的A7车机均有此现象。I6平台的项目或使用PC软件播放Carlife的h264数据没有此现象） 3.连接carlife成功后，点击手机home键退到主界面，车机carlife功能黑屏（程序崩溃） ■根本原因直接原因：通过捕获Core文件，使用gdb调试，发现omx代码调用gstreamer接口一路调用到__memcpy_neon时程序Dump。 memcpy拷贝的源地址是非法的地址。 123456789101112131415L127: memcpy (dinfo.data, sinfo.data +offset, size);(gdb) p sinfo$1 = &#123;memory = 0xaf704da0, flags =GST_MAP_READ, data = 0xac167000 &lt;error: Cannot accessmemory at address 0xac167000&gt;, ★非法地址size = 559104, maxsize = 559104, user_data= &#123;0xb6fceab8, 0xb65a019b, 0xb683fda0, 0xb659c0e0&#125;, _gst_reserved =&#123;0x1, 0x7270e000, 0xaca77688, 0x0&#125;&#125; 诱因： 在对Carlife传输给车机的H264码流进行解码时， 我们发现SPS信息中level-id字段会随着Carlife应用在前后台改变而改变。 具体说： Carlife手机应用在前台时SPS信息：00 00 0001 27 42 00 1F &lt;—（level-id：1F） Carlife手机应用在后台时SPS信息：00 00 0001 27 42 00 20 &lt;—（level-id：20） 通过与高通沟通，得知Level 3.1（level-id：1F）和3.2（level-id：20） 所支持的视频解析度范围不同，解码器一般会通过该值进行重新配置。 相同解析度的情况下，如果从level 3.1 改成level 3.2不利于解码的稳定性。 根本原因:高通调查后承认自己解码器的Bug，提供walkaround方案。没有考虑视频播放过程中重新配置解码器的情况。 ■调查详细调试小插曲 一开始直接使用gdb解析CoreDump的时候发现，bt打出来的信息都是？号，无疑这是因为我们的程序没有带-g编译参数，没有符号导致的。 加完-g参数重新编译后，可以完整的显示出了堆栈信息，但是没有行号信息。从gdb的提示信息可以看出，符号是正确加载了，很奇怪。 经过很多尝试之后，决定尝试替换车机里其他人拷贝进去的gdb，使用我在A7平台下编译生成的gdb命令，这下显示了所有想要的东西。 调试开始下面开始展示真正的实力了：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173# gdb /usr/app/carlife/CarlifeDaemon ./TinyVpuDec\:src_14988678226_2254.coreCore was generated by `/usr/app/carlife/CarlifeDaemon -i'.Program terminated with signal SIGSEGV, Segmentation fault.#0 __memcpy_neon () at ../ports/sysdeps/arm/armv7/multiarch/memcpy_impl.S:568568 ../ports/sysdeps/arm/armv7/multiarch/memcpy_impl.S: No such file or directory.(gdb) bt#0 __memcpy_neon () at ../ports/sysdeps/arm/armv7/multiarch/memcpy_impl.S:568#1 0xb6855ff2 in _fallback_mem_copy (mem=0xaf704da0, offset=0, size=559104) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstallocator.c:127#2 0xb685e3a6 in gst_buffer_copy_into (dest=0xaf711020, src=0xaf705ca0, flags=(GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_META | GST_BUFFER_COPY_MEMORY | GST_BUFFER_COPY_DEEP), offset=0, size=559104) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstbuffer.c:498#3 0xb685e5bc in gst_buffer_copy_with_flags (buffer=0xaf705ca0, flags=(GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_META | GST_BUFFER_COPY_MEMORY | GST_BUFFER_COPY_DEEP)) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstbuffer.c:579#4 0xb65b4cbc in gst_base_sink_drain (basesink=0x15ff3f8) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/libs/gst/base/gstbasesink.c:4918#5 0xb65b8e78 in gst_base_sink_default_query (basesink=0x15ff3f8, query=0xaf70bc90) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/libs/gst/base/gstbasesink.c:4941#6 0xb688a152 in gst_pad_query (pad=pad@entry=0x15e2960, query=query@entry=0xaf70bc90)---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstpad.c:3831#7 0xb688a624 in gst_pad_peer_query (pad=0x15e2810, query=query@entry=0xaf70bc90) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstpad.c:3962#8 0xb03d1242 in gst_video_decoder_negotiate_pool (decoder=0x15f6158, caps=&lt;optimized out&gt;) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/video/gstvideodecoder.c:3696#9 0xb03d585a in gst_video_decoder_negotiate (decoder=decoder@entry=0x15f6158) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0-plugins-base/1.6-r0/git/gst-libs/gst/video/gstvideodecoder.c:3872#10 0xb032cd92 in gst_omx_video_dec_reconfigure_output_port ( crop_rect=0xb0111168, crop_rect=0xb0111168, self=0x15f6158) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gst-omx/1.2-r0/git/omx/gstomxvideodec.c:1722#11 gst_omx_video_dec_loop (self=0x15f6158) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gst-omx/1.2-r0/git/omx/gstomxvideodec.c:1956#12 0xb68ab9ce in gst_task_func (task=0xb01136b8)---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gsttask.c:331#13 0xb6d06410 in g_thread_pool_thread_proxy (data=&lt;optimized out&gt;) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/cortexa7hf-vfp-poky-linux-gnueabi/glib-2.0/1_2.40.0-r0/glib-2.40.0/glib/gthreadpool.c:307#14 0xb6d05d02 in g_thread_proxy (data=0xaf702b80) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/cortexa7hf-vfp-poky-linux-gnueabi/glib-2.0/1_2.40.0-r0/glib-2.40.0/glib/gthread.c:764#15 0xb6b5145e in start_thread (arg=0xaca78910) at pthread_create.c:314#16 0xb699dd9c in ?? () at ../ports/sysdeps/unix/sysv/linux/arm/nptl/../clone.S:92 from /lib/arm-linux-gnueabihf/libc.so.6Backtrace stopped: previous frame identical to this frame (corrupt stack?)(gdb) frame 1#1 0xb6855ff2 in _fallback_mem_copy (mem=0xaf704da0, offset=0, size=559104) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstallocator.c:127127 /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstallocator.c: No such file or directory.# 结合代码可以发现，程序执行L127: memcpy (dinfo.data, sinfo.data +offset, size);时Dump了# 这时我们需要看一下pc指针指向什么地方Dump的。于是我们查看寄存器的信息。(gdb) info rr0 0xac1f0058 2887712856r1 0xac167000 2887151616r2 0x88800 559104r3 0x0 0r4 0x88800 559104r5 0xac1f0008 2887712776r6 0xaf704da0 2943372704r7 0xb69064b4 3062916276r8 0x88800 559104r9 0xaca775f0 2896655856r10 0x0 0r11 0xaca77624 2896655908r12 0xac1f0058 2887712856sp 0xaca775b8 0xaca775b8lr 0xb6855ff3 -1232773133pc 0xb6855ff2 0xb6855ff2 &lt;_fallback_mem_copy+118&gt;cpsr 0x200e0030 537788464# 看下pc指向的是汇编哪一行(gdb) disassemble r 0xb68e52b4 &lt;+372&gt;: strne r3, [r12], #4 0xb68e52b8 &lt;+376&gt;: lsls r8, r8, #31 0xb68e52bc &lt;+380&gt;: ldrhcs r3, [r1], #2 0xb68e52c0 &lt;+384&gt;: ldrbne r8, [r1] 0xb68e52c4 &lt;+388&gt;: strhcs r3, [r12], #2 0xb68e52c8 &lt;+392&gt;: strbne r8, [r12] 0xb68e52cc &lt;+396&gt;: pop &#123;r8&#125; ; (ldr r8, [sp], #4) 0xb68e52d0 &lt;+400&gt;: bx lr=&gt; 0xb68e52d4 &lt;+404&gt;: vldr d3, [r1] 0xb68e52d8 &lt;+408&gt;: vldr d4, [r1, #64] ; 0x40 0xb68e52dc &lt;+412&gt;: vldr d5, [r1, #128] ; 0x80 0xb68e52e0 &lt;+416&gt;: vldr d6, [r1, #192] ; 0xc0 0xb68e52e4 &lt;+420&gt;: vldr d7, [r1, #256] ; 0x100 0xb68e52e8 &lt;+424&gt;: vldr d0, [r1, #8] 0xb68e52ec &lt;+428&gt;: vldr d1, [r1, #16]# 从汇编代码可以看出来，程序是加载 r1 寄存器中存放的地址时Dump了，访问了无法访问的内存。# 我们看下代码L127: memcpy (dinfo.data, sinfo.data +offset, size);再看一下我们数据的拷贝源是什么，很明显sinfo.data无法访问。(gdb) p sinfo$1 = &#123;memory = 0xaf704da0, flags = GST_MAP_READ, data = 0xac167000 &lt;error: Cannot access memory at address 0xac167000&gt;, size = 559104, maxsize = 559104, user_data = &#123;0xb6fceab8, 0xb65a019b, 0xb683fda0, 0xb659c0e0&#125;, _gst_reserved = &#123;0x1, 0x7270e000, 0xaca77688, 0x0&#125;&#125;# 让我们的显示变得漂亮一点(gdb) set print pretty on# 我们回到栈帧1，为什么要到栈帧1呢？栈帧0是memcpy函数，我们打印不了我们想要看的参数mem# 那我们为什么要看mem呢？很简单，sinfo是怎么来的，通过阅读代码是由mem拷贝过来的。(gdb) frame 1#1 0xb67ebff2 in _fallback_mem_copy (mem=0xaf604da8, offset=0, size=559104) at /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstallocator.c:127127 /Build_Directory/workspace/ZS11_Gerrit/A7_MR3/poky/build/tmp/work/atlas7_arm-poky-linux-gnueabi/gstreamer1.0/1.6-r0/git/gst/gstallocator.c: No such file or directory.(gdb) info rr0 0xac175058 2887209048r1 0xac0ec000 2886647808r2 0x88800 559104r3 0x0 0r4 0x88800 559104r5 0xac175008 2887208968r6 0xaf604da8 2942324136r7 0xb689c4b4 3062482100r8 0x88800 559104r9 0xac9fc5f0 2896152048r10 0x0 0r11 0xac9fc624 2896152100r12 0xac175058 2887209048sp 0xac9fc5b8 0xac9fc5b8lr 0xb67ebff3 -1233207309pc 0xb67ebff2 0xb67ebff2 &lt;_fallback_mem_copy+118&gt;cpsr 0x200e0030 537788464(gdb) p sinfo$4 = &#123; memory = 0xaf604da8, flags = GST_MAP_READ, data = 0xac0ec000 &lt;error: Cannot access memory at address 0xac0ec000&gt;, size = 559104, maxsize = 559104, user_data = &#123;0xb6f64ab8, 0xb653619b, 0xb67d5da0, 0xb65320e0&#125;, _gst_reserved = &#123;0x1, 0x8583b000, 0xac9fc688, 0x0&#125;&#125;(gdb) p *(GstMemorySystem *)(mem)$6 = &#123; mem = &#123; mini_object = &#123; type = 1980632, refcount = 3, lockstate = 131329, flags = 1, copy = 0xb6817489 &lt;_gst_memory_copy&gt;, dispose = 0xb0280055, free = 0xb6816f49 &lt;_gst_memory_free&gt;, n_qdata = 0, qdata = 0x0 &#125;, allocator = 0xaf60f048, parent = 0x0, maxsize = 559104, align = 0, offset = 0, size = 559104 &#125;, slice_size = 0, data = 0xaf610398 "\001", user_data = 0xac0ec000, ---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- notify = 0xffffffff, map_mode = 0&#125; 来，我们看看gstallocator.c:127的代码，gst_memory_map (mem, &amp;sinfo, GST_MAP_READ)在这个地方，给sinfo赋值了，具体怎么赋值的呢？我们需要深入到gst_memory_map 函数123456789101112131415161718192021222324252627282930313233343536373839404142gbooleangst_memory_map (GstMemory * mem, GstMapInfo * info, GstMapFlags flags)&#123; g_return_val_if_fail (mem != NULL, FALSE); g_return_val_if_fail (info != NULL, FALSE); if (!gst_memory_lock (mem, (GstLockFlags) flags)) goto lock_failed; info-&gt;flags = flags; info-&gt;memory = mem; info-&gt;size = mem-&gt;size; info-&gt;maxsize = mem-&gt;maxsize - mem-&gt;offset; if (mem-&gt;allocator-&gt;mem_map_full) info-&gt;data = mem-&gt;allocator-&gt;mem_map_full (mem, info, mem-&gt;maxsize); else info-&gt;data = mem-&gt;allocator-&gt;mem_map (mem, mem-&gt;maxsize, flags); // ★该函数 if (G_UNLIKELY (info-&gt;data == NULL)) goto error; info-&gt;data = info-&gt;data + mem-&gt;offset; return TRUE; /* ERRORS */lock_failed: &#123; GST_CAT_DEBUG (GST_CAT_MEMORY, "mem %p: lock %d failed", mem, flags); memset (info, 0, sizeof (GstMapInfo)); return FALSE; &#125;error: &#123; /* something went wrong, restore the orginal state again */ GST_CAT_ERROR (GST_CAT_MEMORY, "mem %p: subclass map failed", mem); gst_memory_unlock (mem, (GstLockFlags) flags); memset (info, 0, sizeof (GstMapInfo)); return FALSE; &#125;&#125; 12//gstallocator.c alloc-&gt;mem_map = (GstMemoryMapFunction) _sysmem_map; 123456//gstallocator.cstatic gpointer_sysmem_map (GstMemorySystem * mem, gsize maxsize, GstMapFlags flags)&#123; return mem-&gt;data;&#125; 一开始，以为就是这个函数，但是后来发现不是，思考了一下这个应该就是C语言实现多态的方式。那是怎么知道不是这个函数的呢？增加断点调试。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182(gdb) attach pid（CarlifeDaemon）(gdb) b gstallocator.c:106# 复现问题后继续运行到断点(gdb) c# 锁定当前线程，因为gstmemory.c中的函数会在很多地方调用到，不锁定的话会停在别的线程(gdb) set scheduler-locking on (gdb) b gstmemory.c:309(gdb) c# 为了能够进入mem_map函数调试，我在_sysmem_map函数处加了断点，但是死活进不去，于是我一步步，打印mem-&gt;allocator 的所有成员看看mem_map的函数地址。(gdb) p *(GstAllocator*)mem-&gt;allocator $4 = &#123; object = &#123; object = &#123; g_type_instance = &#123; g_class = 0xaf6138d0 &#125;, ref_count = 17, qdata = 0x2 &#125;, lock = &#123; p = 0xaf60a600, i = &#123;2942346752, 0&#125; &#125;, name = 0xaf60ccb0 "TinyVideoSink:pool:sink:allocator", parent = 0x0, flags = 66060304, control_bindings = 0x0, control_rate = 100000000, last_sync = 18446744073709551615, _gst_reserved = 0x0 &#125;, mem_type = 0xb02bafb8 "V4l2Memory", mem_map = 0xb029efe9, # 需要关注的函数地址---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- mem_unmap = 0xb029ef7d, mem_copy = 0xb6766f7d &lt;_fallback_mem_copy&gt;, mem_share = 0xb029fcc5, mem_is_span = 0xb029ef0d, mem_map_full = 0x0, mem_unmap_full = 0x0, _gst_reserved = &#123;0x0, 0x0&#125;, priv = 0xaf60d040&#125;No function contains specified address.(gdb) x 0xb029efe90xb029efe9: 0x924b146c# 其他调用的地方(gdb) p *(GstAllocator*)mem-&gt;allocator $6 = &#123; object = &#123; object = &#123; g_type_instance = &#123; g_class = 0x1c81ac8 &#125;, ref_count = 7, qdata = 0x2 &#125;, lock = &#123; p = 0x1c81b78, i = &#123;29891448, 0&#125; &#125;, name = 0x1c80950 "allocatorsysmem0", parent = 0x0, flags = 0, control_bindings = 0x0, control_rate = 100000000, last_sync = 18446744073709551615, _gst_reserved = 0x0 &#125;, mem_type = 0xb67db1d4 "SystemMemory", mem_map = 0xb67667dd &lt;_sysmem_map&gt;, # 需要关注的函数地址---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- mem_unmap = 0xb67667e1 &lt;_sysmem_unmap&gt;, mem_copy = 0xb6766a49 &lt;_sysmem_copy&gt;, mem_share = 0xb6766b65 &lt;_sysmem_share&gt;, mem_is_span = 0xb67667e5 &lt;_sysmem_is_span&gt;, mem_map_full = 0x0, mem_unmap_full = 0x0, _gst_reserved = &#123;0x0, 0x0&#125;, priv = 0x1c83c18&#125; 同样的函数指针，指向了不同的函数实现，然而这块代码我们没有，没有办法知道如何赋值的，只知道现在sinfo.data = 0xac0ec000是(GstMemorySystem )(mem)的user_data]]></content>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OTG_roleswitch]]></title>
    <url>%2F2020%2F11%2F26%2FOTG-roleswitch%2F</url>
    <content type="text"><![CDATA[OTG roleswitch(Apple CarPlay)关于roleswitch驱动层状态机变化流程插入时的状态 车机作为 a_host 手机作为 b_peripheral 车机枚举手机，完成正常的USB枚举。 roleswitch时的状态 车机发送私有协议（见下图）给手机，通知手机切成 b_host。 此时VBUS仍然是车机供电。手机会一直枚举车机。只要车机状态变更到 a_peripheral，就能枚举成功。 车机触发状态机进行状态机变换，最终切到 a_periphera l状态。 手机枚举车机，完成一次正常的USB枚举。 拔出后的状态 车机切回 a_wait_bcon 状态。 手机切回 b_wait_acon 状态。 OTG 状态机转换A Device状态机 B Device状态机 其他苹果roleswitch私有协议文档说明 ATS 抓包数据 内核状态机日志开关 一次完整的roleswitch过程日志1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 插入手机前[ 2318.493379] Set state: a_wait_bcon[ 2318.496097] usb 1-1: USB disconnect, device number 12# 插入手机[ 2321.151592] Set state: a_host[ 2321.424758] usb 1-1: new high-speed USB device number 13 using ci_hdrc[ 2321.578095] usb 1-1: New USB device found, idVendor=05ac, idProduct=12a8[ 2321.581955] usb 1-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3[ 2321.593696] usb 1-1: Product: iPhone[ 2321.594498] usb 1-1: Manufacturer: Apple Inc.[ 2321.603727] usb 1-1: SerialNumber: 2330bb40ef6c37782d9675fe9d086467f49f031e[ 2321.610365] usb 1-1: Second configuration choosed for Apple MFi device.[ 2321.627515] usb 1-1: 1:1: cannot get freq at ep 0x81[ 2321.650139] hid-generic 0003:05AC:12A8.000C: device has no listeners, quitting# 触发roleswitch[ 2348.700349] Set state: a_suspend[ 2348.700929] usb 1-1: USB disconnect, device number 13 q[ 2348.825643] Set state: a_peripherallatform/devices/ci_hdrc.0/inputs/a_bus_req [ 2348.826318] ci_hdrc ci_hdrc.0: remove, state 1[ 2348.830757] usb usb1: USB disconnect, device number 1[ 2348.847613] ci_hdrc ci_hdrc.0: USB bus 1 deregistered[ 2348.849891] ci_otg_start_host off [ 2348.853548] ci_otg_start_gadget on [ 2349.038270] g_ncm gadget: high-speed config #1: CDC Ethernet (NCM)[ 2349.041631] g_ncm gadget: source/sink enabled, alt intf 0[ 2349.046989] g_ncm gadget: init ncm ctrl 1[ 2349.050985] g_ncm gadget: notify speed 425984000# 拔出手机[ 2867.624758] g_ncm gadget: suspend[ 2868.123519] Set state: a_wait_bcon[ 2868.124092] g_ncm gadget: reset config[ 2868.127819] g_ncm gadget: ncm deactivated[ 2868.131941] ci_otg_start_gadget off [ 2868.136118] ci_hdrc ci_hdrc.0: EHCI Host Controller[ 2868.140452] ci_hdrc ci_hdrc.0: new USB bus registered, assigned bus number 1[ 2868.164755] ci_hdrc ci_hdrc.0: USB 2.0 started, EHCI 1.00[ 2868.167567] usb usb1: New USB device found, idVendor=1d6b, idProduct=0002[ 2868.174095] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1[ 2868.181399] usb usb1: Product: EHCI Host Controller[ 2868.186288] usb usb1: Manufacturer: Linux 3.18.41 ehci_hcd[ 2868.191621] usb usb1: SerialNumber: ci_hdrc.0[ 2868.198254] hub 1-0:1.0: USB hub found[ 2868.199797] hub 1-0:1.0: 1 port detected[ 2868.206021] ci_otg_start_host on 内核各种状态的查询方法12345678910111213141516171819202122232425root@atlas7-arm:/sys/kernel/debug/ci_hdrc.0# cat otg OTG state: a_hosta_bus_drop: 0a_bus_req: 1a_srp_det: 0a_vbus_vld: 1b_conn: 1adp_change: 0power_up: 0a_bus_resume: 0a_bus_suspend: 0a_conn: 0b_bus_req: 0b_bus_suspend: 0b_se0_srp: 0b_ssend_srp: 0b_sess_vld: 0b_srp_done: 0drv_vbus: 1loc_conn: 0loc_sof: 1adp_prb: 0id: 0protocol: 1 内核个节点含义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-platform-chipidea-usb-otgWhat: /sys/bus/platform/devices/ci_hdrc.0/inputs/a_bus_reqDate: Feb 2014Contact: Li Jun &lt;jun.li@nxp.com&gt;Description: Can be set and read. Set a_bus_req(A-device bus request) input to be 1 if the application running on the A-device wants to use the bus, and to be 0 when the application no longer wants to use the bus(or wants to work as peripheral). a_bus_req can also be set to 1 by kernel in response to remote wakeup signaling from the B-device, the A-device should decide to resume the bus. Valid values are &quot;1&quot; and &quot;0&quot;. Reading: returns 1 if the application running on the A-device is using the bus as host role, otherwise 0.What: /sys/bus/platform/devices/ci_hdrc.0/inputs/a_bus_dropDate: Feb 2014Contact: Li Jun &lt;jun.li@nxp.com&gt;Description: Can be set and read The a_bus_drop(A-device bus drop) input is 1 when the application running on the A-device wants to power down the bus, and is 0 otherwise, When a_bus_drop is 1, then the a_bus_req shall be 0. Valid values are &quot;1&quot; and &quot;0&quot;. Reading: returns 1 if the bus is off(vbus is turned off) by A-device, otherwise 0.What: /sys/bus/platform/devices/ci_hdrc.0/inputs/b_bus_reqDate: Feb 2014Contact: Li Jun &lt;jun.li@nxp.com&gt;Description: Can be set and read. The b_bus_req(B-device bus request) input is 1 during the time that the application running on the B-device wants to use the bus as host, and is 0 when the application no longer wants to work as host and decides to switch back to be peripheral. Valid values are &quot;1&quot; and &quot;0&quot;. Reading: returns if the application running on the B device is using the bus as host role, otherwise 0.What: /sys/bus/platform/devices/ci_hdrc.0/inputs/a_clr_errDate: Feb 2014Contact: Li Jun &lt;jun.li@nxp.com&gt;Description: Only can be set. The a_clr_err(A-device Vbus error clear) input is used to clear vbus error, then A-device will power down the bus. Valid value is &quot;1&quot;]]></content>
      <tags>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ID3信息]]></title>
    <url>%2F2020%2F11%2F26%2FID3%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[ID3信息Taglib 网址：https://taglib.org/ 代码：https://github.com/xuleilx/taglib/ 实例：https://github.com/xuleilx/taglib/tree/master/examples 新增读取图片实例]]></content>
      <tags>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2020%2F11%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[虚拟内存管理]]></title>
    <url>%2F2020%2F10%2F29%2F%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-md%2F</url>
    <content type="text"><![CDATA[虚拟内存管理虚拟内存虚拟内存的起因 存储器层次结构 访问时间 Registers 1 nsec Cache 2 nsec Main Memory 10 nsec Magnetic disk 10 msec Magnetic tape 100 sec 覆盖技术覆盖技术：相互之间没有调用关系的程序模块之间。 1.对于一个进程，不需要一开始就把程序的全部指令和数据都装入内存再执行。2.程序划分为若干个功能上相对独立的程序段，按照程序逻辑结构让那些不需要同时执行的程序段共享同一块内存区3.当有关程序段的先头程序段已经执行结束后，再把后续程序段从外存调入内存覆盖前面的程序段 交换技术swap技术：swap out、swap in。内存和硬盘之间。 对象是进程，等待状态的进程驻留内存会造成存储空间的浪费。因此，有必要把处于等待状态的进程换出内存。 虚存技术利用程序的局部性。一页4K大小。基本特征：1.大的用户空间：物理内存+外存2.部分交换3.不连续性：分配不连续，使用不连续 后备存储Backing Store（二级存储）数据，代码，动态库swap file ：程序运行过程中产生的数据 页面置换算法局部页面置换 最优置换算法（OPT）：预测未来，难以实现 先进先出（FIFO）：最简单，性能差 最近最久未使用（LRU）：由过去预测未来，接近OPT，开销大。 时钟算法（Clock）：性能接近LRU，高效，开销小 二次机会法（Enhanced Clock）：Clock算法的改进，增加读写位判断，减少写页被置换 最不常用算法（LFU） Belady现象：一些算法会导致导致不会因为物理页增加，内存访问减少。有时候反而增加内存访问。一般来讲，物理页增加，访问内存的次数会减少，极限情况物理页包含了所有内存。 全局页面置换 工作集置换算法 缺页率置换算法 针对多个程序同时运行，全局页面置换算法优于局部页面置换算法，全局页面置换算法可以动态调整分配给每个程序内存页的大小 内存抖动 进程太多，分配给每个进程的物理页面太少，不能包含工作集 造成大量缺页，频繁置换 进程运行速度变慢 操作系统需要在并发水平和缺页率之间达到一个平衡 选择适当的程序数目和进程需要的物理页数目 LAB3实验12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 给未被映射的地址映射上物理页/*LAB3 EXERCISE 1: YOUR CODE * Maybe you want help comment, BELOW comments can help you finish the code * * Some Useful MACROs and DEFINEs, you can use them in below implementation. * MACROs or Functions: * get_pte : get an pte and return the kernel virtual address of this pte for la * if the PT contians this pte didn't exist, alloc a page for PT (notice the 3th parameter '1') * pgdir_alloc_page : call alloc_page &amp; page_insert functions to allocate a page size memory &amp; setup * an addr map pa&lt;---&gt;la with linear address la and the PDT pgdir * DEFINES: * VM_WRITE : If vma-&gt;vm_flags &amp; VM_WRITE == 1/0, then the vma is writable/non writable * PTE_W 0x002 // page table/directory entry flags bit : Writeable * PTE_U 0x004 // page table/directory entry flags bit : User can access * VARIABLES: * mm-&gt;pgdir : the PDT of these vma * *//* * try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT. * (notice the 3th parameter '1') */// 1. 页目录中找页表，如果没有就创建一个页表// 2. 页表中查找包含addr地址的页表项if ( (ptep = get_pte( mm-&gt;pgdir, addr, 1 ) ) == NULL )&#123; cprintf( "get_pte in do_pgfault failed\n" ); goto failed;&#125;// 如果找到的页表项为空，分配页并映射到页表中if ( *ptep == 0 ) /* if the phy addr isn't exist, then alloc a page &amp; map the phy addr with logical addr */&#123; if ( pgdir_alloc_page( mm-&gt;pgdir, addr, perm ) == NULL ) &#123; cprintf( "pgdir_alloc_page in do_pgfault failed\n" ); goto failed; &#125;&#125;else &#123; // 找到页表项 /*LAB3 EXERCISE 2: YOUR CODE * Now we think this pte is a swap entry, we should load data from disk to a page with phy addr, * and map the phy addr with logical addr, trigger swap manager to record the access situation of this page. * * Some Useful MACROs and DEFINEs, you can use them in below implementation. * MACROs or Functions: * swap_in(mm, addr, &amp;page) : alloc a memory page, then according to the swap entry in PTE for addr, * find the addr of disk page, read the content of disk page into this memroy page * page_insert ： build the map of phy addr of an Page with the linear addr la * swap_map_swappable ： set the page swappable */ /* * if this pte is a swap entry, then load data from disk to a page with phy addr * and call page_insert to map the phy addr with logical addr */ // 如果找到的页表项是需要swap的，swap it if ( swap_init_ok ) &#123; struct Page *page = NULL; if ( (ret = swap_in( mm, addr, &amp;page ) ) != 0 ) &#123; cprintf( "swap_in in do_pgfault failed\n" ); goto failed; &#125; page_insert( mm-&gt;pgdir, page, addr, perm ); swap_map_swappable( mm, addr, page, 1 ); &#125;else &#123; cprintf( "no swap_init_ok but ptep is %x, failed\n", *ptep ); goto failed; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// 基于FIFO的页面替换算法/* * (3)_fifo_map_swappable: According FIFO PRA, we should link the most recent arrival page at the back of pra_list_head qeueue */static int_fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)&#123; list_entry_t *head=(list_entry_t*) mm-&gt;sm_priv; list_entry_t *entry=&amp;(page-&gt;pra_page_link); assert(entry != NULL &amp;&amp; head != NULL); //record the page access situlation /*LAB3 EXERCISE 2: YOUR CODE*/ //(1)link the most recent arrival page at the back of the pra_list_head qeueue. list_add(head, entry); return 0;&#125;/* * (4)_fifo_swap_out_victim: According FIFO PRA, we should unlink the earliest arrival page in front of pra_list_head qeueue, * then set the addr of addr of this page to ptr_page. */static int_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)&#123; list_entry_t *head=(list_entry_t*) mm-&gt;sm_priv; assert(head != NULL); assert(in_tick==0); /* Select the victim */ /*LAB3 EXERCISE 2: YOUR CODE*/ //(1) unlink the earliest arrival page in front of pra_list_head qeueue //(2) set the addr of addr of this page to ptr_page /* Select the tail */ list_entry_t *le = head-&gt;prev; assert(head!=le); struct Page *p = le2page(le, pra_page_link); list_del(le); assert(p !=NULL); *ptr_page = p; return 0;&#125;]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物理内存管理]]></title>
    <url>%2F2020%2F10%2F25%2F%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[物理内存管理机制虚拟内存虚拟内存存在的意义：抽象，隔离，移植。MCU这类单进程的，一般用物理地址。 现代操作系统肯定要支持多任务，同时运行多个进程。如果直接为进程分配物理内存，就要面临诸多问题：每个进程分配多少物理内存？分配少不够用，分配多则没几个进程物理内存就耗尽了。如果动态分配物理内存，则进程拿到的内存在空间上不连续，系统还要解决碎片的问题。还有安全问题，怎么保证一个进程不越界访问其它进程甚至是操作系统自己的内存，一个程序的错误可能导致整个系统的错误。 虚拟内存系统，是对内存系统和文件系统（可选）的抽象。 将内存资源进行了抽象：可以按需为进程分配 page，甚至可以把长时间不用的 page 缓存在磁盘上节省物理内存；由于每个进程有自己的空间，做到了很好的隔离。而每个进程都以为自己有连续的内存空间可以使用。 物理内存不够的情况下，利用磁盘系统，虽然性能会降低，但是不至于程序无法运行；而增加新的物理内存，就能使程序性能提升。 保护80X86支持两类保护： 任务之间保护 80X86 使用的方法是通过把每个任务放置在不同的虚拟地址空间中，并给予每个任务不同的逻辑地址到物理地址的变换映射。每个任务中的地址变换功能被定义成一个任务中的逻辑地址映射到物理内存的一部分区域，而另一个任务中的逻辑地址映射到物理内存中的不同区域中。这样，因为一个任务不可能生成能够映射到其他任务逻辑地址对应使用的物理内存部分，所以所有任务都被隔绝开了。 特权级保护 特权级 0 是最高的特权级别,用于可靠性最高的程序. 通常,操作系统是为所有的程序服务的,它的可靠性最高,并且操作系统要负责对软硬件的控制,所以操作系统的主体必须拥有特权级 0. 特权级 1, 2 是次于最高的特权级别(特权级 2 的特权级低于特权级 1),用于可靠性不如操作系统(或说是内核 Kernel)的系统服务程序.比较典型的是设备驱动程序. 特权级 3是最低的特权级别,用于可靠性最低的程序.应用程序的可靠性被视为最低的,通常不需要直接访问硬件和一些敏感的系统资源,调用设备驱动程序或操作系统实例能完成绝大多数工作. 分段分页分段机制把逻辑地址转换成线性地址，而分页则把线性地址转换成物理地址。 双重映射其实是毫无必要的，也使映射的过程变得不容易理解。 分页 分段 目的 页是信息的物理单位，分页是为实现离散分配方式，以减少内存的外零头，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要 是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 长度 页的大小固定且由系统决定，由系统把逻辑地址化分为页号和页内地址两部分，由机器硬件实现，因而在系统中只能有一种大小的页面 段的长度不固定，决定于用户编写的程序，通常由编译程序在对流程序进行编译时，根据信息的性质来划分 地址空间 作业地址空间是一维的，即单一的线性地址空间，程序员只需要利用一个记忆符，即可表示一个地址。 作业地址空间是二维的，程序员在标识一个地址时，即需给出段名，又需给出段内地址 碎片 有内部碎片，无外部碎片 有外部碎片，无内部碎片 共享和动态链表 不容易实现 容易实现 图 4 段页式管理总体框架图 ​ 分段 分页​ ↓​ ↓逻辑地址 - 线性地址（虚拟地址） - 物理地址 图 5 分页机制管理 多级页表避免把全部页表一直保存在内存中是多级页表的关键所在。特别是那些不需要的页表就不应该保留。通过一个顶级页表为真正有用的页表提供索引，这是我所理解的二级页表的本质。 32位计算机，4GB内存，每页大小4KB($2^{12}$)，需要$2^{20}$个页表项。每页4KB($2^{12}$)需要用到$2^{8}$个页来存放这些页表项。一般计算机有1M的cache存放这些页表项。 对应用程序来说段选择符是作为指针变量的一部分而可见，但选择符的值通常由链接编辑器或链接加载器进行设置或修改，而非应用程序 物理内存管理步骤探测系统物理内存布局一般来说，获取内存大小的方法由 BIOS 中断调用和直接探测两种。BIOS 中断调用方法是一般只能在实模式下完成，而直接探测方法必须在保护模式下完成。通过 BIOS 中断获取内存布局有三种方式，都是基于INT 15h中断，分别为88h e801h e820h。但是并非在所有情况下这三种方式都能工作。在 Linux kernel 里，采用的方法是依次尝试这三种方法。而在本实验中，我们通过e820h中断获取内存信息。因为e820h中断必须在实模式下使用，所以我们在 bootloader 进入保护模式之前调用这个 BIOS 中断，并且把 e820 映射结构保存在物理地址0x8000处。 实现物理内存探测 物理内存探测是在bootasm.S中实现的，相关代码很短，如下所示： 1234567891011121314151617181920212223242526272829probe_memory://对0x8000处的32位单元清零,即给位于0x8000处的//struct e820map的成员变量nr_map清零 movl $0, 0x8000 xorl %ebx, %ebx//表示设置调用INT 15h BIOS中断后，BIOS返回的映射地址描述符的起始地址 movw $0x8004, %distart_probe: movl $0xE820, %eax // INT 15的中断调用参数//设置地址范围描述符的大小为20字节，其大小等于struct e820map的成员变量map的大小 movl $20, %ecx//设置edx为534D4150h (即4个ASCII字符“SMAP”)，这是一个约定 movl $SMAP, %edx//调用int 0x15中断，要求BIOS返回一个用地址范围描述符表示的内存段信息 int $0x15//如果eflags的CF位为0，则表示还有内存段需要探测 jnc cont//探测有问题，结束探测 movw $12345, 0x8000 jmp finish_probecont://设置下一个BIOS返回的映射地址描述符的起始地址 addw $20, %di//递增struct e820map的成员变量nr_map incl 0x8000//如果INT0x15返回的ebx为零，表示探测结束，否则继续探测 cmpl $0, %ebx jnz start_probefinish_probe: 上述代码正常执行完毕后，在0x8000地址处保存了从BIOS中获得的内存分布信息，此信息按照struct e820map的设置来进行填充。这部分信息将在bootloader启动ucore后，由ucore的page_init函数来根据struct e820map的memmap（定义了起始地址为0x8000）来完成对整个机器中的物理内存的总体管理。 BIOS通过系统内存映射地址描述符（Address Range Descriptor）格式来表示系统物理内存布局，其具体表示如下： 1234Offset Size Description00h 8字节 base address #系统内存块基地址08h 8字节 length in bytes #系统内存大小10h 4字节 type of address range #内存类型 看下面的(Values for System Memory Map address type) 123456Values for System Memory Map address type:01h memory, available to OS02h reserved, not available (e.g. system ROM, memory-mapped device)03h ACPI Reclaim Memory (usable by OS after reading ACPI tables)04h ACPI NVS Memory (OS is required to save this memory between NVS sessions)other not defined yet -- treat as Reserved INT15h BIOS中断的详细调用参数: 12345eax：e820h：INT 15的中断调用参数；edx：534D4150h (即4个ASCII字符“SMAP”) ，这只是一个签名而已；ebx：如果是第一次调用或内存区域扫描完毕，则为0。 如果不是，则存放上次调用之后的计数值；ecx：保存地址范围描述符的内存大小,应该大于等于20字节；es:di：指向保存地址范围描述符结构的缓冲区，BIOS把信息写入这个结构的起始地址。 此中断的返回值为: 1234567891011eflags的CF位：若INT 15中断执行成功，则不置位，否则置位；eax：534D4150h (&apos;SMAP&apos;) ；es:di：指向保存地址范围描述符的缓冲区,此时缓冲区内的数据已由BIOS填写完毕ebx：下一个地址范围描述符的计数地址ecx ：返回BIOS往ES:DI处写的地址范围描述符的字节大小ah：失败时保存出错代码 这样，我们通过调用INT 15h BIOS中断，递增di的值（20的倍数），让BIOS帮我们查找出一个一个的内存布局entry，并放入到一个保存地址范围描述符结构的缓冲区中，供后续的ucore进一步进行物理内存管理。这个缓冲区结构定义在memlayout.h中： 12345678struct e820map &#123; int nr_map; struct &#123; long long addr; long long size; long type; &#125; map[E820MAX];&#125;; 链接地址/虚地址/物理地址/加载地址以及edata/end/text的含义 链接脚本简介 ucore kernel各个部分由组成kernel的各个.o或.a文件构成，且各个部分在内存中地址位置由ld工具根据kernel.ld链接脚本（linker script）来设定。ld工具使用命令-T指定链接脚本。链接脚本主要用于规定如何把输入文件（各个.o或.a文件）内的section放入输出文件（lab2/bin/kernel，即ELF格式的ucore内核）内， 并控制输出文件内各部分在程序地址空间内的布局。下面简单分析一下/lab2/tools/kernel.ld，来了解一下ucore内核的地址布局情况。kernel.ld的内容如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* Simple linker script for the ucore kernel. See the GNU ld &apos;info&apos; manual (&quot;info ld&quot;) to learn the syntax. */OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)OUTPUT_ARCH(i386)ENTRY(kern_entry)SECTIONS &#123; /* Load the kernel at this address: &quot;.&quot; means the current address */ . = 0xC0100000; .text : &#123; *(.text .stub .text.* .gnu.linkonce.t.*) &#125; PROVIDE(etext = .); /* Define the &apos;etext&apos; symbol to this value */ .rodata : &#123; *(.rodata .rodata.* .gnu.linkonce.r.*) &#125; /* Include debugging information in kernel memory */ .stab : &#123; PROVIDE(__STAB_BEGIN__ = .); *(.stab); PROVIDE(__STAB_END__ = .); BYTE(0) /* Force the linker to allocate space for this section */ &#125; .stabstr : &#123; PROVIDE(__STABSTR_BEGIN__ = .); *(.stabstr); PROVIDE(__STABSTR_END__ = .); BYTE(0) /* Force the linker to allocate space for this section */ &#125; /* Adjust the address for the data segment to the next page */ . = ALIGN(0x1000); /* The data segment */ .data : &#123; *(.data) &#125; PROVIDE(edata = .); .bss : &#123; *(.bss) &#125; PROVIDE(end = .); /DISCARD/ : &#123; *(.eh_frame .note.GNU-stack) &#125;&#125; 其实从链接脚本的内容，可以大致猜出它指定告诉链接器的各种信息： 内核加载地址：0xC0100000 入口（起始代码）地址： ENTRY(kern_entry) cpu机器类型：i386 其最主要的信息是告诉链接器各输入文件的各section应该怎么组合：应该从哪个地址开始放，各个section以什么顺序放，分别怎么对齐等等，最终组成输出文件的各section。除此之外，linker script还可以定义各种符号（如.text、.data、.bss等），形成最终生成的一堆符号的列表（符号表），每个符号包含了符号名字，符号所引用的内存地址，以及其他一些属性信息。符号实际上就是一个地址的符号表示，其本身不占用的程序运行的内存空间。 链接地址/加载地址/虚地址/物理地址ucore 设定了ucore运行中的虚地址空间，具体设置可看 lab2/kern/mm/memlayout.h 中描述的”Virtual memory map “图，可以了解虚地址和物理地址的对应关系。lab2/tools/kernel.ld描述的是执行代码的链接地址（link_addr），比如内核起始地址是0xC0100000，这是一个虚地址。所以我们可以认为链接地址等于虚地址。在ucore建立内核页表时，设定了物理地址和虚地址的虚实映射关系是： phy addr + 0xC0000000 = virtual addr 即虚地址和物理地址之间有一个偏移。但boot loader把ucore kernel加载到内存时，采用的是加载地址（load addr），这是由于ucore还没有运行，即还没有启动页表映射，导致这时采用的寻址方式是段寻址方式，用的是boot loader在初始化阶段设置的段映射关系，其映射关系（可参看bootasm.S的末尾处有关段描述符表的内容）是： linear addr = phy addr = virtual addr 查看 bootloader的实现代码 bootmain::bootmain.c readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); 这里的ph-&gt;p_va=0xC0XXXXXX，就是ld工具根据kernel.ld设置的链接地址，且链接地址等于虚地址。考虑到ph-&gt;p_va &amp; 0xFFFFFF == 0x0XXXXXX，所以bootloader加载ucore kernel的加载地址是0x0XXXXXX, 这实际上是ucore内核所在的物理地址。简言之： OS的链接地址（link addr） 在tools/kernel.ld中设置好了，是一个虚地址（virtual addr）；而ucore kernel的加载地址（load addr）在boot loader中的bootmain函数中指定，是一个物理地址。 小结一下，ucore内核的链接地址==ucore内核的虚拟地址；boot loader加载ucore内核用到的加载地址==ucore内核的物理地址。 edata/end/text的含义 在基于ELF执行文件格式的代码中，存在一些对代码和数据的表述，基本概念如下： BSS段（bss segment）：指用来存放程序中未初始化的全局变量的内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。 数据段（data segment）：指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 代码段（code segment/text segment）：指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 在lab2/kern/init/init.c的kern_init函数中，声明了外部全局变量： 1extern char edata[], end[]; 但搜寻所有源码文件*.[ch]，没有发现有这两个变量的定义。那这两个变量从哪里来的呢？其实在lab2/tools/kernel.ld中，可以看到如下内容： 1234567891011121314151617….text : &#123; *(.text .stub .text.* .gnu.linkonce.t.*)&#125;… .data : &#123; *(.data)&#125;…PROVIDE(edata = .);… .bss : &#123; *(.bss)&#125;…PROVIDE(end = .);… 这里的“.”表示当前地址，“.text”表示代码段起始地址，“.data”也是一个地址，可以看出，它即代表了代码段的结束地址，也是数据段的起始地址。类推下去，“edata”表示数据段的结束地址，“.bss”表示数据段的结束地址和BSS段的起始地址，而“end”表示BSS段的结束地址。 这样回头看kerne_init中的外部全局变量，可知edata[]和 end[]这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的起始地址或结束地址等，它们不在任何一个.S、.c或.h文件中定义。 自映射机制这是扩展知识。 上一小节讲述了通过boot_map_segment函数建立了基于一一映射关系的页目录表项和页表项，这里的映射关系为： virtual addr (KERNBASE~KERNBASE+KMEMSIZE) = physical_addr (0~KMEMSIZE) 这样只要给出一个虚地址和一个物理地址，就可以设置相应PDE和PTE，就可完成正确的映射关系。 如果我们这时需要按虚拟地址的地址顺序显示整个页目录表和页表的内容，则要查找页目录表的页目录表项内容，根据页目录表项内容找到页表的物理地址，再转换成对应的虚地址，然后访问页表的虚地址，搜索整个页表的每个页目录项。这样过程比较繁琐。 我们需要有一个简洁的方法来实现这个查找。ucore做了一个很巧妙的地址自映射设计，把页目录表和页表放在一个连续的4MB虚拟地址空间中，并设置页目录表自身的虚地址&lt;–&gt;物理地址映射关系。这样在已知页目录表起始虚地址的情况下，通过连续扫描这特定的4MB虚拟地址空间，就很容易访问每个页目录表项和页表项内容。 具体而言，ucore是这样设计的，首先设置了一个常量（memlayout.h）： VPT=0xFAC00000， 这个地址的二进制表示为： 1111 1010 1100 0000 0000 0000 0000 0000 高10位为1111 1010 11，即10进制的1003，中间10位为0，低12位也为0。在pmm.c中有两个全局初始化变量 pte_t const vpt = (pte_t )VPT; pde_t const vpd = (pde_t )PGADDR(PDX(VPT), PDX(VPT), 0); 并在pmm_init函数执行了如下语句： boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W; 这些变量和语句有何特殊含义呢？其实vpd变量的值就是页目录表的起始虚地址0xFAFEB000，且它的高10位和中10位是相等的，都是10进制的1003。当执行了上述语句，就确保了vpd变量的值就是页目录表的起始虚地址，且vpt是页目录表中第一个目录表项指向的页表的起始虚地址。此时描述内核虚拟空间的页目录表的虚地址为0xFAFEB000，大小为4KB。页表的理论连续虚拟地址空间0xFAC00000~0xFB000000，大小为4MB。因为这个连续地址空间的大小为4MB，可有1M个PTE，即可映射4GB的地址空间。 但ucore实际上不会用完这么多项，在memlayout.h中定义了常量 #define KMEMSIZE 0x38000000 表示ucore只支持896MB的物理内存空间，这个896MB只是一个设定，可以根据情况改变。则最大的内核虚地址为常量 #define KERNTOP (KERNBASE + KMEMSIZE)=0xF8000000 所以最大内核虚地址KERNTOP的页目录项虚地址为 vpd+0xF8000000/0x400000=0xFAFEB000+0x3E0=0xFAFEB3E0 最大内核虚地址KERNTOP的页表项虚地址为： vpt+0xF8000000/0x1000=0xFAC00000+0xF8000=0xFACF8000 在pmm.c中的函数print_pgdir就是基于ucore的页表自映射方式完成了对整个页目录表和页表的内容扫描和打印。注意，这里不会出现某个页表的虚地址与页目录表虚地址相同的情况。 print_pgdir函数使得 ucore 具备和 qemu 的info pg相同的功能，即print pgdir能 够从内存中，将当前页表内有效数据（PTE_P）印出来。拷贝出的格式如下所示: 12345PDE(0e0) c0000000-f8000000 38000000 urw|-- PTE(38000) c0000000-f8000000 38000000 -rwPDE(001) fac00000-fb000000 00400000 -rw|-- PTE(000e0) faf00000-fafe0000 000e0000 urw|-- PTE(00001) fafeb000-fafec000 00001000 -rw 上面中的数字包括括号里的，都是十六进制。 主要的功能是从页表中将具备相同权限的 PDE 和 PTE 项目组织起来。比如上表中： 1PDE(0e0) c0000000-f8000000 38000000 urw • PDE(0e0)：0e0表示 PDE 表中相邻的 224 项具有相同的权限； • c0000000-f8000000：表示 PDE 表中,这相邻的两项所映射的线性地址的范围； • 38000000：同样表示范围，即f8000000减去c0000000的结果； • urw：PDE 表中所给出的权限位，u表示用户可读，即PTE_U，r表示PTE_P，w表示用 户可写，即PTE_W。 1PDE(001) fac00000-fb000000 00400000 -rw 表示仅 1 条连续的 PDE 表项具备相同的属性。相应的，在这条表项中遍历找到 2 组 PTE 表项，输出如下: 12|-- PTE(000e0) faf00000-fafe0000 000e0000 urw|-- PTE(00001) fafeb000-fafec000 00001000 -rw 注意： PTE 中输出的权限是 PTE 表中的数据给出的，并没有和 PDE 表中权限做与运算。 2. 整个print_pgdir函数强调两点：第一是相同权限，第二是连续。 3. print_pgdir中用到了vpt和vpd两个变量。可以参 考VPT和PGADDR两个宏。 自映射机制还可方便用户态程序访问页表。因为页表是内核维护的，用户程序很难知道自己页表的映射结构。VPT 实际上在内核地址空间的，我们可以用同样的方式实现一个用户地址空间的映射（比如 pgdir[UVPT] = PADDR(pgdir) | PTE_P | PTE_U，注意，这里不能给写权限，并且 pgdir 是每个进程的 page table，不是 boot_pgdir），这样，用户程序就可以用和内核一样的 print_pgdir 函数遍历自己的页表结构了。]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[x86启动顺序]]></title>
    <url>%2F2020%2F10%2F09%2Fx86%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基本概念BIOS启动过程以Intel 80386为例，计算机加电后，CPU从物理地址0xFFFFFFF0（由初始化的CS：EIP确定，此时CS和IP的值分别是0xF000和0xFFF0)）开始执行。在0xFFFFFFF0这里只是存放了一条跳转指令，通过跳转指令跳到BIOS例行程序起始点。BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的bootloader。 Intel的CPU具有很好的向后兼容性。在16位的8086 CPU时代，内存限制在1MB范围内，且BIOS的代码固化在EPROM中。在基于Intel的8086 CPU的PC机中的EPROM被编址在1ＭB内存地址空间的最高64KB中。PC加电后，CS寄存器初始化为0xF000，IP寄存器初始化为0xFFF0，所以CPU要执行的第一条指令的地址为CS:IP=0xF000:0XFFF0（Segment:Offset 表示）=0xFFFF0（Linear表示）。这个地址位于被固化EPROM中，指令是一个长跳转指令JMP F000:E05B。这样就开启了BIOS的执行过程。 到了32位的80386 CPU时代，内存空间扩大到了4G，多了段机制和页机制，但Intel依然很好地保证了80386向后兼容8086。地址空间的变化导致无法直接采用8086的启动约定。如果把BIOS启动固件编址在0xF000起始的64KB内存地址空间内，就会把整个物理内存地址空间隔离成不连续的两段，一段是0xF000以前的地址，一段是1MB以后的地址，这很不协调。为此，intel采用了一个折中的方案：默认将执行BIOS ROM编址在32位内存地址空间的最高端，即位于4GB地址的最后一个64KB内。在PC系统开机复位时，CPU进入实模式，并将CS寄存器设置成0xF000，将它的shadow register的Base值初始化设置为0xFFFF0000，EIP寄存器初始化设置为0x0000FFF0。所以机器执行的第一条指令的物理地址是0xFFFFFFF0。80386的BIOS代码也要和以前8086的BIOS代码兼容，故地址0xFFFFFFF0处的指令还是一条长跳转指令jmp F000:E05B。注意，这个长跳转指令会触发更新CS寄存器和它的shadow register，即执行jmp F000 : E05B后，CS将被更新成0xF000。表面上看CS其实没有变化，但CS的shadow register被更新为另外一个值了，它的Base域被更新成0x000F0000，此时形成的物理地址为Base+EIP=0x000FE05B，这就是CPU执行的第二条指令的地址。此时这条指令的地址已经是1M以内了，且此地址不再位于BIOS ROM中，而是位于RAM空间中。由于Intel设计了一种映射机制，将内存高端的BIOS ROM映射到1MB以内的RAM空间里，并且可以使这一段被映射的RAM空间具有与ROM类似的只读属性。所以PC机启动时将开启这种映射机制，让4GB地址空间的最高一个64KB的内容等同于1MB地址空间的最高一个64K的内容，从而使得执行了长跳转指令后，其实是回到了早期的8086 CPU初始化控制流，保证了向下兼容。 Bootloader启动过程BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。bootloader完成的工作包括： 切换到保护模式，启用分段机制读磁盘中ELF执行文件格式的ucore操作系统到内存显示字符串信息把控制权交给ucore操作系统 操作系统启动过程当bootloader通过读取硬盘扇区把ucore在系统加载到内存后，就转跳到ucore操作系统在内存中的入口位置（kern/init.c中的kern_init函数的起始地址），这样ucore就接管了整个控制权。当前的ucore功能很简单，只完成基本的内存管理和外设中断管理。ucore主要完成的工作包括： 初始化终端；显示字符串；显示堆栈中的多层函数调用关系；切换到保护模式，启用分段机制；初始化中断控制器，设置中断描述符表，初始化时钟中断，使能整个系统的中断机制；执行while（1）死循环。 代码实现第一个地址机器启动后有个固定启动地址CS:EIP CS=F000H,EIP=FFF0H1234567891011121314151617(gdb) info reax 0x0 0ecx 0x0 0edx 0x663 1635ebx 0x0 0esp 0x0 0x0ebp 0x0 0x0esi 0x0 0edi 0x0 0eip 0xfff0 0xfff0eflags 0x2 [ ]cs 0xf000 61440ss 0x0 0ds 0x0 0es 0x0 0fs 0x0 0gs 0x0 0 早期16位实模式下，CS左移4位+EIP 32位80386，实际地址： Base+EIP = FFFF0000H+0000FFF0H=FFFFFFF0H 12345678(gdb) x/x 0xffff00xffff0: 0x00e05bea(gdb) si=&gt; 0xe05b: add %al,(%bx,%si)0x0000e05b in ?? ()(gdb) x /2i $pc=&gt; 0xe05b: add %al,(%bx,%si) 0xe05d: add %al,(%bx,%si) BIOS到BootloaderBIOS加载存储设备（比如软盘、硬盘、光盘、USB盘）上的第一个扇区（主引导扇区，Master Boot Record or MBR）的512字节到内存0x7c00，然后跳转到@0x7c00的第一条指令开始执行 123456789(gdb) b *0x7c00Breakpoint 1 at 0x7c00(gdb) cContinuing.Breakpoint 1, 0x00007c00 in ?? ()(gdb) x /2i $pc=&gt; 0x7c00: cli &lt;-- bootasm.S 0x7c01: cld 保护模式和分段机制Bootloader中需要完成从实模式到保护模式的切换 实模式只有1M的寻址空间，每个地址对应真实的物理地址 保护模式可以寻址4G字节，对应逻辑地址 通过修改A20地址线可以完成从实模式到保护模式的转换。 保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14个段。 CPL：当前特权级（Current Privilege Level) 保存在CS段寄存器（选择子）的最低两位，CPL就是当前活动代码段的特权级，并且它定义了当前所执行程序的特权级别） DPL：描述符特权（Descriptor Privilege Level） 存储在段描述符中的权限位，用于描述对应段所属的特权等级，也就是段本身能被访问的真正特权级。 RPL：请求特权级RPL(Request Privilege Level) RPL保存在选择子的最低两位。RPL说明的是进程对段访问的请求权限，意思是当前进程想要的请求权限。RPL的值可自由设置，并不一定要求RPL&gt;=CPL，但是当RPL&lt;CPL时，实际起作用的就是CPL了，因为访问时的特权级保护检查要判断：max(RPL,CPL)&lt;=DPL是否成立。所以RPL可以看成是每次访问时的附加限制，RPL=0时附加限制最小，RPL=3时附加限制最大。 分析bootloader 进入保护模式的过程 从%cs=0 $pc=0x7c00，进入后 首先清理环境：包括将flag置0和将段寄存器置01234567.code16 cli cld xorw %ax, %ax movw %ax, %ds movw %ax, %es movw %ax, %ss 开启A20：通过将键盘控制器上的A20线置于高电位，全部32条地址线可用，可以访问4G的内存空间。123456789101112131415seta20.1: # 等待8042键盘控制器不忙 inb $0x64, %al # testb $0x2, %al # jnz seta20.1 # movb $0xd1, %al # 发送写8042输出端口的指令 outb %al, $0x64 #seta20.1: # 等待8042键盘控制器不忙 inb $0x64, %al # testb $0x2, %al # jnz seta20.1 # movb $0xdf, %al # 打开A20 outb %al, $0x60 # 初始化GDT表：一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可1lgdt gdtdesc 进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式123movl %cr0, %eaxorl $CR0_PE_ON, %eaxmovl %eax, %cr0 通过长跳转更新cs的基地址123 ljmp $PROT_MODE_CSEG, $protcseg.code32protcseg: 设置段寄存器，并建立堆栈12345678movw $PROT_MODE_DSEG, %axmovw %ax, %dsmovw %ax, %esmovw %ax, %fsmovw %ax, %gsmovw %ax, %ssmovl $0x0, %ebpmovl $start, %esp 转到保护模式完成，进入boot主方法1call bootmain 分析bootloader加载ELF格式的OS的过程 首先看readsect函数，readsect从设备的第secno扇区读取数据到dst位置123456789101112131415161718192021static voidreadsect(void *dst, uint32_t secno) &#123; waitdisk(); outb(0x1F2, 1); // 设置读取扇区的数目为1 outb(0x1F3, secno &amp; 0xFF); outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF); outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0); // 上面四条指令联合制定了扇区号 // 在这4个字节线联合构成的32位参数中 // 29-31位强制设为1 // 28位(=0)表示访问&quot;Disk 0&quot; // 0-27位是28位的偏移量 outb(0x1F7, 0x20); // 0x20命令，读取扇区 waitdisk(); insl(0x1F0, dst, SECTSIZE / 4); // 读取到dst位置， // 幻数4因为这里以DW为单位&#125; readseg简单包装了readsect，可以从设备读取任意长度的内容。1234567891011121314static voidreadseg(uintptr_t va, uint32_t count, uint32_t offset) &#123; uintptr_t end_va = va + count; va -= offset % SECTSIZE; uint32_t secno = (offset / SECTSIZE) + 1; // 加1因为0扇区被引导占用 // ELF文件从1扇区开始 for (; va &lt; end_va; va += SECTSIZE, secno ++) &#123; readsect((void *)va, secno); &#125;&#125; 在bootmain函数中，1234567891011121314151617181920212223242526272829303132voidbootmain(void) &#123; // 首先读取ELF的头部 readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0); // 通过储存在头部的幻数判断是否是合法的ELF文件 if (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123; goto bad; &#125; struct proghdr *ph, *eph; // ELF头部有描述ELF文件应加载到内存什么位置的描述表， // 先将描述表的头地址存在ph ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; // 按照描述表将ELF文件中数据载入内存 for (; ph &lt; eph; ph ++) &#123; readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); &#125; // ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000 // ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000 // 根据ELF头部储存的入口信息，找到内核的入口 ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); while (1);&#125; 实现函数调用堆栈跟踪函数ss:ebp指向的堆栈位置储存着caller的ebp，以此为线索可以得到所有使用堆栈的函数ebp。ss:ebp+4指向caller调用时的eip，ss:ebp+8等是（可能的）参数。 输出中，堆栈最深一层为123ebp:0x00007bf8 eip:0x00007d68 \ args:0x00000000 0x00000000 0x00000000 0x00007c4f &lt;unknow&gt;: -- 0x00007d67 -- 其对应的是第一个使用堆栈的函数，bootmain.c中的bootmain。bootloader设置的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。call指令压栈，所以bootmain中ebp为0x7bf8。]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核完全注释_第三章 内核编程语言和环境]]></title>
    <url>%2F2020%2F08%2F21%2FLinux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[一、目标文件1.1 目标文件格式 a.out格式7个区的基本定义和用途：执行头（exec header）：该部分中含有一些参数（exec结构），是有关目标文件的整体结构信息。例如代码和数据区的长度、未初始化数据区的长度、对应源程序文件名以及目标文件创建时间等。内核使用这些参数把执行文件加载到内存中并执行，而链接程序（ld）使用这些参数将一些模块文件组合成一个可执行文件。这是目标文件唯一必要的组成部分。 执行头结构体 12345678910struct exec &#123; unsigned long a_magic // 执行文件魔数。使用 N_MAGIC 等宏访问。 unsigned a_text // 代码长度，字节数。 unsigned a_data // 数据长度，字节数。 unsigned a_bss // 文件中的未初始化数据区长度，字节数。 unsigned a_syms // 文件中的符号表长度，字节数。 unsigned a_entry // 执行开始地址。 unsigned a_trsize // 代码重定位信息长度，字节数。 unsigned a_drsize // 数据重定位信息长度，字节数。&#125; 代码区（text segment）：由编译器或汇编器生成的二进制指令代码和数据信息，含有程序执行时被加载到内存中的指令和相关数据。可以以只读形式被加载。 数据区（data segment）：由编译器或汇编器生成的二进制指令代码和数据信息，这部分含有已经初始化过的数据，总是被加载到可读写的内存中。 代码重定位（text relocations）：这部分含有供链接程序使用的记录数据。在组合目标模块文件时用于定位代码段中的指针或地址。当链接程序需要该表目标代码的地址时就需要修正和维护这些地方。 数据重定位（data relocations）：类似于代码重定位部分的作用，但是用于数据段中指针的重定位。 重定位结构体 : 123456789struct relocation_info&#123; int r_address; // 段内需要重定位的地址。 unsigned int r_symbolnum:24; // 含义与 r_extern 有关。指定符号表中一个符号或者一个段。 unsigned int r_pcrel:1; // 1 比特。 PC 相关标志。 unsigned int r_length:2; // 2 比特。指定要被重定位字段长度（2 的次方）。 unsigned int r_extern:1; // 外部标志位。 1 - 以符号的值重定位。 0 - 以段的地址重定位。 unsigned int r_pad:4; // 没有使用的 4 个比特位，但最好将它们复位掉。&#125;; 符号表（symbol table）：这部分同样含有供链接程序使用的记录数据。这些记录数据保保存着模块文件中定义的全局符号以及需要从其他模块文件中输入的符号，或者是由链接器定义的符号，用于在模块文件之间对命名的变量和函数（符号）进行交叉引用。 字符串表（string table）：该部分含有与符号名相对应的字符串。用于调试程序调试目标代码，与连接过程无关。这些信息科包含源程序代码和行号、局部符号以及数据结构描述信息等。1234567891011struct nlist &#123; union &#123; char *n_name; // 字符串指针， struct nlist *n_next; // 或者是指向另一个符号项结构的指针， long n_strx; // 或者是符号名称在字符串表中的字节偏移值。 &#125; n_un; unsigned char n_type; // 该字节分成 3 个字段，参见 a.out.h 文件 146-154 行。 char n_other; // 通常不用。 short n_desc; // unsigned long n_value; // 符号的值。&#125;; 对于一个指定的目标文件并非一定会包含所有以上信息。 1.2 可执行文件映射到进程逻辑地址空间 1.3 目标文件的链接操作 1.4 System.map文件链接（ld）时使用“-M”选项，或者使用nm，可以生成链接映像（link map）信息，即连接程序产生的目标程序内存地址映像信息。其中列出了程序段装入内存中的位置信息。有如下信息： 目标文件及符号信息映射到内存中的位置 公共符号如何放置 链接中包含的所有文件成员及其应用的符号 一般存放在： /boot/System.map/System.map/usr/src/linux/System.map 表 3-5 目标文件符号列表文件中的符号类型 符号类型 名称 说明 A Absolute 符号的值是绝对值，并且在进一步链接过程中不会被改变。 B BSS 符号在未初始化数据区或区（section） 中，即在 BSS 段中 C Common 符号是公共的。公共符号是未初始化的数据。在链接时，多个公共符号可能具 有同一名称。如果该符号定义在其他地方，则公共符号被看作是未定义的引用。 D Data 符号在已初始化数据区中。 G Global 符号是在小对象已初始化数据区中的符号。某些目标文件的格式允许对小数据 对象（例如一个全局整型变量）可进行更有效的访问 I Inderect 符号是对另一个符号的间接引用 N Debugging 符号是一个调试符号 R Read only 符号在一个只读数据区中 S Small 符号是小对象未初始化数据区中的符号 T Text 符号是代码区中的符号 U Undefined 符号是外部的，并且其值为 0（未定义） - Stabs 符号是 a.out 目标文件中的一个 stab 符号，用于保存调试信息 ? Unknwon 符号的类型未知，或者是与具体文件格式有关 二、MakeFile2.1 Makefile 文件中的规则12target（目标）...： prerequisites（先决条件）... command（命令） prerequisite（先决条件或称依赖对象）是用以创建 target 所必要或者依赖的一系列文件或其他目标。target 通常依赖于多个这样的必要文件或目标文件。 command（命令）是指 make 所执行的操作，通常就是一些 shell 命令，是生成 target 需要执行的操作。当先决条件中一个或多个文件的最后修改时间比 target 文件的要新时，规则的命令就会被执行。另外，一个规则中可以有多个命令，每个命令占用规则中单独一行。请注意，我们需要在写每个命令之前键入一个制表符（按 Tab 键产生）！12345678910edit : main.o files.o utils.o cc -o edit main.o files.o utils.omain.o : main.c defs.h cc -c main.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit main.o files.o utils.o 2.2 让MakeFile自动推断命令12345678objects = main.o files.o utils.o #变量edit : $(objects) #自动推断命令 cc -o edit $(objects)main.o : defs.hfiles.o : defs.h buffer.h command.hutils.o : defs.hclean : rm edit $(objects) 2.3 隐含规则中的自动变量123# ↓ 第一个先决条件foo.o : foo.c defs.h hack.h cc -c $(CFLAGS) $&lt; -o $@ $^: 表示规则的所有先决条件，包括它们所处目录的名称；代表所有通过目录搜索得到的依赖文件的完整路径名（目录 + 一般文件名）列表 ；$&lt;: 表示规则中的第一个先决条件；如：替换成 foo.c$@: 表示目标对象；如：被替换为 foo.o 参考：GNU make中文手册 三、小结学习可执行文件的内存结构，复习MakeFile的语法。]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USB笔记3_复合设备]]></title>
    <url>%2F2020%2F08%2F17%2FUSB%E7%AC%94%E8%AE%B03-%E5%A4%8D%E5%90%88%E8%AE%BE%E5%A4%87%2F</url>
    <content type="text"><![CDATA[USB笔记3_复合设备本篇主要浅谈支持多功能的设备。至少有两种方法能够实现： 只是用一个接口，但是使用两个应用集合和两个报告。 使用两个接口，一个接口实现键盘功能，另一个接口实现鼠标功能。 方法一：一个接口、两个集合、两个报告通过修改报告描述符实现。一个描述符中可以具有多个外层应用集合，而系统软件就是通过分析外层应用集合的功能来增加不通的设备和驱动的。因此在这里，只需要实现用途分别为键盘和鼠标的两个应用集合即可。同时，每个应用集合里还需要增加一个报告ID，以区分返回数据。报告ID是报告输入或者输出时的第一个字节，当没有定义报告ID时，报告前面就没有报告ID。对于返回的没有报告ID的报告，人体学输入设备驱动会自动增加一个报告ID 0；而应用程序在发送数据出去时，也要带一个值为0的报告ID。人体学输入设备驱动会自动去掉这个值为0的报告ID，只发送数据出去。注意：报告ID一旦定义，输入报告和输出报告的第一字节都是报告ID。例如：本例中的键盘，从端点1读输出报告数据时要读2字节的数据，第一字节为报告ID，第二字节才是真正的报告数据。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268//USB报告描述符的定义//该报告描述符定义了两个顶层应用集合——键盘和鼠标。code uint8 ReportDescriptor[]=&#123; //每行开始的第一字节为该条目的前缀，前缀的格式为： //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。 /************************USB键盘部分报告描述符**********************//*******************************************************************/ //这是一个全局（bType为1）条目，将用途页选择为普通桌面Generic Desktop Page(0x01) //后面跟一字节数据（bSize为1），后面的字节数就不注释了， //自己根据bSize来判断。 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //这是一个局部（bType为2）条目，说明接下来的集合用途用于键盘 0x09, 0x06, // USAGE (Keyboard) //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示 //该集合是一个应用集合。它的性质在前面由用途页和用途定义为 //普通桌面用的键盘。 0xa1, 0x01, // COLLECTION (Application) //报告ID，这里定义键盘报告的ID为1（报告ID 0是保留的） 0x85, 0x01, //Report ID (1) //这是一个全局条目，选择用途页为键盘（Keyboard/Keypad(0x07)） 0x05, 0x07, // USAGE_PAGE (Keyboard/Keypad) //这是一个局部条目，说明用途的最小值为0xe0。实际上是键盘左Ctrl键。 //具体的用途值可在HID用途表中查看。 0x19, 0xe0, // USAGE_MINIMUM (Keyboard LeftControl) //这是一个局部条目，说明用途的最大值为0xe7。实际上是键盘右GUI键。 0x29, 0xe7, // USAGE_MAXIMUM (Keyboard Right GUI) //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值） //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。 0x15, 0x00, // LOGICAL_MINIMUM (0) //这是一个全局条目，说明逻辑值最大为1。 0x25, 0x01, // LOGICAL_MAXIMUM (1) //这是一个全局条目，说明数据域的数量为八个。 0x95, 0x08, // REPORT_COUNT (8) //这是一个全局条目，说明每个数据域的长度为1个bit。 0x75, 0x01, // REPORT_SIZE (1) //这是一个主条目，说明有8个长度为1bit的数据域（数量和长度 //由前面的两个全局条目所定义）用来做为输入， //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示 //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。 //这样定义的结果就是，当某个域的值为1时，就表示对应的键按下。 //bit0就对应着用途最小值0xe0，bit7对应着用途最大值0xe7。 0x81, 0x02, // INPUT (Data,Var,Abs) //这是一个全局条目，说明数据域数量为1个 0x95, 0x01, // REPORT_COUNT (1) //这是一个全局条目，说明每个数据域的长度为8bit。 0x75, 0x08, // REPORT_SIZE (8) //这是一个主条目，输入用，由前面两个全局条目可知，长度为8bit， //数量为1个。它的属性为常量（即返回的数据一直是0）。 //该字节是保留字节（保留给OEM使用）。 0x81, 0x03, // INPUT (Cnst,Var,Abs) //这是一个全局条目。定义位域数量为6个。 0x95, 0x06, // REPORT_COUNT (6) //这是一个全局条目。定义每个位域长度为8bit。 //其实这里这个条目不要也是可以的，因为在前面已经有一个定义 //长度为8bit的全局条目了。 0x75, 0x08, // REPORT_SIZE (8) //这是一个全局条目，定义逻辑最小值为0。 //同上，这里这个全局条目也是可以不要的，因为前面已经有一个 //定义逻辑最小值为0的全局条目了。 0x15, 0x00, // LOGICAL_MINIMUM (0) //这是一个全局条目，定义逻辑最大值为255。 0x25, 0xFF, // LOGICAL_MAXIMUM (255) //这是一个全局条目，选择用途页为键盘。 //前面已经选择过用途页为键盘了，所以该条目不要也可以。 0x05, 0x07, // USAGE_PAGE (Keyboard/Keypad) //这是一个局部条目，定义用途最小值为0（0表示没有键按下） 0x19, 0x00, // USAGE_MINIMUM (Reserved (no event indicated)) //这是一个局部条目，定义用途最大值为0x65 0x29, 0x65, // USAGE_MAXIMUM (Keyboard Application) //这是一个主条目。它说明这六个8bit的数据域是输入用的， //属性为：Data,Ary,Abs。Data说明数据是可以变的，Ary说明 //这些数据域是一个数组，即每个8bit都可以表示某个键值， //如果按下的键太多（例如超过这里定义的长度或者键盘本身无法 //扫描出按键情况时），则这些数据返回全1（二进制），表示按键无效。 //Abs表示这些值是绝对值。 0x81, 0x00, // INPUT (Data,Ary,Abs) //以下为输出报告的描述 //逻辑最小值前面已经有定义为0了，这里可以省略。 //这是一个全局条目，说明逻辑值最大为1。 0x25, 0x01, // LOGICAL_MAXIMUM (1) //这是一个全局条目，说明数据域数量为5个。 0x95, 0x05, // REPORT_COUNT (5) //这是一个全局条目，说明数据域的长度为1bit。 0x75, 0x01, // REPORT_SIZE (1) //这是一个全局条目，说明使用的用途页为指示灯（LED） 0x05, 0x08, // USAGE_PAGE (LEDs) //这是一个局部条目，说明用途最小值为数字键盘灯。 0x19, 0x01, // USAGE_MINIMUM (Num Lock) //这是一个局部条目，说明用途最大值为Kana灯。 0x29, 0x05, // USAGE_MAXIMUM (Kana) //这是一个主条目。定义输出数据，即前面定义的5个LED。 0x91, 0x02, // OUTPUT (Data,Var,Abs) //这是一个全局条目。定义位域数量为1个。 0x95, 0x01, // REPORT_COUNT (1) //这是一个全局条目。定义位域长度为3bit。 0x75, 0x03, // REPORT_SIZE (3) //这是一个主条目，定义输出常量，前面用了5bit，所以这里需要 //3个bit来凑成一字节。 0x91, 0x03, // OUTPUT (Cnst,Var,Abs) //下面这个主条目用来关闭前面的集合。bSize为0，所以后面没数据。 0xc0, // END_COLLECTION//以下注释不包括第一字节报告ID。//通过上面的报告描述符的定义，我们知道返回的输入报告具有8字节。//第一字节的8个bit用来表示特殊键是否按下（例如Shift、Alt等键）。//第二字节为保留值，值为常量0。第三到第八字节是一个普通键键值的//数组，当没有键按下时，全部6个字节值都为0。当只有一个普通键按下时，//这六个字节中的第一字节值即为该按键的键值（具体的键值请看HID的//用途表文档），当有多个普通键同时按下时，则同时返回这些键的键值。//如果按下的键太多，则这六个字节都为0xFF（不能返回0x00，这样会让//操作系统认为所有键都已经释放）。至于键值在数组中的先后顺序是//无所谓的，操作系统会负责检查是否有新键按下。我们应该在中断端点1//中按照上面的格式返回实际的键盘数据。另外，报告中还定义了一个字节//的输出报告，是用来控制LED情况的。只使用了低7位，高1位是保留值0。//当某位的值为1时，则表示对应的LED要点亮。操作系统会负责同步各个//键盘之间的LED，例如你有两块键盘，一块的数字键盘灯亮时，另一块//也会跟着亮。键盘本身不需要判断各种LED应该何时亮，它只是等待主机//发送报告给它，然后根据报告值来点亮相应的LED。我们在端点1输出中断//中读出这1字节的输出报告，然后对它取反（因为学习板上的LED是低电平时//亮），直接发送到LED上。这样main函数中按键点亮LED的代码就不需要了。/************************USB鼠标部分报告描述符**********************//*******************************************************************/ //这是一个全局（bType为1）条目，选择用途页为普通桌面Generic Desktop Page(0x01) 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //这是一个局部（bType为2）条目，说明接下来的应用集合用途用于鼠标 0x09, 0x02, // USAGE (Mouse) //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示 //该集合是一个应用集合。它的性质在前面由用途页和用途定义为 //普通桌面用的鼠标。 0xa1, 0x01, // COLLECTION (Application) //报告ID，这里定义鼠标报告的ID为2 0x85, 0x02, //Report ID (2) //这是一个局部条目。说明用途为指针集合 0x09, 0x01, // USAGE (Pointer) //这是一个主条目，开集合，后面跟的数据0x00表示该集合是一个 //物理集合，用途由前面的局部条目定义为指针集合。 0xa1, 0x00, // COLLECTION (Physical) //这是一个全局条目，选择用途页为按键（Button Page(0x09)） 0x05, 0x09, // USAGE_PAGE (Button) //这是一个局部条目，说明用途的最小值为1。实际上是鼠标左键。 0x19, 0x01, // USAGE_MINIMUM (Button 1) //这是一个局部条目，说明用途的最大值为3。实际上是鼠标中键。 0x29, 0x03, // USAGE_MAXIMUM (Button 3) //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值啦） //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。 0x15, 0x00, // LOGICAL_MINIMUM (0) //这是一个全局条目，说明逻辑值最大为1。 0x25, 0x01, // LOGICAL_MAXIMUM (1) //这是一个全局条目，说明数据域的数量为三个。 0x95, 0x03, // REPORT_COUNT (3) //这是一个全局条目，说明每个数据域的长度为1个bit。 0x75, 0x01, // REPORT_SIZE (1) //这是一个主条目，说明有3个长度为1bit的数据域（数量和长度 //由前面的两个全局条目所定义）用来做为输入， //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示 //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。 //这样定义的结果就是，第一个数据域bit0表示按键1（左键）是否按下， //第二个数据域bit1表示按键2（右键）是否按下，第三个数据域bit2表示 //按键3（中键）是否按下。 0x81, 0x02, // INPUT (Data,Var,Abs) //这是一个全局条目，说明数据域数量为1个 0x95, 0x01, // REPORT_COUNT (1) //这是一个全局条目，说明每个数据域的长度为5bit。 0x75, 0x05, // REPORT_SIZE (5) //这是一个主条目，输入用，由前面两个全局条目可知，长度为5bit， //数量为1个。它的属性为常量（即返回的数据一直是0）。 //这个只是为了凑齐一个字节（前面用了3个bit）而填充的一些数据 //而已，所以它是没有实际用途的。 0x81, 0x03, // INPUT (Cnst,Var,Abs) //这是一个全局条目，选择用途页为普通桌面Generic Desktop Page(0x01) 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //这是一个局部条目，说明用途为X轴 0x09, 0x30, // USAGE (X) //这是一个局部条目，说明用途为Y轴 0x09, 0x31, // USAGE (Y) //这是一个局部条目，说明用途为滚轮 0x09, 0x38, // USAGE (Wheel) //下面两个为全局条目，说明返回的逻辑最小和最大值。 //因为鼠标指针移动时，通常是用相对值来表示的， //相对值的意思就是，当指针移动时，只发送移动量。 //往右移动时，X值为正；往下移动时，Y值为正。 //对于滚轮，当滚轮往上滚时，值为正。 0x15, 0x81, // LOGICAL_MINIMUM (-127) 0x25, 0x7f, // LOGICAL_MAXIMUM (127) //这是一个全局条目，说明数据域的长度为8bit。 0x75, 0x08, // REPORT_SIZE (8) //这是一个全局条目，说明数据域的个数为3个。 0x95, 0x03, // REPORT_COUNT (3) //这是一个主条目。它说明这三个8bit的数据域是输入用的， //属性为：Data,Var,Rel。Data说明数据是可以变的，Var说明 //这些数据域是独立的，即第一个8bit表示X轴，第二个8bit表示 //Y轴，第三个8bit表示滚轮。Rel表示这些值是相对值。 0x81, 0x06, // INPUT (Data,Var,Rel) //下面这两个主条目用来关闭前面的集合用。 //我们开了两个集合，所以要关两次。bSize为0，所以后面没数据。 0xc0, // END_COLLECTION 0xc0 // END_COLLECTION//以下注释不包括第一字节报告ID。//通过上面的报告描述符的定义，我们知道返回的输入报告具有4字节。//第一字节的低3位用来表示按键是否按下的，高5位为常数0，无用。//第二字节表示X轴改的变量，第三字节表示Y轴的改变量，第四字节表示//滚轮的改变量。我们在中断端点1中应该要按照上面的格式返回实际的//鼠标数据。&#125;;//由于该报告使用了报告ID，因此报告在返回时，需要在最前面增加//一字节的报告ID。当报告ID为1时，返回的数据是键盘数据；//当报告ID为2时，返回的数据是鼠标数据。 由于多了一个Report ID，所以构造report的时候是9个字节，而不是之前的8个字节。 方法二：两个接口、各一个HID描述符、各一个报告描述符使用两个接口，每个接口实现一个HID设备。这样每个接口需要一个报告描述符。12345678910graph LRA[配置描述符集合] --&gt; B(配置描述符)B --&gt; C[第一个接口描述符]B --&gt; D[第二个接口描述符]C--&gt; G[HID描述符]C--&gt; H[输入端点描述符]C--&gt; I[输出端点描述符]D--&gt; J[HID描述符]D--&gt; K[输入端点描述符]D--&gt; L[输出端点描述符] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219//USB配置描述符集合的定义//配置描述符总长度为9+9+9+7+7+9+9+7字节code uint8 ConfigurationDescriptor[9+9+9+7+7+9+9+7]=&#123; /***************配置描述符***********************/ //bLength字段。配置描述符的长度为9字节。 0x09, //bDescriptorType字段。配置描述符编号为0x02。 0x02, //wTotalLength字段。配置描述符集合的总长度， //包括配置描述符本身、接口描述符、类描述符、端点描述符等。 sizeof(ConfigurationDescriptor)&amp;0xFF, //低字节 (sizeof(ConfigurationDescriptor)&gt;&gt;8)&amp;0xFF, //高字节 //bNumInterfaces字段。该配置包含的接口数，有两个接口。 0x02, //bConfiguration字段。该配置的值为1。 0x01, //iConfigurationz字段，该配置的字符串索引。这里没有，为0。 0x00, //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的， //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。 0x80, //bMaxPower字段，该设备需要的最大电流量。由于我们的板子 //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位 //电流为2mA，所以这里设置为50(0x32)。 0x32, /*******************第一个接口描述符*********************/ //bLength字段。接口描述符的长度为9字节。 0x09, //bDescriptorType字段。接口描述符的编号为0x04。 0x04, //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。 0x00, //bAlternateSetting字段。该接口的备用编号，为0。 0x00, //bNumEndpoints字段。非0端点的数目。由于USB键盘需要二个 //中断端点（一个输入一个输出），因此该值为2。 0x02, //bInterfaceClass字段。该接口所使用的类。USB键盘是HID类， //HID类的编码为0x03。 0x03, //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中， //只规定了一种子类：支持BIOS引导启动的子类。 //USB键盘、鼠标属于该子类，子类代码为0x01。 0x01, //bInterfaceProtocol字段。如果子类为支持引导启动的子类， //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。 0x01, //iConfiguration字段。该接口的字符串索引值。这里没有，为0。 0x00, /******************HID描述符************************/ //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。 0x09, //bDescriptorType字段。HID描述符的编号为0x21。 0x21, //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。 0x10, 0x01, //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。 0x21, //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。 0x01, //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。 0x22, //bDescriptorLength字段。 //下级描述符的长度。下级描述符为键盘报告描述符。 sizeof(KeyboardReportDescriptor)&amp;0xFF, (sizeof(KeyboardReportDescriptor)&gt;&gt;8)&amp;0xFF, /**********************输入端点描述符***********************/ //bLength字段。端点描述符长度为7字节。 0x07, //bDescriptorType字段。端点描述符编号为0x05。 0x05, //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。 //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。 0x81, //bmAttributes字段。D1~D0为端点传输类型选择。 //该端点为中断端点。中断端点的编号为3。其它位保留为0。 0x03, //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。 //注意低字节在先。 0x10, 0x00, //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。 0x0A, /**********************输出端点描述符***********************/ //bLength字段。端点描述符长度为7字节。 0x07, //bDescriptorType字段。端点描述符编号为0x05。 0x05, //bEndpointAddress字段。端点的地址。我们使用D12的输出端点1。 //D7位表示数据方向，输出端点D7为0。所以输出端点1的地址为0x01。 0x01, //bmAttributes字段。D1~D0为端点传输类型选择。 //该端点为中断端点。中断端点的编号为3。其它位保留为0。 0x03, //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。 //注意低字节在先。 0x10, 0x00, //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。 0x0A, /*******************第二个接口描述符*********************/ //bLength字段。接口描述符的长度为9字节。 0x09, //bDescriptorType字段。接口描述符的编号为0x04。 0x04, //bInterfaceNumber字段。该接口的编号，第二个接口，编号为1。 0x01, //bAlternateSetting字段。该接口的备用编号，为0。 0x00, //bNumEndpoints字段。非0端点的数目。由于USB鼠标需要一个 //中断输入端点，因此该值为1。 0x01, //bInterfaceClass字段。该接口所使用的类。USB键盘是HID类， //HID类的编码为0x03。 0x03, //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中， //只规定了一种子类：支持BIOS引导启动的子类。 //USB键盘、鼠标属于该子类，子类代码为0x01。 0x01, //bInterfaceProtocol字段。如果子类为支持引导启动的子类， //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。 0x02, //iConfiguration字段。该接口的字符串索引值。这里没有，为0。 0x00, /******************HID描述符************************/ //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。 0x09, //bDescriptorType字段。HID描述符的编号为0x21。 0x21, //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。 0x10, 0x01, //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。 0x21, //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。 0x01, //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。 0x22, //bDescriptorLength字段。 //下级描述符的长度。下级描述符为鼠标报告描述符。 sizeof(MouseReportDescriptor)&amp;0xFF, (sizeof(MouseReportDescriptor)&gt;&gt;8)&amp;0xFF, /**********************输入端点描述符***********************/ //bLength字段。端点描述符长度为7字节。 0x07, //bDescriptorType字段。端点描述符编号为0x05。 0x05, //bEndpointAddress字段。端点的地址。我们使用D12的输入端点2。 //D7位表示数据方向，输入端点D7为1。所以输入端点2的地址为0x82。 0x82, //bmAttributes字段。D1~D0为端点传输类型选择。 //该端点为中断端点。中断端点的编号为3。其它位保留为0。 0x03, //wMaxPacketSize字段。该端点的最大包长。端点2的最大包长为64字节。 //注意低字节在先。 0x40, 0x00, //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。 0x0A&#125;; 三、QAQ:无A:无]]></content>
  </entry>
  <entry>
    <title><![CDATA[USB笔记2_HID]]></title>
    <url>%2F2020%2F08%2F17%2FUSB%E7%AC%94%E8%AE%B02-HID%2F</url>
    <content type="text"><![CDATA[USB笔记2_HID本篇主要浅谈HID Report 一、报告描述符简介1.1 Item介绍报告描述符比较复杂，它是以item形式排列组合而成，无固定长度，用户可以自定义长度以及每一bit的含义。item类型分三种：main，global和local，每种类型又可以分为多个tag： main： Input、Output、Feature、Collection、End Collection global： Usage Page、Logical Minimum、Logical Maximum、Physical Minimum、Physical Maximum、Unit Exponent、Unit、Report Size、Report ID、Report Count、Push、Pop local： Usage、Usage Minimum、Usage Maximum、Designator Index、Designator Minimum、Designator Maximum、String Index、String Minimum、String Maximum、Delimiter、Reserved 1.2 Item之间的关系Main项目中的 input,ouput,feature三个卷标用来表示报告中数据的种类，这些是报告描述符中最主要的项目，其他项目都是用来修饰这三种项目。 Input 项：表示设备操作输入到主机的数据模式。这个数据格式就形成一个输入报告，虽然输入报告可以用控制型管线以get report（input）来传输，但是通常用中断型输入管线来传输以确保在每一固定周期内都能将更新的输入报告传给主机。 Output 项：表示由主机输出到装置操作的数据格式。这个数据格式就形成一个输出报告。输出报告通常不适用轮询的方式来传送给设备，而是由应用软件依实际需求以传令方式要求送出输出报告，所以大多用控制型管线以set report(output)指令来将报告送到设备。当然也可以选择用中断型输出管线来传送，只是通常不建议这样用。 Feature 项：表示由主机送到设备的组态所需数据的数据格式。这个数据模式就形成一个特征报告。特征报告只能用控制型管线以get report(feature)和set report(feature)指令分别来取得和设定设备的特征值 主项目用来定义报告中数据的种类和格式，而说明主项目之意义与用途为全局项目和区域项目。顾名思义，区域性项目只能适用于列于其下的第一个主项目，不适用于其他主项目，若一个主项目之上有几个不同的卷标的区域性项目，则这些区域性项目皆适用于描述该主项目。相反，全局性项目适用于其下方的所有主项目，除非另一个相同卷标的全局性项目出现！！！ 1.3 实例以下是单点触摸屏的示例报告描述符和格式：123456789101112131415161718192021222324252627282930310x05, 0x0D, // Usage Page (Digitizer)0x09, 0x04, // Usage (Touch Screen)0xA1, 0x01, // Collection (Application)0x05, 0x0D, // Usage Page (Digitizer)0x09, 0x22, // Usage (Finger)0xA1, 0x02, // Collection (Logical)0x05, 0x0D, // Usage Page (Digitizer)0x09, 0x33, // Usage (Touch)0x15, 0x00, // Logical Minimum......... (0)0x25, 0x01, // Logical Maximum......... (1)0x75, 0x01, // Report Size............. (1)0x95, 0x01, // Report Count............ (1)0x81, 0x02, // Input...................(Data, Variable, Absolute)0x75, 0x07, // Report Size............. (7)0x95, 0x01, // Report Count............ (1)0x81, 0x01, // Input...................(Constant)0x05, 0x01, // Usage Page (Generic Desktop)0x09, 0x30, // Usage (X)0x15, 0x00, // Logical Minimum......... (0)0x26, 0x20, 0x03, // Logical Maximum......... (800)0x75, 0x10, // Report Size............. (16)0x95, 0x01, // Report Count............ (1)0x81, 0x02, // Input...................(Data, Variable, Absolute)0x09, 0x31, // Usage (Y)0x15, 0x00, // Logical Minimum......... (0)0x26, 0xE0, 0x01, // Logical Maximum......... (480)0x75, 0x10, // Report Size............. (16)0x95, 0x01, // Report Count............ (1)0x81, 0x02, // Input...................(Data, Variable, Absolute)0xC0, // End Collection0xC0, // End Collection 单点触摸屏的输入报告布局示例：12345|Touch | X | Y |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| 0 | 1 | 2 | 3 | 4 | 二、主机和设备之间的通信2.1 获取报告描述符 HID类请求（命令）包格式 偏移量 域 大小 说明 0 bmRequestType 1 HID设备类请求特性如下： 位7： 0＝从USB HOST到USB设备 1＝从USB设备到USB HOST 位6~5： 01＝请求类型为设备类请求 位4~0： 0001＝请求对象为接口（interface）因而，针对HID的设备类请求，仅仅10100001和00100001有效 1 bRequest 1 HID类请求（参考下表） 2 wValue 2 高字节说明描述符的类型0x21：HID描述符 0x22：报告描述符 0x23：物理描述符低字节为非0值时被用来选定实体描述符。 4 wIndex 2 2字节数值，根据不同的bRequest有不同的意义 6 wLength 2 该请求的数据段长度 2.2 实例2.2.1 主机端获取报告描述符（该描述符来自UsbMouse）123456789101112131415USB端点0输出中断。读端点0缓冲区8字节。0x81 0x06 0x00 0x22 0x00 0x00 0x34 0x00 // 来自主机端的请求，HID类请求（命令）包，8个字节USB标准输入请求：获取描述符——报告描述符。 // 报告描述符 52个字节写端点0缓冲区16字节。0x05 0x01 0x09 0x02 0xA1 0x01 0x09 0x01 0xA1 0x00 0x05 0x09 0x19 0x01 0x29 0x03 USB端点0输入中断。写端点0缓冲区16字节。0x15 0x00 0x25 0x01 0x95 0x03 0x75 0x01 0x81 0x02 0x95 0x01 0x75 0x05 0x81 0x03 USB端点0输入中断。写端点0缓冲区16字节。0x05 0x01 0x09 0x30 0x09 0x31 0x09 0x38 0x15 0x81 0x25 0x7F 0x75 0x08 0x95 0x03 USB端点0输入中断。写端点0缓冲区4字节。0x81 0x06 0xC0 0xC0 描述符相关的操作是通过端点0进行通信的，也是USB协议中必须要存在的端点。 2.2.2 设备端输入HID Report123USB端点1输入中断。写端点1缓冲区4字节。0x00 0x00 0x01 0x00 2.2.2 设备端输入HID Report123USB端点1输出中断。读端点1缓冲区4字节。0x00 0x00 0x01 0x00 Host端如果是Linux，调用接口libusb_interrupt_transfer()。可以看出HID控制消息是通过端点1来通信的。 这里的端点1是之前配置描述符中定义的，用于传输真实数据的端点。主机端通过lsusb也可以看到对应的消息：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960root@atlas7-arm:~# lsusb -vd 8888:0001Bus 002 Device 004: ID 8888:0001 Device Descriptor: bLength 18 bDescriptorType 1 bcdUSB 1.10 bDeviceClass 0 (Defined at Interface level) bDeviceSubClass 0 bDeviceProtocol 0 bMaxPacketSize0 16 idVendor 0x8888 idProduct 0x0001 bcdDevice 1.00 iManufacturer 1 iProduct 2 iSerial 3 bNumConfigurations 1 Configuration Descriptor: bLength 9 bDescriptorType 2 wTotalLength 34 bNumInterfaces 1 bConfigurationValue 1 iConfiguration 0 bmAttributes 0x80 (Bus Powered) MaxPower 100mA Interface Descriptor: bLength 9 bDescriptorType 4 bInterfaceNumber 0 bAlternateSetting 0 bNumEndpoints 1 bInterfaceClass 3 Human Interface Device bInterfaceSubClass 1 Boot Interface Subclass bInterfaceProtocol 2 Mouse iInterface 0 HID Device Descriptor: bLength 9 bDescriptorType 33 bcdHID 1.10 bCountryCode 33 US bNumDescriptors 1 bDescriptorType 34 Report wDescriptorLength 52 Report Descriptors: ** UNAVAILABLE ** Endpoint Descriptor: bLength 7 bDescriptorType 5 bEndpointAddress 0x81 EP 1 IN bmAttributes 3 Transfer Type Interrupt Synch Type None Usage Type Data wMaxPacketSize 0x0010 1x 16 bytes bInterval 10Device Status: 0x1fd8 (Bus Powered) Debug Mode 三、QAQ:内核报错usb 1-1: can’t set config #1, error -110A:设备端没有处理主机端发送过来的消息，收到消息需要回复ack SETUP数据包（SET_CONFIGURATION） 正常： 0x00 0x09 0x01 0x00 0x00 0x00 0x00 0x00 异常： 0xC0 0x33 0x00 0x00 0x00 0x00 0x02 0x00]]></content>
  </entry>
  <entry>
    <title><![CDATA[USB笔记1_UsbMouse]]></title>
    <url>%2F2020%2F08%2F11%2FUSB%E7%AC%94%E8%AE%B01-UsbMouse%2F</url>
    <content type="text"><![CDATA[USB笔记1_UsbMouse本篇主要来自《圈圈教你玩usb》的UsbMouse实例 一、USB枚举过程1.1 Device设备端代码片段12345678910111213141516while(1) //死循环&#123; if(D12GetIntPin()==0) //如果有中断发生 &#123; D12WriteCommand(READ_INTERRUPT_REGISTER); //写读中断寄存器的命令 InterruptSource=D12ReadByte(); //读回第一字节的中断寄存器 if(InterruptSource&amp;0x80)UsbBusSuspend(); //总线挂起中断处理 if(InterruptSource&amp;0x40)UsbBusReset(); //总线复位中断处理 if(InterruptSource&amp;0x01)UsbEp0Out(); //端点0输出中断处理 if(InterruptSource&amp;0x02)UsbEp0In(); //端点0输入中断处理 if(InterruptSource&amp;0x04)UsbEp1Out(); //端点1输出中断处理 if(InterruptSource&amp;0x08)UsbEp1In(); //端点1输入中断处理 if(InterruptSource&amp;0x10)UsbEp2Out(); //端点2输出中断处理 if(InterruptSource&amp;0x20)UsbEp2In(); //端点2输入中断处理 &#125;&#125; 1.2 Device设备端日志1.2.1 SETUP数据包，获取设备描述符123456789USB端点0输出中断。 // host端带返回值的请求，device需要知道输出什么，所以先读8字节读端点0缓冲区8字节。0x80 0x06 0x00 0x01 0x00 0x00 0x40 0x00 USB标准输入请求：获取描述符——设备描述符。 // 设备描述符有18个字节写端点0缓冲区16字节。 // PDIUSBD12的端点0大小的16字节0x12 0x01 0x10 0x01 0x00 0x00 0x00 0x10 0x88 0x88 0x01 0x00 0x00 0x01 0x01 0x02 USB端点0输入中断。写端点0缓冲区2字节。 // 发送剩余的2个字节0x03 0x01 日志显示已经成功接收到主机发送过来的8字节数据。在第一次接收到数据后，会停顿一段时间。这段时间主机一直在请求输入。但是目前还没有返回数据，所以D12一直在回答NAK，即没有数据准备好。结果USB主机经过一段时间的等待之后，终于不耐烦了，发送了一次总线复位，然后又重新输出这8个字节的数据，然后又是等待输入数据。尝试几次后主机只好无奈的放弃了。这是改USB端口上不再有数据活动，从而D12进入了挂起状态。同时在计算机端弹出无法识别的USB设备对话框。 主机端内核日志： [ 9536.933549] usb 2-1: new full-speed USB device number 16 using ci_hdrc [ 9542.053622] usb 2-1: device descriptor read/64, error -110 #define ETIMEDOUT 110 /* Connection timed out */ 1.2.2 设置地址1234567USB总线复位。USB端点0输出中断。读端点0缓冲区8字节。0x00 0x05 0x06 0x00 0x00 0x00 0x00 0x00 USB标准输出请求：设置地址。地址为：0x06 写端点0缓冲区0字节。USB端点0输入中断。 1.2.3 SETUP数据包，基于新地址，重新获取设备描述符123456789USB端点0输出中断。读端点0缓冲区8字节。0x80 0x06 0x00 0x01 0x00 0x00 0x12 0x00 USB标准输入请求：获取描述符——设备描述符。写端点0缓冲区16字节。0x12 0x01 0x10 0x01 0x00 0x00 0x00 0x10 0x88 0x88 0x01 0x00 0x00 0x01 0x01 0x02 USB端点0输入中断。写端点0缓冲区2字节。0x03 0x01 二、描述符2.1 各描述符之间的关系设备描述符（Device Descriptor） 配置描述符（Configuration Descriptor） 接口描述符（Interface Descriptor） HID描述符（HID Device Descriptor） 报告描述符（Report Descriptor） 一个设备描述符可以包含多个配置描述符，通常1个一个配置描述符可以包含多个接口描述符。一个接口描述符可以包含多个端点描述符。 接口描述符跟着配置描述符走的，无法单独存在。 2.2 各描述符简介：2.2.1 设备描述符（Device Descriptor）Device Descriptor: bLength 18 bDescriptorType 1 bcdUSB 1.10 bDeviceClass 0 (Defined at Interface level) bDeviceSubClass 0 bDeviceProtocol 0 bMaxPacketSize0 16 idVendor 0x8888 idProduct 0x0001 bcdDevice 1.00 iManufacturer 1 iProduct 2 iSerial 3 bNumConfigurations 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//USB设备描述符的定义code uint8 DeviceDescriptor[]= //设备描述符为18字节&#123;//bLength字段。设备描述符的长度为18(0x12)字节 0x12,//bDescriptorType字段。设备描述符的编号为0x01 0x01,//bcdUSB字段。这里设置版本为USB1.1，即0x0110。//由于是小端结构，所以低字节在先，即0x10，0x01。 0x10, 0x01,//bDeviceClass字段。我们不在设备描述符中定义设备类，//而在接口描述符中定义设备类，所以该字段的值为0。 0x00,//bDeviceSubClass字段。bDeviceClass字段为0时，该字段也为0。 0x00,//bDeviceProtocol字段。bDeviceClass字段为0时，该字段也为0。 0x00,//bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。 0x10,//idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。//实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。//注意小端模式，低字节在先。 0x88, 0x88,//idProduct字段。产品ID号，由于是第一个实验，我们这里取0x0001。//注意小端模式，低字节应该在前。 0x01, 0x00,//bcdDevice字段。我们这个USB鼠标刚开始做，就叫它1.0版吧，即0x0100。//小端模式，低字节在先。 0x00, 0x01,//iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，//字符串索引就从1开始吧。 0x01,//iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。//注意字符串索引值不要使用相同的值。 0x02,//iSerialNumber字段。设备的序列号字符串索引值。//这里取3就可以了。 0x03,//bNumConfigurations字段。该设备所具有的配置数。//我们只需要一种配置就行了，因此该值设置为1。 0x01&#125;; 2.2.2 配置描述符（Configuration Descriptor）- 接口描述符（Interface Descriptor） - HID描述符（HID Device Descriptor）Configuration Descriptor: bLength 9 bDescriptorType 2 wTotalLength 34 bNumInterfaces 1 bConfigurationValue 1 iConfiguration 0 bmAttributes 0x80 (Bus Powered) MaxPower 100mA Interface Descriptor: bLength 9 bDescriptorType 4 bInterfaceNumber 0 bAlternateSetting 0 bNumEndpoints 1 bInterfaceClass 3 Human Interface Device bInterfaceSubClass 1 Boot Interface Subclass bInterfaceProtocol 2 Mouse iInterface 0 HID Device Descriptor: bLength 9 bDescriptorType 33 bcdHID 1.10 bCountryCode 33 US bNumDescriptors 1 bDescriptorType 34 Report wDescriptorLength 52 Report Descriptor: (length is 52) 略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//USB配置描述符集合的定义//配置描述符总长度为9+9+9+7字节code uint8 ConfigurationDescriptor[9+9+9+7]=&#123; /***************配置描述符***********************/ //bLength字段。配置描述符的长度为9字节。 0x09, //bDescriptorType字段。配置描述符编号为0x02。 0x02, //wTotalLength字段。配置描述符集合的总长度， //包括配置描述符本身、接口描述符、类描述符、端点描述符等。 sizeof(ConfigurationDescriptor)&amp;0xFF, //低字节 (sizeof(ConfigurationDescriptor)&gt;&gt;8)&amp;0xFF, //高字节 //bNumInterfaces字段。该配置包含的接口数，只有一个接口。 0x01, //bConfiguration字段。该配置的值为1。 0x01, //iConfigurationz字段，该配置的字符串索引。这里没有，为0。 0x00, //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的， //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。 0x80, //bMaxPower字段，该设备需要的最大电流量。由于我们的板子 //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位 //电流为2mA，所以这里设置为50(0x32)。 0x32, /*******************接口描述符*********************/ //bLength字段。接口描述符的长度为9字节。 0x09, //bDescriptorType字段。接口描述符的编号为0x04。 0x04, //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。 0x00, //bAlternateSetting字段。该接口的备用编号，为0。 0x00, //bNumEndpoints字段。非0端点的数目。由于USB鼠标只需要一个 //中断输入端点，因此该值为1。 0x01, //bInterfaceClass字段。该接口所使用的类。USB鼠标是HID类， //HID类的编码为0x03。 0x03, //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中， //只规定了一种子类：支持BIOS引导启动的子类。 //USB键盘、鼠标属于该子类，子类代码为0x01。 0x01, //bInterfaceProtocol字段。如果子类为支持引导启动的子类， //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。 0x02, //iConfiguration字段。该接口的字符串索引值。这里没有，为0。 0x00, /******************HID描述符************************/ //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。 0x09, //bDescriptorType字段。HID描述符的编号为0x21。 0x21, //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。 0x10, 0x01, //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。 0x21, //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。 0x01, //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。 0x22, //bDescriptorLength字段。下级描述符的长度。下级描述符为报告描述符。 sizeof(ReportDescriptor)&amp;0xFF, (sizeof(ReportDescriptor)&gt;&gt;8)&amp;0xFF, /**********************端点描述符***********************/ //bLength字段。端点描述符长度为7字节。 0x07, //bDescriptorType字段。端点描述符编号为0x05。 0x05, //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。 //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。 0x81, //bmAttributes字段。D1~D0为端点传输类型选择。 //该端点为中断端点。中断端点的编号为3。其它位保留为0。 0x03, //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。 //注意低字节在先。 0x10, 0x00, //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。 0x0A&#125;; 2.2.3 报告描述符（Report Descriptor）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//USB报告描述符的定义code uint8 ReportDescriptor[]=&#123; //每行开始的第一字节为该条目的前缀，前缀的格式为： //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。 //这是一个全局（bType为1）条目，选择用途页为普通桌面Generic Desktop Page(0x01) //后面跟一字节数据（bSize为1），后面的字节数就不注释了， //自己根据bSize来判断。 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //这是一个局部（bType为2）条目，说明接下来的应用集合用途用于鼠标 0x09, 0x02, // USAGE (Mouse) //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示 //该集合是一个应用集合。它的性质在前面由用途页和用途定义为 //普通桌面用的鼠标。 0xa1, 0x01, // COLLECTION (Application) //这是一个局部条目。说明用途为指针集合 0x09, 0x01, // USAGE (Pointer) //这是一个主条目，开集合，后面跟的数据0x00表示该集合是一个 //物理集合，用途由前面的局部条目定义为指针集合。 0xa1, 0x00, // COLLECTION (Physical) //这是一个全局条目，选择用途页为按键（Button Page(0x09)） 0x05, 0x09, // USAGE_PAGE (Button) //这是一个局部条目，说明用途的最小值为1。实际上是鼠标左键。 0x19, 0x01, // USAGE_MINIMUM (Button 1) //这是一个局部条目，说明用途的最大值为3。实际上是鼠标中键。 0x29, 0x03, // USAGE_MAXIMUM (Button 3) //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值啦） //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。 0x15, 0x00, // LOGICAL_MINIMUM (0) //这是一个全局条目，说明逻辑值最大为1。 0x25, 0x01, // LOGICAL_MAXIMUM (1) //这是一个全局条目，说明数据域的数量为三个。 0x95, 0x03, // REPORT_COUNT (3) //这是一个全局条目，说明每个数据域的长度为1个bit。 0x75, 0x01, // REPORT_SIZE (1) //这是一个主条目，说明有3个长度为1bit的数据域（数量和长度 //由前面的两个全局条目所定义）用来做为输入， //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示 //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。 //这样定义的结果就是，第一个数据域bit0表示按键1（左键）是否按下， //第二个数据域bit1表示按键2（右键）是否按下，第三个数据域bit2表示 //按键3（中键）是否按下。 0x81, 0x02, // INPUT (Data,Var,Abs) //这是一个全局条目，说明数据域数量为1个 0x95, 0x01, // REPORT_COUNT (1) //这是一个全局条目，说明每个数据域的长度为5bit。 0x75, 0x05, // REPORT_SIZE (5) //这是一个主条目，输入用，由前面两个全局条目可知，长度为5bit， //数量为1个。它的属性为常量（即返回的数据一直是0）。 //这个只是为了凑齐一个字节（前面用了3个bit）而填充的一些数据 //而已，所以它是没有实际用途的。 0x81, 0x03, // INPUT (Cnst,Var,Abs) //这是一个全局条目，选择用途页为普通桌面Generic Desktop Page(0x01) 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //这是一个局部条目，说明用途为X轴 0x09, 0x30, // USAGE (X) //这是一个局部条目，说明用途为Y轴 0x09, 0x31, // USAGE (Y) //这是一个局部条目，说明用途为滚轮 0x09, 0x38, // USAGE (Wheel) //下面两个为全局条目，说明返回的逻辑最小和最大值。 //因为鼠标指针移动时，通常是用相对值来表示的， //相对值的意思就是，当指针移动时，只发送移动量。 //往右移动时，X值为正；往下移动时，Y值为正。 //对于滚轮，当滚轮往上滚时，值为正。 0x15, 0x81, // LOGICAL_MINIMUM (-127) 0x25, 0x7f, // LOGICAL_MAXIMUM (127) //这是一个全局条目，说明数据域的长度为8bit。 0x75, 0x08, // REPORT_SIZE (8) //这是一个全局条目，说明数据域的个数为3个。 0x95, 0x03, // REPORT_COUNT (3) //这是一个主条目。它说明这三个8bit的数据域是输入用的， //属性为：Data,Var,Rel。Data说明数据是可以变的，Var说明 //这些数据域是独立的，即第一个8bit表示X轴，第二个8bit表示 //Y轴，第三个8bit表示滚轮。Rel表示这些值是相对值。 0x81, 0x06, // INPUT (Data,Var,Rel) //下面这两个主条目用来关闭前面的集合用。 //我们开了两个集合，所以要关两次。bSize为0，所以后面没数据。 0xc0, // END_COLLECTION 0xc0 // END_COLLECTION&#125;;//通过上面的报告描述符的定义，我们知道返回的输入报告具有4字节。//第一字节的低3位用来表示按键是否按下的，高5位为常数0，无用。//第二字节表示X轴改的变量，第三字节表示Y轴的改变量，第四字节表示//滚轮的改变量。我们在中断端点1中应该要按照上面的格式返回实际的//鼠标数据。 三、QAQ:lsusb获取Report Descriptor异常A:Report Descriptors: UNAVAILABLE 获取Report Descriptorshttp://www.slashdev.ca/2010/05/08/get-usb-report-descriptor-with-linux/]]></content>
  </entry>
  <entry>
    <title><![CDATA[USB学习]]></title>
    <url>%2F2020%2F07%2F27%2FUSB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[USB学习1. 动机从事汽车电子行业以来，了解到了诸多之前没有接触过的领域，对于一个一直从事中间件开发的我来说，受益匪浅。工作的中心主要是手机互联相关业务，所涉及的领域比较多，多媒体，gstreamer，alsa，USB驱动，iap协议等。自觉除了USB驱动，其他内容都有略知一二，出问题都能从容应对，唯有USB驱动仍是软肋，一直在心中作梗。遂借工作之余，打算探个究竟。 2. 方法应用出生，当然是从应用入手，大概了解了内核驱动实现之后，觉得对USB的理解还是稍有欠缺。遂想到一句古话：纸上得来终觉浅，绝知此事要躬行。 USB in a NutShell https://www.beyondlogic.org/usbnutshell/usb1.shtml 大概了解USB的整体框架 《圈圈教你玩USB》 不可多得的好书，不过并不适合的零基础的人。要有51单片机的基础，USB相关知识。 参考该书实现一个USB外设，对USB有了更深的了解。做一个外设并不容易，还需要参考 《PDIUSBD12》和《AT89C52》手册，弄懂芯片的协议。 《Linux那些事儿之我是USB》 说实话，作者可能很懂USB，但是讲的内容并不像书的名字这么通俗易懂，可能驱动层就是这么难懂吧。可以协助阅读内核相关代码。 《usb_20》 当然，终极目标解释理解spec了，其他都是实现，这个还是内功。 3. 感悟说实话，互联网所谓的全栈工程师，跟嵌入式相比，感觉还是小巫见大巫了。单讲USB，从应用 - 驱动 - USB器件 - MCU(固件) - 设备(LED)。没有点基础还真吃不消。USB整体框图：]]></content>
      <tags>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以二项式系数概括]]></title>
    <url>%2F2019%2F03%2F19%2F%E4%BB%A5%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%E6%A6%82%E6%8B%AC%2F</url>
    <content type="text"><![CDATA[Fair Coin: Flip 4 times获得1个Head的概率P(exactly 1 “heads”) = P(HTTT) +P(THTT)+P(TTHT)+P(TTTH)= $\frac{1}{16}$+$\frac{1}{16}$+$\frac{1}{16}$+$\frac{1}{16}$=1/4 获得2个Head的概率4次里面选2次 $C_4^2=\frac{43}{21} = 6$P(exactly 2 “heads”) =$\frac{C_4^2}{16}$ = 3/8 Fair Coin: Flip 5 flips获得3个Head的概率5次里面选3次 $C_5^3=\frac{543}{321} = 10$P(exactly 3 “heads”) =$\frac{C_5^3}{32} $ = 5/16 Fair Coin: Flip n flips获得k个Head的概率n次里面选k次 $C_n^k= \frac{\frac{n!}{(n-k!)}}{k!}=\frac{n(n-1)…(n-k+1)}{k(k-1)…1}$all the probability = $2^{n}$P(exactly k “heads”) =$\frac{n(n-1)…(n-k+1)}{2^{n}k*(k-1)…1}$]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本概率]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%9F%BA%E6%9C%AC%E6%A6%82%E7%8E%87%2F</url>
    <content type="text"><![CDATA[ProbabilityP(H) = # of possibility that meet by condition / # of equally likely possibility]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扑克中的概率和文氏图]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%89%91%E5%85%8B%E4%B8%AD%E7%9A%84%E6%A6%82%E7%8E%87%E5%92%8C%E6%96%87%E6%B0%8F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[扑克中的概率P(Jack) = 4/52 = 1/13 P(♥) = 13/52 = 1/4 P(J and ♥) = 1/52 p(J or ♥) = (4+13-1)/52 = 16/52 = 4/13 文氏图1234567891011121314151617181920'''' # of Jacks / / +---------/--------------------------+ | / 52 | | /--/--\ | | | 4 | | | | /-----------\ | | \---|./ | | | ,'` 13 | | | _-` | | | | .' \--------\--/ | ,-` \ | # of J -` | \ | and ♥ | \ | +---------------------\--------------+ \ # of ♥ '''']]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列组合]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[定义排列排列的定义：从n个不同元素中，任取m(m≤n,m与n均为自然数,下同）个元素按照一定的顺序排成一列，叫做从n个不同元素中取出m个元素的一个排列；从n个不同元素中取出m(m≤n）个元素的所有排列的个数，叫做从n个不同元素中取出m个元素的排列数，用符号 A(n,m）表示。$$计算公式：A^m_n = n(n-1)(n-2)…（n-m+1）=\frac{n!}{(n-m)!}$$ 组合组合的定义：从n个不同元素中，任取m(m≤n）个元素并成一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m≤n）个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数。用符号 C(n,m) 表示。$$计算公式：C^m_n =C^n_r=C^n_{n-r}=\frac{A^m_n}{m!}=\frac{n!}{m!(n-m)!};C(n,m)=C(n,n-m).n&gt;=m\\C^r_n =\binom{n}{r}=\dbinom{n}{n-r}$$]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率相加]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%A6%82%E7%8E%87%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[概率相加P(A or B) = P(A) + P(B) - P(A and B) 文氏图12345678910111213141516171819''' +-----------------------------------------+ | | | /----------------\ | | | | | | | A | | | | /--------------------\ | | | | A | | | | | | and | B | | | | | B | | | | | | | | | | \----------|-----/ | | | | | | | | | | | \--------------------/ | | | +-----------------------------------------+ ''']]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立事件]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8B%AC%E7%AB%8B%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Find the probability of getting exactly two “head” when flipping three coins. HHH THH HHT THT HTH TTH HTT TTT $$p(2’H’) = \frac{3}{8}$$ 计算骰子的概率两个骰子一次投掷得到的数值和：方法1：枚举| | 1 | 2 | 3 | 4 | 5 | 6 || —- | —- | —- | —- | —- | —- | —- || 1 | 2 | 3 | 4 | 5 | 6 | 7 || 2 | 3 | 4 | 5 | 6 | 7 | 8 || 3 | 4 | 5 | 6 | 7 | 8 | 9 || 4 | 5 | 6 | 7 | 8 | 9 | 10 || 5 | 6 | 7 | 8 | 9 | 10 | 11 || 6 | 7 | 8 | 9 | 10 | 11 | 12 |P(7) = 6/36方法2：P(5) = 4 / 36| D1 | D2 || —- | —- || 1 | 4 || 2 | 3 || 3 | 2 || 4 | 1 |]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立事件的组合概率]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8B%AC%E7%AB%8B%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%84%E5%90%88%E6%A6%82%E7%8E%87%2F</url>
    <content type="text"><![CDATA[独立事件的组合概率P(H)= 1/2 P(T) = 1/2 Two way to figure out the result1. 枚举出所有的情况P(H,H) = 1/4 (H,H ; H,T ; T,H ; T,T) 2. 每次事件都是独立的，计算独立事件都发生的概率P(H,H) = P(H) P(H) = (1/2) (1/2) = 1/4 P(T,H,T) = P(T) P(H) P(T) = (1/2) (1/2) (1/2) = 1/8]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相依事件的概率]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%9B%B8%E4%BE%9D%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%A6%82%E7%8E%87%2F</url>
    <content type="text"><![CDATA[剩下的35张取到1的概率36张卡片，分别1-9的四种花色(方块，红桃，梅花，黑桃)的卡片。随机取出9张，其中有四张是1的概率是多少？ 解法1P(all 4 cards is 1 in my hand of 9) = (# of ways in which event can happened)/(the total # of hands) total # of hands = $\frac{363534333231302928}{987654321}$ the # of hands with 4 1’s = $\frac{11113231302928}{54321}$ P(all 4 cards is 1 in my hand of 9) = $\frac{11113231302928}{54321} \frac{987654321}{3635343332313029*28}$= $\frac{2}{935}$ 解法2 取到一张1的概率 剩下的35张取到1的概率 剩下的34张取到1的概率 剩下的33张取到1的概率 $\frac{1}{36}*9$ $\frac{1}{35}*8$ $\frac{1}{34}*7$ $\frac{1}{33}*6$]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝叶斯定理]]></title>
    <url>%2F2019%2F03%2F19%2F%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[贝叶斯定理:$$P(b|a) = \frac{P(a|b)P(b)}{P(a)}$$证明：$P(a \cap b) = P(a|b)P(b)$$P(a \cap b) = P(b \cap a) = P(b|a)P(a)$$P(a|b)P(b) = P(b|a)P(a)$$P(b|a) = \frac{P(a|b)P(b)}{P(a)}$ Ex1:一个袋子里有：5个均匀的硬币，10个不均匀的硬币(0.8 H, 0.2 T)求：取6枚4枚是Head，都是去的均匀硬币的概率。即：P(Fair|4/6 Heads)$P(Fair|4/6 Heads) = \frac{P(4/6 Heads|Fair)P(Fair)}{P(4/6 Heads)}$ Ex2:一个班上有30个学生，至少2个同学生日是同一天的概率。解：P(至少2个同学生日是同一天) = 1 - P(没有同学生日在同一天)P(没有同学生日在同一天) = $\frac{A^{30}_{365}}{365^{30}}$]]></content>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i.Max6移植Movidius]]></title>
    <url>%2F2019%2F01%2F14%2Fi.Max6%E7%A7%BB%E6%A4%8DMovidius%2F</url>
    <content type="text"><![CDATA[0、概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时隔半年有余，由于工作的原因没能更新机器学习方面的内容。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之间林林总总，看完了《UNIX网络编程卷1：套接字联网API（第3版）》，《Linux多线程服务端编程：使用muduo C++网络库》和《Netty权威指南》的部分章节，完成了Tbox Telemetics模块的设计和编码，在这之前其实已对网络编程有所了解，也尝试用MFC编写过类QQ的sample，只是功能简单，单客户端/单服务端之间的通信，然真正用于网络通信的协议未曾染指。网络编程方面的知识，在这次的开发工作中得以锻炼，略有心得一二。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更换项目的间隙，中间有空闲二周，正直双十一，遂购架构书籍数本，看完《架构整洁之道》开始对于软件架构有了进一步的了解，科室读书会分享之，感觉功力倍增。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新年交替之际，开始AI实验室的预研，主要针对边缘计算，驾驶行为分析。嵌入式的硬件限制，只能外挂计算棒，开始研究Intel的Movidius，接触到了OpenVINO工具套件。本篇主要就是介绍一下NCS2在树莓派上的移植。 1、环境搭建 树莓派。系统Raspbian* 9 OS，官网下载最新版本即可。 The Intel™ Distribution of OpenVINO™ for Raspbian OS package to download is here and the Installation document here. 2、步骤IntroductionThis guide applies to 32-bit Raspbian 9 OS, which is an official OS for Raspberry Pi boards. IMPORTANT: All steps in this guide are required unless otherwise stated. The Intel® Distribution of OpenVINO™ toolkit for Raspbian* OS includes the MYRIAD plugin &gt;only. You can use it with the Intel® Movidius™ Neural Compute Stick (Intel® NCS) or the Intel® &gt;Neural Compute Stick 2 plugged in one of USB ports. ###About the Intel® Distribution of OpenVINO™ ToolkitThe Intel® Distribution of OpenVINO™ toolkit quickly deploys applications and solutions that emulate human vision. Based on Convolutional Neural Networks (CNN), the toolkit extends computer vision (CV) workloads across Intel® hardware, maximizing performance. The Intel Distribution of OpenVINO toolkit includes the Intel® Deep Learning Deployment Toolkit (Intel® DLDT). ###Included in the Installation PackageThe Intel Distribution of OpenVINO toolkit for Raspbian OS is an archive with pre-installed header files and libraries. The following components are installed by default: Component Description Inference Engine This is the engine that runs the deep learning model. It includes a set of libraries for an easy inference integration into your applications. OpenCV* version 4.0 OpenCV* community version compiled for Intel® hardware. Sample Applications A set of simple console applications demonstrating how to use the Inference Engine in your applications. ###System Requirements ###Hardware: Raspberry Pi* board with ARMv7-A CPU architectureOne of Intel® Movidius™ Visual Processing Units (VPU):Intel® Movidius™ Neural Compute StickIntel® Neural Compute Stick 2 ###Operating Systems: Raspbian* Stretch, 32-bit Install the PackageOpen the Terminal* or your preferred console application.Go to the directory in which you downloaded the Intel Distribution of OpenVINO toolkit. This document assumes this is your ~/Downloads directory. If not, replace ~/Downloads with the directory where the file is located. cd ~/Downloads/ By default, the package file is saved as l_openvino_toolkit_ie_p_.tgz.Unpack the archive: tar -xf l_openvino_toolkit_ie_p_.tgz Modify the setupvars.sh script by replacing with the absolute path to the installation folder: sed -i “s||$(pwd)/inference_engine_vpu_arm|” inference_engine_vpu_arm/bin/setupvars.shNow the Intel Distribution of OpenVINO toolkit is ready to be used. Continue to the next sections to configure the environment and set up USB rules. Set the Environment VariablesYou must update several environment variables before you can compile and run Intel Distribution of OpenVINO toolkit applications. Run the following script to temporarily set the environment variables: source inference_engine_vpu_arm/bin/setupvars.sh (Optional) The Intel Distribution of OpenVINO environment variables are removed when you close the shell. As an option, you can permanently set the environment variables as follows: Open the .bashrc file in : vi /.bashrc Add this line to the end of the file: source ~/Downloads/inference_engine_vpu_arm/bin/setupvars.sh Save and close the file: press Esc and type :wq.To test your change, open a new terminal.You will see the following: [setupvars.sh] OpenVINO environment initialized Add USB RulesAdd the current Linux user to the users group: sudo usermod -a -G users “$(whoami)” Log out and log in for it to take effect. To perform inference on the Intel® Movidius™ Neural Compute Stick or Intel® Neural Compute Stick 2, install the USB rules as follows: sh inference_engine_vpu_arm/install_dependencies/install_NCS_udev_rules.sh Build and Run Object Detection SampleFollow the next steps to run pre-trained Face Detection network using samples from Intel Distribution of OpenVINO toolkit: Go to the folder with samples source code: cd inference_engine_vpu_arm/deployment_tools/inference_engine/samples Create build directory: mkdir build &amp;&amp; cd build Build the Object Detection Sample: cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=”-march=armv7-a”make -j2 object_detection_sample_ssd Download the pre-trained Face Detection model or copy it from a host machine:To download the .bin file with weights: wget –no-check-certificate https://download.01.org/openvinotoolkit/2018_R4/open_model_zoo/face-detection-adas-0001/FP16/face-detection-adas-0001.bin To download the .xml file with the network topology: wget –no-check-certificate https://download.01.org/openvinotoolkit/2018_R4/open_model_zoo/face-detection-adas-0001/FP16/face-detection-adas-0001.xml Run the sample with specified path to the model:Copy Code ./armv7l/Release/object_detection_sample_ssd -m face-detection-adas-0001.xml -d MYRIAD -i Run Face Detection Model Using OpenCV* APITo validate OpenCV installation, you may try to run OpenCV’s deep learning module with Inference Engine backend. Here is a Python sample, which works with Face Detection model: Download the pre-trained Face Detection model or copy it from a host machine:To download the .bin file with weights: wget –no-check-certificate https://download.01.org/openvinotoolkit/2018_R4/open_model_zoo/face-detection-adas-0001/FP16/face-detection-adas-0001.bin To download the .xml file with the network topology: wget –no-check-certificate https://download.01.org/openvinotoolkit/2018_R4/open_model_zoo/face-detection-adas-0001/FP16/face-detection-adas-0001.xml Create a new Python file named as openvino_fd_myriad.py and copy the following script there:12345678910111213141516171819202122232425262728import cv2 as cv# Load the model net = cv.dnn.readNet('face-detection-adas-0001.xml', 'face-detection-adas-0001.bin') # Specify target device net.setPreferableTarget(cv.dnn.DNN_TARGET_MYRIAD) # Read an image frame = cv.imread('/path/to/image') # Prepare input blob and perform an inference blob = cv.dnn.blobFromImage(frame, size=(672, 384), ddepth=cv.CV_8U) net.setInput(blob) out = net.forward() # Draw detected faces on the frame for detection in out.reshape(-1, 7): confidence = float(detection[2]) xmin = int(detection[3] * frame.shape[1]) ymin = int(detection[4] * frame.shape[0]) xmax = int(detection[5] * frame.shape[1]) ymax = int(detection[6] * frame.shape[0]) if confidence &gt; 0.5: cv.rectangle(frame, (xmin, ymin), (xmax, ymax), color=(0, 255, 0))# Save the frame to an image file cv.imwrite('out.png', frame) Run the script: python3 openvino_fd_myriad.py In this script, OpenCV* loads the Face Detection model in the Intermediate Representation (IR) format and an image. Then it runs the model and saves an image with detected faces. 3、i.Max6移植&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理论上树莓派上编译的产物可以直接拷贝到相同处理器架构的i.Max6上(CPU都是ARMv7)，不过由于各个公司BSP对内核裁剪和集成编译的时候包含的软件包不同，需要修改的内容也不尽相同。这里写的是本司的开发板环境缺少的依赖： python3 lsb_release libstdc++ -&gt; 3.4.22 vi inference_engine_vpu_arm/install_dependencies/install_NCS_udev_rules.sh:%s/sudo//g #删除所有的sudo touch /etc/ld.so.conf 4、总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初步了解OpenVINO发现其是一大宝藏，里面包含了几十种流行模型的，并且有大量sample可以参考学习，可以通过组合各个模型实现自己想要的功能。增加对机器学习的实战经验，加深对机器学习的理解。遗憾的是Intel的NCS2目前貌似只支持深度学习的预测，之于一般的机器学习模型是否也支持，有待考证。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld驱动模块]]></title>
    <url>%2F2018%2F09%2F17%2FHelloWorld%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[0、概述本章主要通过一个简单的实例，实现驱动模块的加载和卸载，并不实现具体的功能。 1、介绍1.1、编写hello.c1234567891011121314151617#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;MODULE_LICENSE("Dual BSD/GPL");static int hello_init(void)&#123; printk(KERN_ALERT "Hello, world\n");&#125;static void hello_exit(void)&#123; printk(KERN_ALERT "Goodbye, cruel world\n");&#125;module_init(hello_init);module_exit(hello_exit); 这个模块定义了两个函数，一个在模块加载到内核时被调用（hello_init），一个在模块去除时被调用（hello_exit）。module_init和module_exit这几行使用了特别的内核宏来指出这两个函数的角色。另一个特别的宏（MODULE_LICENSE）是用来告知内核，该模块带有一个自由的许可证，没有这样的说明，在模块加载时内核会报错。 printk函数在Linux内核中定义并且对模块可用，它与标准C库函数printf的行为相似。内核需要它自己的打印函数，因为没有C库的支持。字串KERN_ALERT是消息的优先级。在此模块中指定了一个高优先级，因为使用默认优先级的消息可能不会直接显示，这依赖于运行的内核版本、klogd守护进程的版本以及配置。 1.2、编写Makefile为了编译模块文件，有两种方法创建Makefile文件可以实现:1、只需一行即可，命令如下： obj-m := hello.o obj-m指出将要编译成的内核模块列表。.o 格式文件会自动地由相应的 .c 文件生成（不需要显式地罗列所有源代码文件）如果要把上述程序编译为一个运行时加载和删除的模块，则编译命令如下所示。 make -C /usr/src/kernels/2.6.25-14.fc9.i686 M=$PWD modules 这个命令首先是改变目录到用 -C 选项指定的位置（即内核源代码目录，这个参数要根据自己的情况而定）。这个 M= 选项使Makefile在构造modules目标前，返回到模块源码目录。然后，modules目标指向obj-m变量中设定的模块。这里的编译规则的意思是：在包含内核源代码位置的地方进行make，然后再编译 $PWD （当前）目录下的modules。这里允许我们使用所有定义在内核源代码树下的所有规则来编译我们的内核模块。 2、使用下面的Makefile来实现：12345678ifneq ($(KERNELRELEASE),) obj-m := hello.oelse KERNELDIR ?= /lib/modules/$(shell uname -r)/build PWD :=$(shell pwd)default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modulesendif 然后保存后，使用make命令。编译完毕之后，就会在源代码目录下生成hello.ko文件，这就是内核驱动模块了。我们使用下面的命令来加载hello模块。 1.3、效果 dmesg | tail 这时，在终端里就会打印出内核信息了。同时，也可以使用lsmod命令来查看是否有加载了 xuleilx@xuleilx-MS-7817:/opt# lsmodModule Size Used byhelloworld 12448 0 至此，一个最简单的内核模块驱动程序就完成了。^_^ 2、总结至此，打开通往内核的大门。 下一步计划：编写字符设备驱动，可以存放一些数值。]]></content>
      <tags>
        <tag>Driver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidFramework学习之旅]]></title>
    <url>%2F2018%2F09%2F11%2FAndroidFrameWork%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[作为一名开发者，Linux内核源码必定是其追求的终极目标。自觉愚钝，一直未敢染指Linux 内核源码。工作八年有余，解决Bug无数，设计模式，重构，STL库等也熟知一二，然对于一 些涉及底层的问题未能深入剖析，自觉功力不足。 近几年机器学习嫣然成为风口浪尖的弄潮儿，于是自学半年有余，略有心得，自觉入门。然在 实际工作和运用中缺乏实战机会，且与自己的职业生涯规划略有出入，遂放缓脚步，寻找更好 的学习点。 Android系统一直是Linux开发者鄙夷的对象，愚随大流，以勉Android代码为耻，然 Android数年以来表现依然如此强势，尤近年来车载行业对于Android系统的接纳，传统车载 行业必然会受到一定的冲击，Android系统的架构也是经受过数年的考验，其架构的成熟性以 及通用性耳目共睹，遂决定开始学习Android系统架构。 于是开始我的Android系统的学习之旅，对于学习这件事，随着年龄的增长，也有了自己独特 的一套方法。一般会去知乎上搜索一些对于一门技术的学习方法或是推荐书籍，于是检索到： https://www.zhihu.com/question/19759722 看完这些文章所说的对于C/C++和Linux系统知识 的要求后信心倍增，自觉对于这些方面的知识很有自信。 第一阶段打算跟着&quot;老罗的Android之旅&quot;，学完之后也应该有自己的一套知识体系了。先从内 核入手，不求甚解，能够摸索出内核代码的阅读方法，就已经足够，也不指望看一遍书就能摸 透。根据 老罗的Android之旅 提到的《Linux Kernel Development》、 《Understanding the Linux Kernel》、《Linux Device Drivers》和 《Linux内核源代码情景分析》开始入手内核。 分成两个阶段：内核学习，安卓FrameWork 第一阶段，开始我的内核学习之旅： 1.编译Android系统代码 2018/08/27 ~ 2.《Linux Kernel Development》 2018/08/27 ~ 2018/09/07 3.字符设备驱动程序 2018/09/11 ~ 4.《LDD3》 2018/09/11 ~]]></content>
      <tags>
        <tag>AndroidFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataVisualisation]]></title>
    <url>%2F2018%2F06%2F28%2FDataVisualisation%2F</url>
    <content type="text"><![CDATA[0、概述本阶段完成了关于数据可视化的学习，这部分的学习为我打开了一扇通往新世界的大门。 一个人如果能再某个领域成为专家就已经是一件很了不起的事情了，对于MachineLearner来说，将会面对不同领域的问题，需要具备不同的DomainKnowledge是一件几乎不可能的事情，可能我们通过几周或者甚至几天的学习，对问题领域有个大概的了解，但是对不同的Feature之间的关系，影响可能就无法知晓了，当然我们可以通过咨询相应领域的专家，不过这实际上也是一件相当不易的事情。 数据可视化就想武器中的瑞士军刀，它将数据以图表的形式展现在MachineLearner的面前，通过观察图表，我们可以知道数据与数据之间的联系，可以连接到数据的走上，范围，概率分布等。通过这些，我们可以方便的挑选适合我们模型的Features。 1、思维导图 2、使用方法2.1、Univariate plotting with pandas1234567891011121314151617181920import pandas as pdreviews = pd.read_csv("../input/wine-reviews/winemag-data_first150k.csv", index_col=0)reviews.head(3)# Bar Chat# Good for nominal and small ordinal categorical data.reviews['province'].value_counts().head(10).plot.bar()(reviews['province'].value_counts().head(10) / len(reviews)).plot.bar()reviews['points'].value_counts().sort_index().plot.bar()# Line charts# Good for ordinal categorical and interval data.reviews['points'].value_counts().sort_index().plot.line()# Area charts# Good for ordinal categorical and interval data.reviews['points'].value_counts().sort_index().plot.area()# Histogram# Good for interval data.reviews[reviews['price'] &lt; 200]['price'].plot.hist() 2.2、Bivariate plotting with pandas1234567891011121314151617181920212223import pandas as pdreviews = pd.read_csv("../input/wine-reviews/winemag-data_first150k.csv", index_col=0)reviews.head()# Scatter Plot# Good for interval and some nominal categorical data.reviews[reviews['price'] &lt; 100].sample(100).plot.scatter(x='price', y='points')# Hex Plot# Good for interval and some nominal categorical data.reviews[reviews['price'] &lt; 100].plot.hexbin(x='price', y='points', gridsize=15)# Stacked Bar Chart# Good for nominal and ordinal categorical data.wine_counts = pd.read_csv("../input/most-common-wine-scores/top-five-wine-score-counts.csv",index_col=0)wine_counts.head()wine_counts.plot.bar(stacked=True)wine_counts.plot.area()# Bivariate Line Chart# Good for ordinal categorical and interval data.wine_counts.plot.line() 2.3、Multivariate plotting with pandas123456789101112131415161718192021222324252627282930import pandas as pdpd.set_option('max_columns', None)df = pd.read_csv("../input/fifa-18-demo-player-dataset/CompleteDataset.csv", index_col=0)import reimport numpy as npfootballers = df.copy()footballers['Unit'] = df['Value'].str[-1]footballers['Value (M)'] = np.where(footballers['Unit'] == '0', 0, footballers['Value'].str[1:-1].replace(r'[a-zA-Z]',''))footballers['Value (M)'] = footballers['Value (M)'].astype(float)footballers['Value (M)'] = np.where(footballers['Unit'] == 'M', footballers['Value (M)'], footballers['Value (M)']/1000)footballers = footballers.assign(Value=footballers['Value (M)'], Position=footballers['Preferred Positions'].str.split().str[0])# Parallel Coordinatesfrom pandas.plotting import parallel_coordinatesf = ( footballers.iloc[:, 12:17] .loc[footballers['Position'].isin(['ST', 'GK'])] .applymap(lambda v: int(v) if str.isdecimal(v) else np.nan) .dropna())f['Position'] = footballers['Position']f = f.sample(200)parallel_coordinates(f, 'Position') 2.4、Plotting with seaborn123456789101112131415161718192021222324252627282930313233343536import pandas as pdreviews = pd.read_csv("../input/wine-reviews/winemag-data_first150k.csv", index_col=0)import seaborn as sns# Count (Bar) Plot# Good for nominal and small ordinal categorical data.sns.countplot(reviews['points'])# KDE Plot# Good for interval data.sns.kdeplot(reviews.query('price &lt; 200').price)sns.kdeplot(reviews[reviews['price'] &lt; 200].loc[:, ['price', 'points']].dropna().sample(5000))# Distplotsns.distplot(reviews['points'], bins=10, kde=False)# Joint (Hex) Plot# Good for interval and some nominal categorical data.sns.jointplot(x='price', y='points', data=reviews[reviews['price'] &lt; 100])sns.jointplot(x='price', y='points', data=reviews[reviews['price'] &lt; 100], kind='hex', gridsize=20)# Boxplot and violin plot# Good for interval data and some nominal categorical data.df = reviews[reviews.variety.isin(reviews.variety.value_counts().head(5).index)]sns.boxplot( x='variety', y='points', data=df)sns.violinplot( x='variety', y='points', data=reviews[reviews.variety.isin(reviews.variety.value_counts()[:5].index)]) 2.5、Faceting with seaborn1234567891011121314151617# Facet Grid# Good for data with at least two categorical variables.import seaborn as snsdf = footballers[footballers['Position'].isin(['ST', 'GK'])]g = sns.FacetGrid(df, col="Position")g.map(sns.kdeplot, "Overall")g = sns.FacetGrid(df, col="Position", col_wrap=6)g.map(sns.kdeplot, "Overall")df = df[df['Club'].isin(['Real Madrid CF', 'FC Barcelona', 'Atlético Madrid'])]g = sns.FacetGrid(df, row="Position", col="Club")g.map(sns.violinplot, "Overall")# Pair Plot# Good for exploring most kinds of data.sns.pairplot(footballers[['Overall', 'Potential', 'Value']]) 2.6、Multivariate plotting with seaborn1234567891011121314151617181920212223# Multivariate Scatter Plotsns.lmplot(x='Value', y='Overall', markers=['o', 'x', '*'], hue='Position', data=footballers.loc[footballers['Position'].isin(['ST', 'RW', 'LW'])], fit_reg=False )# Grouped Box Plotf = (footballers .loc[footballers['Position'].isin(['ST', 'GK'])] .loc[:, ['Value', 'Overall', 'Aggression', 'Position']] )f = f[f["Overall"] &gt;= 80]f = f[f["Overall"] &lt; 85]f['Aggression'] = f['Aggression'].astype(float)sns.boxplot(x="Overall", y="Aggression", hue='Position', data=f)# Heatmapf = ( footballers.loc[:, ['Acceleration', 'Aggression', 'Agility', 'Balance', 'Ball control']] .applymap(lambda v: int(v) if str.isdecimal(v) else np.nan) .dropna()).corr()sns.heatmap(f, annot=True) 3、总结通过这一阶段的学习，掌握了主流的python库pandas，seaborn的绘图方法，之前学习的matplotlib的知识也在这段时间稍微复习了一下，希望在今后的实践中好好运用数据可视化这部分的知识。并且帮助评价训练出来的模型。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas总结]]></title>
    <url>%2F2018%2F06%2F25%2Fpandas%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0、概述 这段时间主要学习了kaggle网站上的“pandas”的部分。俗话说的好：学过的东西通过 自己的理解转换成自己的东西才算是学会。所以说每学完一个知识点都要做一个总结，依赖理 清自己的只是结构，而来温故而知新。网址：https://www.kaggle.com/learn/pandas 最近刚从知乎上看到一个帖子，主要是讲如何学习，成为别人眼中的学霸。总结了一下主 要有以下四点（排名不分先后）：1、自律 2、目标 3、计划 4、理解。所以逼着自己学 完一个知识点写总结，旅游要写游记。与自己死磕到底。 1、思维导图 2、使用方法 本阶段刚刚接触Pandas不久，给我总体的印象是不需要专门的学习，pandas只是工 具，需要的时候可以网上查询，一般的需求这样就可以满足了。如果想对数据进行分析就需要 系统的学习一下，很多功能网上说的不清楚，一些学的半斤八两的人喜欢发这些玩意儿，学一 下官网的Tutorials和Cookbook。网址：http://pandas.pydata.org/pandas-docs/stable/ 3、总结 回想4,5年前在FNST使用Ruby制作语音播报工具，学到的东西还是挺多的，接触到了 CSV/EXCEL文件操作，面向对象语言的进一步理解，lambda，无数据类型语言，TTS等。现 在感叹为啥不适用Python啊，现在就不要学了，不过Python和Ruby很像，学起来很快就上 手了。CSV/EXCEL文件操作不就是现在学的pandas嘛。哈哈~ 学无止境，学海无涯。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习总结]]></title>
    <url>%2F2018%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0、概述 这段时间主要学习了kaggle网站上的“机器学习”的部分。之前很长一段时间都是在学习 理论，没有机会实践，Kaggle是个不错的平台，有很多使用的难题等待着全世界聪敏的头脑 去解决。通过本篇的学习，很好的将理论知识用到了实践当中，比如之前学习到的绘制模型在 样本集和测试集上的准确率，防止模型过拟合和欠拟合，选择最优的点。还有之前不明白交叉 验证的作用，以及实际效果。网址：https://www.kaggle.com/learn/machine-learning 1、思维导图 2、步骤2.1、分析数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354############## 观察数据 ##############import pandas as pd# save filepath to variable for easier accessmelbourne_file_path = '../input/melbourne-housing-snapshot/melb_data.csv'# read the data and store data in DataFrame titled melbourne_datamelbourne_data = pd.read_csv(melbourne_file_path) # print a summary of the data in Melbourne dataprint(melbourne_data.describe())print(melbourne_data.columns)############## 选择过滤数据 ############### store the series of prices separately as melbourne_price_data.melbourne_price_data = melbourne_data.Price# the head command returns the top few lines of data.print(melbourne_price_data.head())columns_of_interest = ['Landsize', 'BuildingArea']two_columns_of_data = melbourne_data[columns_of_interest]two_columns_of_data.describe()y = melbourne_data.Pricemelbourne_predictors = ['Rooms', 'Bathroom', 'Landsize', 'Lattitude', 'Longtitude']X = melbourne_data[melbourne_predictors]############## Partial Dependence Plots ##############import pandas as pdfrom sklearn.ensemble import GradientBoostingRegressor, GradientBoostingClassifierfrom sklearn.ensemble.partial_dependence import partial_dependence, plot_partial_dependencefrom sklearn.preprocessing import Imputercols_to_use = ['Distance', 'Landsize', 'BuildingArea']def get_some_data(): data = pd.read_csv('../input/melbourne-housing-snapshot/melb_data.csv') y = data.Price X = data[cols_to_use] my_imputer = Imputer() imputed_X = my_imputer.fit_transform(X) return imputed_X, y X, y = get_some_data()my_model = GradientBoostingRegressor()my_model.fit(X, y)my_plots = plot_partial_dependence(my_model, features=[0,2], X=X, feature_names=cols_to_use, grid_resolution=10)############## Data Leakage ############### Leaky Predictors# 数据集中包含预测时不可用的数据。比如，患有癌症的病人，使用了抗生素。# Leaky Validation Strategy# 检验策略有问题。或者测试集的数据影响了验证集数据。比如，调用train_test_split之前运行预处理（如为缺失值拟合Imputer）。 2.2、数据处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697############## 检查数据是否有空项 ##############print(data.isnull().sum())############## 丢掉含有空的数据列 ##############cols_with_missing = [col for col in X_train.columns if X_train[col].isnull().any()]reduced_X_train = X_train.drop(cols_with_missing, axis=1)reduced_X_test = X_test.drop(cols_with_missing, axis=1)print("Mean Absolute Error from dropping columns with Missing Values:")print(score_dataset(reduced_X_train, reduced_X_test, y_train, y_test))############## 填充空的数据列 ##############from sklearn.preprocessing import Imputermy_imputer = Imputer()imputed_X_train = my_imputer.fit_transform(X_train)imputed_X_test = my_imputer.transform(X_test)print("Mean Absolute Error from Imputation:")print(score_dataset(imputed_X_train, imputed_X_test, y_train, y_test))############## 扩展填充空的数据列 ##############imputed_X_train_plus = X_train.copy()imputed_X_test_plus = X_test.copy()cols_with_missing = (col for col in X_train.columns if X_train[col].isnull().any())for col in cols_with_missing: imputed_X_train_plus[col + '_was_missing'] = imputed_X_train_plus[col].isnull() imputed_X_test_plus[col + '_was_missing'] = imputed_X_test_plus[col].isnull()# Imputationmy_imputer = Imputer()imputed_X_train_plus = my_imputer.fit_transform(imputed_X_train_plus)imputed_X_test_plus = my_imputer.transform(imputed_X_test_plus)print("Mean Absolute Error from Imputation while Track What Was Imputed:")print(score_dataset(imputed_X_train_plus, imputed_X_test_plus, y_train, y_test))############## 将非数值列One-Hot Encoding ############### Read the dataimport pandas as pdtrain_data = pd.read_csv('../input/train.csv')test_data = pd.read_csv('../input/test.csv')# Drop houses where the target is missingtrain_data.dropna(axis=0, subset=['SalePrice'], inplace=True)target = train_data.SalePrice# Since missing values isn't the focus of this tutorial, we use the simplest# possible approach, which drops these columns. # For more detail (and a better approach) to missing values, see# https://www.kaggle.com/dansbecker/handling-missing-valuescols_with_missing = [col for col in train_data.columns if train_data[col].isnull().any()] candidate_train_predictors = train_data.drop(['Id', 'SalePrice'] + cols_with_missing, axis=1)candidate_test_predictors = test_data.drop(['Id'] + cols_with_missing, axis=1)# "cardinality" means the number of unique values in a column.# We use it as our only way to select categorical columns here. This is convenient, though# a little arbitrary.low_cardinality_cols = [cname for cname in candidate_train_predictors.columns if candidate_train_predictors[cname].nunique() &lt; 10 and candidate_train_predictors[cname].dtype == "object"]numeric_cols = [cname for cname in candidate_train_predictors.columns if candidate_train_predictors[cname].dtype in ['int64', 'float64']]my_cols = low_cardinality_cols + numeric_colstrain_predictors = candidate_train_predictors[my_cols]test_predictors = candidate_test_predictors[my_cols]print(train_predictors.dtypes.sample(10))one_hot_encoded_training_predictors = pd.get_dummies(train_predictors)from sklearn.model_selection import cross_val_scorefrom sklearn.ensemble import RandomForestRegressordef get_mae(X, y): # multiple by -1 to make positive MAE score instead of neg value returned as sklearn convention return -1 * cross_val_score(RandomForestRegressor(50), X, y, scoring = 'neg_mean_absolute_error').mean()predictors_without_categoricals = train_predictors.select_dtypes(exclude=['object'])mae_without_categoricals = get_mae(predictors_without_categoricals, target)mae_one_hot_encoded = get_mae(one_hot_encoded_training_predictors, target)print('Mean Absolute Error when Dropping Categoricals: ' + str(int(mae_without_categoricals)))print('Mean Abslute Error with One-Hot Encoding: ' + str(int(mae_one_hot_encoded)))############## 多个文件join ##############one_hot_encoded_training_predictors = pd.get_dummies(train_predictors)one_hot_encoded_test_predictors = pd.get_dummies(test_predictors)final_train, final_test = one_hot_encoded_training_predictors.align(one_hot_encoded_test_predictors, join='left', axis=1) 2.3、选择模型1234567891011121314151617181920212223242526272829303132333435363738############## 决策树回归 ##############from sklearn.tree import DecisionTreeRegressor# Define modelmelbourne_model = DecisionTreeRegressor()# Fit modelmelbourne_model.fit(X, y)print("Making predictions for the following 5 houses:")print(X.head())print("The predictions are")print(melbourne_model.predict(X.head()))############## 随机森林 ##############from sklearn.ensemble import RandomForestRegressorfrom sklearn.metrics import mean_absolute_errorforest_model = RandomForestRegressor()forest_model.fit(train_X, train_y)melb_preds = forest_model.predict(val_X)print(mean_absolute_error(val_y, melb_preds))############## XGBoost ##############from xgboost import XGBRegressormy_model = XGBRegressor()# Add silent=True to avoid printing out updates with each cyclemy_model.fit(train_X, train_y, verbose=False)############## PipeLines ##############from sklearn.ensemble import RandomForestRegressorfrom sklearn.pipeline import make_pipelinefrom sklearn.preprocessing import Imputermy_pipeline = make_pipeline(Imputer(), RandomForestRegressor())my_pipeline.fit(train_X, train_y)predictions = my_pipeline.predict(test_X) 2.4、验证模型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768############## 模型在测试集上的误差 ##############from sklearn.model_selection import train_test_split# split data into training and validation data, for both predictors and target# The split is based on a random number generator. Supplying a numeric value to# the random_state argument guarantees we get the same split every time we# run this script.train_X, val_X, train_y, val_y = train_test_split(X, y,random_state = 0)# Define modelmelbourne_model = DecisionTreeRegressor()# Fit modelmelbourne_model.fit(train_X, train_y)# get predicted prices on validation dataval_predictions = melbourne_model.predict(val_X)print(mean_absolute_error(val_y, val_predictions))############## 绘制不同个数叶子节点的误差 ##############from sklearn.metrics import mean_absolute_errorfrom sklearn.tree import DecisionTreeRegressordef get_mae(max_leaf_nodes, predictors_train, predictors_val, targ_train, targ_val): model = DecisionTreeRegressor(max_leaf_nodes=max_leaf_nodes, random_state=0) model.fit(predictors_train, targ_train) preds_val = model.predict(predictors_val) mae = mean_absolute_error(targ_val, preds_val) return(mae) # Data Loading Code Runs At This Pointimport pandas as pd # Load datamelbourne_file_path = '../input/melbourne-housing-snapshot/melb_data.csv'melbourne_data = pd.read_csv(melbourne_file_path) # Filter rows with missing valuesfiltered_melbourne_data = melbourne_data.dropna(axis=0)# Choose target and predictorsy = filtered_melbourne_data.Pricemelbourne_predictors = ['Rooms', 'Bathroom', 'Landsize', 'BuildingArea', 'YearBuilt', 'Lattitude', 'Longtitude']X = filtered_melbourne_data[melbourne_predictors]from sklearn.model_selection import train_test_split# split data into training and validation data, for both predictors and targettrain_X, val_X, train_y, val_y = train_test_split(X, y,random_state = 0)# compare MAE with differing values of max_leaf_nodesplot_x = []plot_y = []for max_leaf_nodes in np.arange(10,1000,5): my_mae = get_mae(max_leaf_nodes, train_X, test_X, train_y, test_y) print("Max leaf nodes: %d \t\t Mean Absolute Error: %d" %(max_leaf_nodes, my_mae)) plot_x.append(max_leaf_nodes) plot_y.append(my_mae)plt.plot(plot_x, plot_y)print("index:%f,nodes:%f"%(plot_y.index(min(plot_y)),plot_x[plot_y.index(min(plot_y))]))plt.show()############## Cross Validation ##############from sklearn.ensemble import RandomForestRegressorfrom sklearn.pipeline import make_pipelinefrom sklearn.preprocessing import Imputermy_pipeline = make_pipeline(Imputer(), RandomForestRegressor())from sklearn.model_selection import cross_val_scorescores = cross_val_score(my_pipeline, X, y, scoring='neg_mean_absolute_error')print('Mean Absolute Error %2f' %(-1 * scores.mean())) 3、总结机器学习是一种数据处理的科学，采用科学的分析方式调整模型的参数，试验的数据，达到提高识别率的目的。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DigitRecognizer]]></title>
    <url>%2F2018%2F06%2F12%2FDigitRecognizer%2F</url>
    <content type="text"><![CDATA[0、概述本篇主要记录本人在Kaggle的Digit Recognizer比赛中学习和用到的知识。 1、介绍 首先介绍一下数字识别(Digit Recognizer)，数字识别堪称机器学习领域的&quot;Hello World&quot;，几乎可以说是每个学习机器学习的入门指南。不过，这个入门还是有门槛的，不像 学习编程语言的&quot;Hello World&quot;，如果一开始就一头扎进来，可能会摸不着头脑。 一开始接触机器学习的是看到有朋友圈里有人发TensorFlow相关的东西，于是在0基础 的情况下，配置TensorFlow环境，模仿TensorFlow的例子开始了Digit Recognizer的 实践，发现做下来不知道自己在做什么，例子的每一步不知道是在干什么，一头雾水。 后来看了一位朋友的博客，分享的是他本人学习机器学习的心路历程，以及一些推荐的公 开课和书籍，撸完Coursera上吴恩达的视频后对机器学习有了初步认识，接着撸了李宏毅的 台大课程，感觉思路豁然开朗，顿时理解了吴恩达讲解的很多内容，毕竟是国语嘛，学起来就 是快。最近开始撸线代和概率论，但是总觉得缺点什么，想想大概是缺少实践吧。 寻找实践的突破口，发现项目中出现的Bug分配到各个担当是个费时费力的工作，如果能 够通过Bug描述自动分类那不就可以节省大量人力成本了嘛。于是说干就干，撸起膀子加油 干。文章分类很快想到了吴恩达老师讲的垃圾邮件分类问题，果断朴素贝叶斯算法。中文与英 文不一样，英文通过空格可以分词，中文就没有那么简单了，于是调研了一下，发现github 上有个很好的中文分分词库jieba。试了用一个项目的数据训练后去测试另一个项目的数据， 准确率也就在50%左右，这样的准确率是无法忍受的，至少在90%以上的准确率才能当做产品 使用吧。这个时候体会到了吴恩达老师的那句话，其实到最后机器学习工作者不是去实现什么 牛逼的算法，因为已经有一大批专门研究算法的人每天从事着这样的工作，用实现好的算法库 比自己实现的效率高，性能好。机器学习工作者主要的工作是：选择数据，选择模型，优化数 据，优化配置，提高准确率。 于是参加了Kaggle比赛，学习各路大神是如何玩转机器学习的。说了这么多，回到我们 的主题Digit Recognizer，分类的方法很多，我们将一一道来。 2、实现2.1、SVM 实现数字识别(scikit-learn)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import pandas as pdimport matplotlib.pyplot as pltfrom sklearn.model_selection import train_test_splitfrom sklearn import svm,metrics# 将图片数据可视化def showImgByRow(row,num=1): ''' show pixel :param row:pixel row np.array :return: null ''' picture = row.reshape((num*28,28)) plt.imshow(picture,cmap='gray') plt.axis('off') plt.show()# 读取训练数据trainFile = r'digit-recognizer/train.csv'trainDF = pd.read_csv(trainFile)# 为了save your life，我们只取前500组数据。其实这样做是可能有问题的，# 如果数据不是随机分布的，前5000个数据都是某个数字，那就game over了# 所以无论做何种预测，最好打印出所有的数据分布。images = trainDF.iloc[0:5000,1:]labels = trainDF.iloc[0:5000,:1]train_images, test_images,train_labels, test_labels = train_test_split(images, labels, train_size=0.8, random_state=0)# 处理输入数据X = train_imagesy = train_labels.values.ravel()# regularization 正规化，归一化# 对于数字识别来说，像素点的为0与非0是完全不同的意义，# 如果取0~255，可能会让算法过渡关注数字的大小，导致识别率的下降X[X&gt;0] = 1 #X/=255# 创建分类器clf = svm.SVC(decision_function_shape='ovr',C = 7,gamma = 0.009)# 喂数据clf.fit(X, y)# 处理测试数据test_images[test_images&gt;0] = 1 #test_images/=255# 预测数据predicted = clf.predict(test_images)expected = test_labels#准确率print(clf.score(test_images,test_labels))print("Classification report for classifier %s:\n%s\n" % (clf, metrics.classification_report(expected, predicted)))print("Confusion matrix:\n%s" % metrics.confusion_matrix(y, y)) 2.2、MLP（DNN）实现数字识别(scikit-learn)1234from sklearn.neural_network import MLPClassifierclf = MLPClassifier(hidden_layer_sizes=(50,), max_iter=10, alpha=1e-4, solver='sgd', verbose=10, tol=1e-4, random_state=1, learning_rate_init=.1) 2.3、DNN实现数字识别(keras)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import pandas as pdimport matplotlib.pyplot as pltfrom sklearn.model_selection import train_test_splitfrom keras.models import Sequentialfrom keras.layers import Dense,Activationfrom keras.utils import to_categorical# 读取训练数据trainFile = r'digit-recognizer/train.csv'trainDF = pd.read_csv(trainFile)# 为了save your life，我们只取前500组数据。其实这样做是可能有问题的，# 如果数据不是随机分布的，前5000个数据都是某个数字，那就game over了# 所以无论做何种预测，最好打印出所有的数据分布。images = trainDF.iloc[0:,1:]labels = trainDF.iloc[0:,:1]train_images, test_images,train_labels, test_labels = train_test_split(images, labels, train_size=0.9, random_state=0)# 处理输入数据X = imagesy = labels.values.ravel()# regularization 正规化，归一化# 对于数字识别来说，像素点的为0与非0是完全不同的意义，# 如果取0~255，可能会让算法过渡关注数字的大小，导致识别率的下降X/=255 #X[X&gt;0] = 1# 创建分类器clf = Sequential()clf.add(Dense(output_dim=64,input_dim=784))clf.add(Activation("relu"))clf.add(Dense(output_dim=10))clf.add(Activation("softmax"))clf.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=['accuracy'])# Convert labels to categorical one-hot encodingone_hot_labels = to_categorical(y, num_classes=10)# Train the model, iterating on the data in batches of 32 samples# 喂数据clf.fit(X, one_hot_labels, epochs=10, batch_size=32)# 处理测试数据test_images/=255 #test_images[test_images&gt;0] = 1# evaluate数据expected = test_labelsone_hot_test_labels = to_categorical(expected, num_classes=10)score = clf.evaluate(test_images, one_hot_test_labels)print(score) 2.4、CNN实现数字识别(keras)参考李宏毅老师的教学视频，自己实现的卷积神经网络12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.model_selection import train_test_splitfrom keras.models import Sequentialfrom keras.layers.core import Dense,Activationfrom keras.layers import MaxPooling2D,Convolution2D,Flattenfrom keras.utils.np_utils import to_categorical# 读取训练数据trainFile = r'digit-recognizer/train.csv'trainDF = pd.read_csv(trainFile)# 为了save your life，我们只取前500组数据。其实这样做是可能有问题的，# 如果数据不是随机分布的，前5000个数据都是某个数字，那就game over了# 所以无论做何种预测，最好打印出所有的数据分布。images = trainDF.iloc[0:5000,1:]labels = trainDF.iloc[0:5000,:1]train_images, test_images,train_labels, test_labels = train_test_split(images, labels, train_size=0.8, random_state=5)# 处理输入数据X = train_images.valuesy = train_labels.values.ravel()# regularization 正规化，归一化# 对于数字识别来说，像素点的为0与非0是完全不同的意义，# 如果取0~255，可能X会让算法过渡关注数字的大小，导致识别率的下降# 此处采用正规化处理，减去平局值，除以标准差mean_px = X.mean().astype(np.float32)std_px = X.std().astype(np.float32)def standardize(x): return (x-mean_px)/std_pxX = standardize(X)# 创建模型model = Sequential()# 25个filter，每个大小是3*3.这样会得到25张图片，去掉边角图片变成26*26model.add(Convolution2D(25,3,3,input_shape=(28,28,1)))# 用2*2的框去取最大值。13*13*25model.add(MaxPooling2D((2,2)))# 越接近Output Filter越多，图包含的信息越多。11*11*50model.add(Convolution2D(50,3,3))# 用2*2的框去取最大值。5*5*50. 比如：去掉一半的像素点，不会改变原图像。model.add(MaxPooling2D((2,2)))# 将图像拉直成1Dmodel.add(Flatten())# 以上是卷积过程，下面是DNN。100个neuron全连接model.add(Dense(output_dim=100))model.add(Activation('relu'))model.add(Dense(output_dim=10))model.add(Activation('softmax'))model.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=['accuracy'])# Convert labels to categorical one-hot encodingone_hot_labels = to_categorical(y, num_classes=10)# Train the model, iterating on the data in batches of 32 samples# 喂数据model.fit(X.reshape(X.shape[0],28,28,1), one_hot_labels, epochs=30, batch_size=64)# 处理测试数据test_images = test_images.valuestest_images = standardize(test_images)# valuationexpected = test_labelsone_hot_test_labels = to_categorical(expected, num_classes=10)score = model.evaluate(test_images.reshape(test_images.shape[0],28,28,1), one_hot_test_labels)print(score) Kaggle上Digit_Recognizer 的Kernel中评分最高的实现，主要的改善有： Dropout 随机丢掉若干神经元 ReduceLROnPlateau当算法在最低点徘徊时，降低LR ImageDataGenerator手动创建更多的学习样本。★关键 分别在训练和测试集上绘制loss和accuracy，观察算法的学习情况。★调整学习方法的依据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport matplotlib.image as mpimgimport seaborn as snsnp.random.seed(2)from sklearn.model_selection import train_test_splitfrom sklearn.metrics import confusion_matriximport itertoolsfrom keras.utils.np_utils import to_categorical # convert to one-hot-encodingfrom keras.models import Sequentialfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2Dfrom keras.optimizers import RMSpropfrom keras.preprocessing.image import ImageDataGeneratorfrom keras.callbacks import ReduceLROnPlateausns.set(style='white', context='notebook', palette='deep')# Load the datatrain = pd.read_csv(r"digit-recognizer/train.csv")test = pd.read_csv(r"digit-recognizer/test.csv")Y_train = train["label"]# Drop 'label' columnX_train = train.drop(labels = ["label"],axis = 1)# free some spacedel train# g = sns.countplot(Y_train)Y_train.value_counts()# plt.show()# Check the dataprint(X_train.isnull().any().describe())print(test.isnull().any().describe())# Normalize the dataX_train = X_train / 255.0test = test / 255.0# Reshape image in 3 dimensions (height = 28px, width = 28px , canal = 1)X_train = X_train.values.reshape(-1,28,28,1)test = test.values.reshape(-1,28,28,1)# Encode labels to one hot vectors (ex : 2 -&gt; [0,0,1,0,0,0,0,0,0,0])Y_train = to_categorical(Y_train, num_classes = 10)# Set the random seedrandom_seed = 2# Split the train and the validation set for the fittingX_train, X_val, Y_train, Y_val = train_test_split(X_train, Y_train, test_size = 0.1, random_state=random_seed)# Some examples# g = plt.imshow(X_train[0][:,:,0])## plt.show()# Set the CNN model# my CNN architechture is In -&gt; [[Conv2D-&gt;relu]*2 -&gt; MaxPool2D -&gt; Dropout]*2 -&gt; Flatten -&gt; Dense -&gt; Dropout -&gt; Outmodel = Sequential()model.add(Conv2D(filters = 32, kernel_size = (5,5),padding = 'Same', activation ='relu', input_shape = (28,28,1)))model.add(Conv2D(filters = 32, kernel_size = (5,5),padding = 'Same', activation ='relu'))model.add(MaxPool2D(pool_size=(2,2)))model.add(Dropout(0.25))model.add(Conv2D(filters = 64, kernel_size = (3,3),padding = 'Same', activation ='relu'))model.add(Conv2D(filters = 64, kernel_size = (3,3),padding = 'Same', activation ='relu'))model.add(MaxPool2D(pool_size=(2,2), strides=(2,2)))model.add(Dropout(0.25))model.add(Flatten())model.add(Dense(256, activation = "relu"))model.add(Dropout(0.5))model.add(Dense(10, activation = "softmax"))# Define the optimizeroptimizer = RMSprop(lr=0.001, rho=0.9, epsilon=1e-08, decay=0.0)# Compile the modelmodel.compile(optimizer = optimizer , loss = "categorical_crossentropy", metrics=["accuracy"])# Set a learning rate annealerlearning_rate_reduction = ReduceLROnPlateau(monitor='val_acc', patience=3, verbose=1, factor=0.5, min_lr=0.00001)epochs = 1 # Turn epochs to 30 to get 0.9967 accuracybatch_size = 64# With data augmentation to prevent overfitting (accuracy 0.99286)datagen = ImageDataGenerator( featurewise_center=False, # set input mean to 0 over the dataset samplewise_center=False, # set each sample mean to 0 featurewise_std_normalization=False, # divide inputs by std of the dataset samplewise_std_normalization=False, # divide each input by its std zca_whitening=False, # apply ZCA whitening rotation_range=10, # randomly rotate images in the range (degrees, 0 to 180) zoom_range = 0.1, # Randomly zoom image width_shift_range=0.1, # randomly shift images horizontally (fraction of total width) height_shift_range=0.1, # randomly shift images vertically (fraction of total height) horizontal_flip=False, # randomly flip images vertical_flip=False) # randomly flip imagesdatagen.fit(X_train)# Fit the modelhistory = model.fit_generator(datagen.flow(X_train,Y_train, batch_size=batch_size), epochs = epochs, validation_data = (X_val,Y_val), verbose = 2, steps_per_epoch=X_train.shape[0] // batch_size , callbacks=[learning_rate_reduction])# Plot the loss and accuracy curves for training and validationfig, ax = plt.subplots(2,1)ax[0].plot(history.history['loss'], color='b', label="Training loss")ax[0].plot(history.history['val_loss'], color='r', label="validation loss",axes =ax[0])legend = ax[0].legend(loc='best', shadow=True)ax[1].plot(history.history['acc'], color='b', label="Training accuracy")ax[1].plot(history.history['val_acc'], color='r',label="Validation accuracy")legend = ax[1].legend(loc='best', shadow=True)# Plot the confusion_matrix# confusion_mtx = confusion_matrix(expected, predicted)# df_cm = pd.DataFrame(confusion_mtx, index = [i for i in range(0,10)], columns = [i for i in range(0,10)])# plt.figure(figsize = (6,5))# conf_mat = sns.heatmap(df_cm, annot=True, cmap='Blues', fmt='g', cbar = False)# conf_mat.set(xlabel='Predicts', ylabel='True')# plt.show() 2.5、kNN实现数字识别此处不再赘述，请参考前文：https://xuleilx.github.io/2018/04/12/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/ 3、总结机器学习把复杂的数字识别问题的变成了简单的分类问题。通过本文可以发现同一个问题可以 由不同的算法解决。本文主要用的是SVM、DNN、CNN、kNN四种算法，分别采用刚刚接触的 Scikit-learn和Keras实现。这里尤其要说明一点的是，神经网络将传统机器学习的函数模 型选择问题变成了搭建神经网络结构的问题。通过对loss和accuracy在样本集和测试集上的 表现权衡bias和variance，成功图像识别问题变成了数据分析问题。这大概就是机器学习的 魅力所在，将无形变成有形。]]></content>
      <tags>
        <tag>Kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logistic回归]]></title>
    <url>%2F2018%2F05%2F29%2FLogistic%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[0、概述0.1、回归的含义 高尔顿（Frramcia Galton,1882-1911）早年在剑桥大学学习医学，但医生的职业对 他并无吸引力，后来他接受了一笔遗产，这使他可以放弃医生的生涯，并与 1850－1852年期 间去非洲考察，他所取得的成就使其在1853年获得英国皇家地理学会的金质奖章。此后他研究 过多种学科（气象学、心理学、社会学、 教育学和指纹学等），在1865年后他的主要兴趣转 向遗传学，这也许是受他表兄达尔文的影响。 从19世纪80年代高尔顿就开始思考父代和子代相似，如身高、性格及其它种种特制的相似 性问题。于是他选择了父母平均身高X与其一子身高Y的关系作为研究对象。他观察了1074对 父母及每对父母的一个儿子，将结果描成散点图，发现趋势近乎一条直 线。总的来说是父母 平均身高X增加时，其子的身高Y也倾向于增加，这是意料中的结果。但有意思的是高尔顿发现 这1074对父母平均身高的平均值为68 英寸（英国计量单位，1 英寸=2.54cm）时，1074个 儿子的平均身高为69 英寸，比父母平均身高大1 英寸 ，于是他推想，当父母平均身高为64 英寸时，1074个儿子的平均身高应为64+1=65 英寸；若父母的身高为72 英寸时，他们儿子 的平均身高应为72=1=73 英寸，但观察结果确与此不符。高尔顿发现前一种情况是儿子的平 均身高为67 英寸，高于父母平均值达3 英寸，后者儿子的平均身高为71英寸，比父母的平均 身高低1 英寸。 高尔顿对此研究后得出的解释是自然界有一种约束力，使人类身高在一定时期是相对稳定 的。如果父 母身高（或矮了），其子女比他们更高（矮），则人类身材将向高、矮两个极端 分化。自然界不这样做，它让身高有一种回归到中心的作用。例如，父母平均身高 72 英寸， 这超过了平均值68英寸，表明这些父母属于高的一类，其儿子也倾向属于高的一类（其平均身 高71 英寸 大于子代69 英寸），但不像父母离子代那么远（71-69&lt;72-68）。反之，父母 平均身高64 英寸，属于矮的一类，其儿子也倾向属于矮的一类（其平均67 英寸，小于子代 的平均数69 英寸），但不像父母离中心那么远（69 -67&lt; 68-64）。 因此，身高有回归于中心的趋势，由于这个性质，高尔顿就把“回归”这个词引进到问题 的讨论中，这就是“回归”名称的由来，逐渐背后人沿用成习了。 0.2、线性回归线性回归实际上就是找到一条直线 $$y = W^{T}x + b$$ ，使得该直线尽可能的拟合样本数据。 0.3、Logistic回归Logistic回归其实不是线性回归求预测值的问题，而是二分类问题。首先我们的线性回归模型输出的预测值，连续的数值，我们想用它解决分类问题，就需要让连续的数值转换到0/1就可以了,这里引入一个新的函数sigmoid $$y=\frac{1}{1+e^{-z}}$$ 函数，其中 $$z = W^{T}x + b$$ 。图像是这样的： 0.4、Softmax回归In mathematics, the softmax function, or normalized exponential function,[1]:198 is ageneralization of the logistic function that “squashes” a K-dimensional vector $$\mathbf {z}$$ ofarbitrary real values to a K-dimensional vector $$\sigma (\mathbf {z} )$$ of real values, where eachentry is in the range (0, 1), and all the entries adds up to 1. The function is given by$${\displaystyle \sigma :\mathbb {R} ^{K}\to \left\{\sigma \in \mathbb {R} ^{K}|\sigma _{i}&gt;0,\sum _{i=1}^{K}\sigma _{i}=1\right\}}$$$$\sigma (\mathbf {z} )_{j}={\frac {e^{z_{j}}}{\sum _{k=1}^{K}e^{z_{k}}}} for j = 1, …, K.$$举个栗子：假设模型的输入样本是I，讨论一个3分类问题（类别用1，2，3表示），样本I的真实类别是2，那么这个样本I经过网络所有层到达 softmax 层之前就得到了 $$W^{T}x$$，也就是说 $$W^{T}x$$ 是一个3 1的向量，那么上面公式中的 $$a_{j}$$ 就表示这个3 1的向量中的第 j 个值; 而分母中的 $$a_{k}$$ 则表示3 1的向量中的3个值，所以会有个求和符号。 因为 $$e^{x}$$ 恒大于0，所以分子永远是正数，分母又是多个正数的和，所以分母也肯定是正数，因此 $$\sigma (\mathbf {z} )_{j}$$ 是正数，而且范围是(0,1)。如果现在不是在训练模型，而是在测试模型，那么当一个样本经过 softmax 层并输出一个K 1的向量时，就会取这个向量中值最大的那个数的index作为这个样本的预测标签。 总结一下：sigmoid将一个real value映射到（0,1）的区间（当然也可以是（-1,1）），这样可以用来做二分类。softmax把一个k维的real value向量（a1,a2,a3,a4….）映射成一个（b1,b2,b3,b4….）其中bi是一个0-1的常数，然后可以根据bi的大小来进行多分类的任务，如取权重最大的一维。 1、介绍1.1、工作原理1.2、优点，缺点，适用范围优点：计算代价不高，易于理解和实现。 缺点：容易欠拟合，分类精度可能不高。 适用范围：标称型数据，标称型数据。 1.3、一般流程收集数据：可以使用任何方法。 准备数据：由于需要进行距离计算，因此要求数据类型为数值型。另外，结构化数据格式则最佳。 分析数据：采用任意方法对数据进行分析。 训练算法：大部分时间用于训练，训练的目的是为了找到最佳的分类回归系数。 测试算法：一旦训练步骤完成，分类将会很快。 使用算法：首先，我们需要输入一些数据，并将其装换成对应的结构化数字；接着基于训练好的回归系数就可以对这些数据进行简单的回归计算，判定它们属于哪个类别；在此之后，我们就可以在输出的类别上做一些其他分析工作。 2、实现2.1、梯度下降梯度：对于可微的数量场f(x,y,z)，以 $$\left ( \partial f /\partial x, \partial f /\partial y, \partial f /\partial z\right )$$ 为分量的向量场称为f的梯度或斜量。梯度下降法(gradient descent)是一个最优化算法，常用于机器学习和人工智能当中用来递归性地逼近最小偏差模型。 对于只含有一组数据的训练样本，我们可以得到更新weights的规则为：$$\theta _{j} := \theta _{j} + \alpha ( y^{i} - h_{\theta }(x^{i}))x_{j}^{(i)}$$扩展到多组数据样本，更新公式为：Repeat until convergence {$$\theta _{j} := \theta _{j} + \alpha \sum_{i=1}^{m} ( y^{i} - h_{\theta }(x^{i}))x_{j}^{(i)} (for every j)$$}称为批处理梯度下降算法，这种更新算法所需要的运算成本很高，尤其是数据量较大时。考虑下面的更新算法：Loop { for i=1 to m,{$$\theta _{j} := \theta _{j} + \alpha ( y^{i} - h_{\theta }(x^{i}))x_{j}^{(i)} (for every j)$$​ }}该算法又叫做随机梯度下降法，这种算法不停的更新weights，每次使用一个样本数据进行更新。当数据量较大时，一般使用后者算法进行更新。 2.2、伪代码123456#随机梯度上升算法可以写成如下的伪代码：所有回归系数初始化为1对数据集中每个样本 计算该样本的梯度 使用alpha * gradient更新回归系数返回回归系数 2.3、python实现1234567891011121314151617181920212223242526272829303132333435363738# 梯度上升算法def gradAscent(dataMatIn,classLabels): ''' :param dataMatIn: 输入数据 :param classLabels: 每行数据对应的标签 :return: ''' dataMatrix = mat(dataMatIn) labelMat = mat(classLabels).transpose() # m*n 矩阵 m,n = shape(dataMatrix) alpha = 0.001 maxCycles = 500 # n所有的Feature，都有weight weights = ones((n,1)) for k in range(maxCycles): h = sigmoid(dataMatrix*weights) # 计算实际值与预测值之间的差值 error = (labelMat - h) # 梯度上升，对sigmoid函数一阶偏导 weights = weights + alpha*dataMatrix.transpose()*error return weights# 随机梯度上升算法def stocGradAscent1(dataMatrix, classLabels, numIter=150): m,n = shape(dataMatrix) weights = ones(n) #initialize to all ones for j in range(numIter): dataIndex = list(range(m)) for i in range(m): alpha = 4/(1.0+j+i)+0.0001 #apha decreases with iteration randIndex = int(random.uniform(0,len(dataIndex)))#Does not go to 0 because of the constant h = sigmoid(sum(dataMatrix[randIndex]*weights)) error = classLabels[randIndex] - h # 梯度下降是预测值-实际值，h - y weights = weights + alpha * error * float64(dataMatrix[randIndex]) del(dataIndex[randIndex]) return weights 3、总结本算法接触到了机器学习的一个核心算法，梯度下降(上升)算法，改算法贯穿机器学习的各种算法，使用该算法可以快速求得最小偏差，得到我们建模的参数(w,b)。Logistic回归(逻辑回归)是个分类问题，使用微分知识对函数sigmoid $$y=\frac{1}{1+e^{-z}}$$ 求偏微分，不需要直接求导，而是用偏微分计算。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素贝叶斯]]></title>
    <url>%2F2018%2F05%2F06%2F%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%2F</url>
    <content type="text"><![CDATA[0、概述朴素贝叶斯是贝叶斯理论的一部分，所以讲述这部分内容之前首先需要了解一下贝叶斯定理。 贝叶斯定理是关于随机事件A和B的条件概率（或边缘概率）的一则定理。其中P(A|B)是在B发 生的情况下A发生的可能性。 描述两个条件概率之间的关系，比如 P(A|B) 和 P(B|A)。 按照乘法法则，可以立刻导出： P(A∩B) = P(A)*P(B|A) = P(B)*P(A|B) 如上公式也可变形为： P(B|A) = P(A|B)*P(B)/P(A) 朴素贝叶斯分类器基于一个简单的假定：给定目标值时属性之间相互条件独立。 1、介绍1.1、工作原理假设每个特征对于决定样本属于哪一类都同等重要。给定一个测试样本w，计算它属于c的概 率，只需要计算出训练样本中类别c的每个特征类型的概率p(w|c)，所有训练样本中类别c的 概率p(c)，测试样本w的概率(实际使用中比较样本w属于哪个类别的可能性更大，等号两边相等) p(c|w) = p(w|c)p(c)/p(w) 1.2、优点，缺点，适用范围优点：在数据较少的情况下仍然有效，可以处理多类别问题。 缺点：对于输入数据的准备方式较为敏感。 适用范围：标称型数据。 1.3、一般流程收集数据：可以使用任何方法。 准备数据：需要数值型或者布尔型数据。 分析数据：有大量特征时，绘制特征作用不大，此时使用直方图效果更好。 训练算法：计算不同的独立特征的条件概率。 测试算法：计算错误率。 使用算法：常用于文档分类。可以在任意的分类场景中使用朴素贝叶斯分类器，不一定非要是文本。 2、实现2.1、伪代码123456789计算每个类别中的文档数目对每篇训练文档： 对每个类别： 如果词条出现文档中 -&gt; 增加该词条的计数值 增加所有词条的计数值 对每个类别： 对每个词条： 将该词条的数目数除以总词条数目得到条件概率 返回每个类别的条件概率 2.2、python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172def createVocabList(dataSet): vocabSet = set([]) for document in dataSet: vocabSet = vocabSet | set(document) return list(vocabSet)def setOfWords2Vec(vocabList,inputSet): returnVec = [0]*len(vocabList) for word in inputSet: if word in vocabList: returnVec[vocabList.index(word)] = 1 else: print("the word: %s is no in my Vocabulary!"%word) return returnVecdef bagOfWords2VecMN(vocabList,inputSet): ''' 单个单词出现多次的场景 :param vocabList:单词集合 :param inputSet:输入的句子 :return: ''' returnVec = [0]*len(vocabList) for word in inputSet: if word in vocabList: returnVec[vocabList.index(word)] += 1 else: print("the word: %s is no in my Vocabulary!" % word) return returnVecdef trainNB0(trainMatrix,trainCategory): ''' :param trainMatrix:文档矩阵 :param trainCategory:文档标签向量 :return: ''' # 计算样本数 numTrainDocs = len(trainMatrix) # 计算单词数 numWords = len(trainMatrix[0]) # 计算所有样本中侮辱言论的概率 pAbusive = sum(trainCategory)/float(numTrainDocs) # 避免个别单词不出现，导致计算概率为0，默认都出现一次。 p0Num = ones(numWords);p1Num = ones(numWords) p0Denom = 2.0; p1Denom = 2.0 for i in range(numTrainDocs): # 轮询所有样本 if trainCategory[i] == 1: # 所有侮辱性言论 # 侮辱性言论中，每个单词使用的次数 p1Num += trainMatrix[i] # 侮辱性言论中，所有单词的出现次数 p1Denom += sum(trainMatrix[i]) else: # 所有正常言论 # 正常言论中，每个单词使用的次数 p0Num += trainMatrix[i] # 正常言论中，所有单词的出现次数 p0Denom += sum(trainMatrix[i]) p1Vect = log(p1Num / p1Denom) p0Vect = log(p0Num / p0Denom) return p0Vect,p1Vect,pAbusivedef classifyNB(vec2Classify,p0Vec,p1Vec,pClass1): # p(c1|w) = p(w|c1)p(c1)/p(w) # p(c0|w) = p(w|c0)p(c0)/p(w) # p0Vec,p1Vec已经log过的。此处缺少除以单词本身出现的概率p(w)。p0,p1都需要除以p(w)可约去 p1 = sum(vec2Classify * p1Vec)+log(pClass1) p0 = sum(vec2Classify * p0Vec)+log(1 - pClass1) if p1 &gt; p0: return 1 else: return 0 3、总结巧妙的运用概率的方法解决分类问题，朴素贝叶斯降低了条件概率计算的复杂度，并且正确率很好。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树算法]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0、概述分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点和有向边组成。 结点有两种类型：内部节点和叶节点，内部节点表示一个特征或属性，叶节点表示一个类。 分类的时候，从根节点开始，对实例的某一个特征进行测试，根据测试结果，将实例分配到其子结点； 此时，每一个子结点对应着该特征的一个取值。如此递归向下移动，直至达到叶结点，最后将实例分配到叶结点的类中。 1、介绍1.1、工作原理对训练数据进行建模，决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程。 它可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。 1.2、优点，缺点，适用范围优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据。 缺点：可能会产生过渡匹配问题。 适用范围：数值型和标称型 1.3、一般流程收集数据：可以使用任何方法。 准备数据：树构造算法只适用于标称型数据，因此数值型数据必须离散化。 分析数据：可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期。 训练算法：构造树的数据结构。 测试算法：使用经验树计算错误率。 使用算法：此步骤可以适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。 2、实现2.1、伪代码123456789# 创建分支伪代码函数createBranch()如下所示： if so return 类标签; else 寻找划分数据集的最好特征 划分数据集 创建分支节点 for 每个划分的子集 调用函数createBranch()并增加结果到分支节点中 return 分支节点 2.2、信息增益划分数据集的大原则是：将无序的数据变得更加有序。决策树是通过什么来选择树根，树枝，叶子的呢？这里不得提到两个概念：信息增益和熵。信息增益：在划分数据集之前之后信息发生的变化称为信息增益。熵：集合信息的度量方式称为熵。如果待分类的事务可能分在多个分类之中，则符号x$_{i}$的信息定义为：$$l(x_{i}) = - \log_2 p(x_{i})$$其中p(x$_{i}$)是选择该分类的概率。为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，公式如下：$$H = -\sum_{i=1}^{n}p(x_{i})\log_2 p(x_{i})$$ 2.3、python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118def calcShannoEnt(dataSet): ''' 计算给定数据集的香农熵。注意是所有数据的集合，不是单个样本。 1. get last current ShannoEnt :param dataSet:数据集 :return: 计算结果 ''' numEntries = len(dataSet) labelCounts = &#123;&#125; # 遍历每个实例，统计标签的频数 for featVec in dataSet: # 获取单个样本的标签列(样本的最后一列为标签列) currentLabel = featVec[-1] # 为单个分类创建字典 if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 shannonEnt = 0.0 # 计算所有类别所有可能值包含的信息期望值 for key in labelCounts: prob = float(labelCounts[key])/numEntries shannonEnt -= prob*log(prob,2) return shannonEnt def splitDataSet(dataSet,axis,value): ''' 按照给定特征划分数据集。最终获得一个子集。举个栗子： [[1,1,'yes'] [1,1,'yes'] [1,0,'no'] [0,1,'no'] [0,1,'no']] 如果以第二例作为axis，特征值为1，得到下面的子集： [[1,'yes'] [1,'yes'] [0,'no'] [0,'no']] 1. find the value row 2. del the value from the row 3. return all the row as [] :param dataSet:待划分的数据集 :param axis:划分数据集的特征 :param value: 需要split的特征值 :return: 划分结果列表 ''' retDataSet = [] for featVec in dataSet: if featVec[axis] == value: reduceFeatVec = featVec[:axis] reduceFeatVec.extend(featVec[axis+1:]) retDataSet.append(reduceFeatVec) return retDataSet def chooseBestFeatureToSplit(dataSet): ''' 1.每个特征中的每个特征值分类 2.计算划分后的香农熵，找出最大熵 3.得出划分后香农熵最大的特征作为最好的分类特征 :param dataSet:数据集 :return:返回分类最好的特征 ''' numFeatures = len(dataSet[0]) - 1 baseEntropy = calcShannoEnt(dataSet) bestInfoGain = 0.0;bestFeature = -1 for i in range(numFeatures): featList = [example[i] for example in dataSet] uniqueVals = set(featList) newEntropy = 0.0 for value in uniqueVals: subDataSet = splitDataSet(dataSet,i,value) prob = len(subDataSet)/float(len(dataSet)) newEntropy += prob*calcShannoEnt(subDataSet) infoGain = baseEntropy - newEntropy if(infoGain &gt; bestInfoGain): bestInfoGain = infoGain bestFeature = i return bestFeature def majorityCnt(classList): ''' 采用多数表决的方法决定叶结点的分类 :param: 所有的 类标签 列表 :return: 出现次数最多的类 ''' classCount=&#123;&#125; for vote in classList: # 统计所有类标签的频数 if vote not in classCount.keys(): classCount[vote]=0 classCount[vote] += 1 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1),reverse=True) return sortedClassCount[0][0] def createTree(dataSet,labels): ''' 创建决策树 :param: dataSet:训练数据集 :return: labels:所有的类标签 ''' classList = [example[-1] for example in dataSet] # 所有的标签都相同，直接返回该标签 if classList.count(classList[0]) == len(classList): return classList[0] # 遍历完所有特征，仍不能把数据划分为仅包含唯一类别的分组，返回出现次数最多的 if len(dataSet[0]) == 1: return majorityCnt(classList) # 找到最好的Feature，函数名称感觉有点问题，跟ToSplit没有关系 bestFeat = chooseBestFeatureToSplit(dataSet) # 找到对应的标签 bestFeatLabel = labels[bestFeat] # 将当前最好的Feature放到决策树 myTree = &#123;bestFeatLabel:&#123;&#125;&#125; del(labels[bestFeat]) featValues = [example[bestFeat] for example in dataSet] uniqueVals = set(featValues) # 一个Feature里面有多个值，按不同的值进行构建树的分支 for value in uniqueVals: subLabels = labels[:] myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet,bestFeat,value),subLabels) return myTree 3、总结决策树算法稍微有点复杂，后面还会涉及到剪枝。目前只接触到二叉树，也就是说一个特征值 要么是，要么否，不知道支不支持多分支，看算应该是支持多分支的，有待继续学习。深刻感 觉到理论的重要性，香农熵的概念是这个算法的核心，如果没有选择最优特征值的算法，无法 确定最优二叉树。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k-近邻算法]]></title>
    <url>%2F2018%2F04%2F12%2Fk-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0、概述 1、介绍 1.1、工作原理 1.2、优点，缺点，适用范围 1.3、一般流程 2、实现 2.1、伪代码 2.2、python实现 3、总结 0、概述简单的说，k-近邻算法是一种分类算法，采用测量测试用例与样本用例不同特征值之间的距离，选取距离最小的样本所属的分类作为测试用例的分类。 1、介绍1.1、工作原理工作原理：存在一个样本数据集，也称作训练样本集，并且样本集中每个数据都存在标签，即我们都知道样本集中每个数据与所属分类的对应关系。 输入没有标签的新数据后，将新数据的每个特征与样本集中的数据对应的特征比较，然后算法提取样本集中特征最相似数据(最近邻)的分类标签。 一般来说，我们只选择样本数据集中前K个最相似的数据，这就是k-近邻算法中的k的出处，通常k是不大于20的整数。 最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类 1.2、优点，缺点，适用范围优点：精度高、对异常值不敏感、无数据输入假定。 缺点：计算复杂度高、空间复杂度高。（每个测试用例都要计算与所有样本用例的每个特征值的距离） 适用范围：数值型和标称型 1.3、一般流程收集数据：可以使用任何方法。 准备数据：距离计算所需要的数值，最好是结构化的数据格式。 分析数据：可以使用任何方法。 训练算法：N/A 测试算法：计算错误率。 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类， 最后应用对计算出的分类执行后续的处理。 2、实现2.1、伪代码N/A 2.2、python实现12345678910111213141516171819202122232425262728293031323334from numpy import *import operatorfrom os import listdirdef classify0(inX, dataSet, labels, k): ''' kNN: k Nearest Neighbors Input: inX: vector to compare to existing dataset (1xN) dataSet: size m data set of known vectors (NxM) labels: data set labels (1xM vector) k: number of neighbors to use for comparison (should be an odd number) Output: the most popular class label ''' # 获取样本数，即M dataSetSize = dataSet.shape[0] # 将单个样本拉成M行矩阵，矩阵相减，得到测试用例特征值与每个样本用例的特征值的差 diffMat = tile(inX, (dataSetSize,1)) - dataSet # 特征值差的平方。此处是array sqDiffMat = diffMat**2 # 每个样本所有特征值差和 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 # 排序，按照数组所在的编号输出 sortedDistIndicies = distances.argsort() classCount=&#123;&#125; for i in range(k): # 获取前k个的标签 voteIlabel = labels[sortedDistIndicies[i]] # 计算相同标签数 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 # 按照标签个数排序 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] 3、总结k-近邻算法是分类数据最简单最有效的算法。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习15之Animation动画]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A015%E4%B9%8BAnimation%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npfrom matplotlib import animationfig,ax = plt.subplots()# 数据是一个0~2π内的正弦曲线x = np.arange(0,2*np.pi,0.1)y= np.sin(x)line, = ax.plot(x,y)# 采用np.pi*i/30 方式更新，更流畅def animate(i): line.set_ydata(np.sin(x+np.pi*i/30)) return line,def init(): line.set_ydata(np.sin(x)) return line,# https://matplotlib.org/api/animation_api.htmlani = animation.FuncAnimation(fig=fig,func=animate,frames=30,init_func=init,blit=True)# https://stackoverflow.com/questions/25140952/matplotlib-save-animation-in-gif-errorani.save('/home/xuleilx/workspace/github/github_pages/public/images/animation.gif', writer='imagemagick', fps=30)plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习14之次坐标轴]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A014%E4%B9%8B%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npx = np.arange(0,10,0.1)y1 = 0.05*x**2y2 = -1*y1# 获取figure默认的坐标系 ax1# fig,ax1 = plt.subplots()ax1 = plt.subplot()# 对ax1调用twinx()方法，生成如同镜面效果后的ax2ax2 = ax1.twinx()ax1.plot(x,y1,'g-')ax2.plot(x,y2,'b--')ax1.set_xlabel('X data')ax1.set_ylabel('Y1',color='g')ax2.set_ylabel('Y2',color='b')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subaxes.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习13之图中图]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A013%E4%B9%8B%E5%9B%BE%E4%B8%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfig = plt.figure()x = [1,2,3,4,5,6,7]y = [1,3,4,2,5,8,6]# 4个值都是占整个figure坐标系的百分比。在这里，假设figure的大小是10x10，# 那么大图就被包含在由(1, 1)开始，宽8，高8的坐标系内。left,bottom,width,height=0.1,0.1,0.8,0.8ax1 = fig.add_axes([left,bottom,width,height])ax1.plot(x,y,'r')ax1.set_xlabel('X')ax1.set_ylabel('Y')ax1.set_title('title')left,bottom,width,height=0.2,0.6,0.25,0.25ax2 = fig.add_axes([left,bottom,width,height])ax2.plot(y,x,'b--')ax2.set_xlabel('X')ax2.set_ylabel('Y')ax2.set_title('title inside 1')# 采用一种更简单方法，即直接往plt里添加新的坐标系left,bottom,width,height=0.6,0.2,0.25,0.25plt.axes([left,bottom,width,height])plt.plot(y[::-1],x,'g-.') # 注意对y进行了逆序处理plt.xlabel('X')plt.ylabel('Y')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/plotinplot.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习12之Subplot多合一显示2]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A012%E4%B9%8BSubplot%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA2%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspec# method 1:subplot2grid#############################plt.figure()ax1 = plt.subplot2grid((3,3),(0,0),colspan=3,rowspan=1)ax1.plot([1,2],[1,2])ax1.set_title('ax1_title')ax2 = plt.subplot2grid((3,3),(1,0),colspan=2)ax3 = plt.subplot2grid((3,3),(1,2),rowspan=2)ax4 = plt.subplot2grid((3,3),(2,0))ax5 = plt.subplot2grid((3,3),(2,1))# method 2:gridspec############################## plt.figure()# gs = gridspec.GridSpec(3,3)# ax1 = plt.subplot(gs[0,:])# ax2 = plt.subplot(gs[1,:2])# ax3 = plt.subplot(gs[1:,2])# ax4 = plt.subplot(gs[2,0])# ax5 = plt.subplot(gs[2,1])# method 3:easy to define structure############################## f,axes = plt.subplots(2,2,sharex=True)# axes[0,0].scatter([1,2],[1,2])plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subplot_method1.png")plt.tight_layout()plt.show() 结果：Method1:Method2:Method3:]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习12之Subplot多合一显示]]></title>
    <url>%2F2017%2F12%2F28%2Fmatplotlib%E5%AD%A6%E4%B9%A012%E4%B9%8BSubplot%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfig = plt.figure()# 使用plt.subplot(2,1,1)将整个图像窗口分为2行1列, 当前位置为1.# 使用plt.plot([0,1],[0,1])在第1个位置创建一个小图.plt.subplot(211)plt.plot([0,1],[0,1])# 使用plt.subplot(2,3,4)将整个图像窗口分为2行3列, 当前位置为4.# 使用plt.plot([0,1],[0,2])在第4个位置创建一个小图.## 这里需要解释一下为什么第4个位置放第2个小图. 上一步中使用plt.subplot(2,1,1)将整个图像窗口分为2行1列,# 第1个小图占用了第1个位置, 也就是整个第1行. 这一步中使用plt.subplot(2,3,4)将整个图像窗口分为2行3列,# 于是整个图像窗口的第1行就变成了3列, 也就是成了3个位置, 于是第2行的第1个位置是整个图像窗口的第4个位置.plt.subplot(234)plt.plot([0,1],[0,2])plt.subplot(235)plt.plot([0,1],[0,3])plt.subplot(236)plt.plot([0,1],[0,4])plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/subplot.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习11之3D图像]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A011%E4%B9%8B3D%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)# X,Y valuex = np.arange(-4,4,0.25)y = np.arange(-4,4,0.25)X,Y = np.meshgrid(x,y)# x-y 平面的网格R = np.sqrt(X**2+Y**2)# height valueZ = np.sin(R)# rstride 和 cstride 分别代表 row 和 column 的跨度ax.plot_surface(X,Y,Z,rstride=1,cstride=1,cmap='rainbow',edgecolor='black')# 添加 XY 平面的等高线ax.contourf(X,Y,Z,zdir='z',offset=-2,cmap='rainbow')ax.set_zlim(-2,2)plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/3d_data.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习9之Image图片]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A010%E4%B9%8BImage%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npa = np.linspace(0,1,9).reshape(3,3)# 三行三列的格子，a代表每一个值，图像右边有一个注释，白色代表值最大的地方，颜色越深值越小。plt.imshow(a,interpolation='nearest',cmap='bone',origin='lower')# 添加一个colorbar ，其中我们添加一个shrink参数，使colorbar的长度变短为原来的92%plt.colorbar(shrink=.92)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/image.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习9Contours等高线图]]></title>
    <url>%2F2017%2F12%2F25%2Fmatplotlib%E5%AD%A6%E4%B9%A09%E4%B9%8BContours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npdef f(x,y): # the height function return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)n = 256x = np.linspace(-3,3,n)y = np.linspace(-3,3,n)# 编织成栅格X,Y = np.meshgrid(x,y)# use plt.contourf to filling contours# X,Y and value for (X,Y) pointplt.contourf(X,Y,f(X,Y),8,alpha=.75,cmap=plt.cm.hot)C = plt.contour(X,Y,f(X,Y),8,colors='black',linewidth=.5)# 添加label，隐藏坐标轴plt.clabel(C,inline=True,fontsize=10)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/contours.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习8之bar柱状图]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A08%E4%B9%8Bbar%E6%9F%B1%E7%8A%B6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npn = 10X = np.arange(n)# 均匀分布Y1 = (1-X/float(n))*np.random.uniform(0.5,1,n)Y2 = (1-X/float(n))*np.random.uniform(0.5,1,n)plt.bar(X,+Y1,facecolor='#9999ff',edgecolor='white')plt.bar(X,-Y2,facecolor='#ff9999',edgecolor='white')for x,y in zip(X,Y1): # ha: horizontal alignment # va: vertical alignment plt.text(x,y,'%.2f'%y,ha='center',va='bottom')for x,y in zip(X,Y2): plt.text(x,-y,'%.2f'%y,ha='center',va='top')#设置显示范围plt.xlim(-.5,n)plt.ylim(-1.25,1.25)plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/bar_map.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习7之散点图]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A07%E4%B9%8B%E6%95%A3%E7%82%B9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as npn = 1024# 高斯分布 http://blog.csdn.net/lanchunhui/article/details/50163669X = np.random.normal(0,1,n)Y = np.random.normal(0,1,n)T = np.arctan2(Y,X)# for color valueplt.scatter(X,Y,s=75,c=T,alpha=0.5)#设置显示范围plt.xlim(-1.5,1.5)plt.ylim(-1.5,1.5)# 去坐标plt.xticks(())plt.yticks(())plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/dot_map.png")plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习6之tick能见度]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A06%E4%B9%8Btick%E8%83%BD%E8%A7%81%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y = 0.1*xplt.figure(num=1,figsize=(8,5))# 单纯直线plt.plot(x,y,linewidth=10,zorder=1)plt.ylim(-2,2)# gca = 'get current axis'# 移动坐标轴位置ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))# 当坐标轴的数字被遮挡时，调整线的透明度for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.7, zorder=2))plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/tick.png")#显示plt.show()]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习5之标注annotate]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A05%E4%B9%8B%E6%A0%87%E6%B3%A8annotate%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y = 2*x + 1plt.figure(num=1,figsize=(8,5))# 单纯直线plt.plot(x,y)# gca = 'get current axis'# 移动坐标轴位置ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))x0 = 1y0 = 2*x0+1# x:[x0,x0],y:[0,y0] 矩阵运算plt.plot([x0,x0],[0,y0],'k--',linewidth=2.5)# set dot stylesplt.scatter([x0,],[y0,],s=50,color='b')# 添加标注# method1plt.annotate(r'$2x+1=%s$'%y0, xy=(x0,y0), xycoords='data', xytext=(+30,-30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle='-&gt;', connectionstyle='arc3,rad=.2'))# method2plt.text(-1,3, r'$\mu\ \sigma_i\ \alpha_t$', fontdict=&#123;'size':16,'color':'r'&#125;)plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/annotation.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习4之legend]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A04%E4%B9%8Blegend%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])# 单纯直线l1, = plt.plot(x,y2,label='up')# 指定线的颜色, 宽度和类型l2, = plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--',label='bottom')plt.legend(handles=[l1,l2],labels=['aaa','bbb'],loc='best')plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/legend.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习3之axis2]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A03%E4%B9%8Baxis2%2F</url>
    <content type="text"><![CDATA[代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 单纯直线plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--')# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])# gca = 'get current axis'ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position("bottom")ax.yaxis.set_ticks_position("left")ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))plt.savefig("/home/xuleilx/workspace/github/github_pages/public/images/axis_2.png")#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习3之axis]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A03%E4%B9%8Baxis%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2plt.figure()# 单纯直线plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color='red',linewidth=5.0,linestyle='--')# 设置坐标轴plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel('I am x')plt.ylabel('I am y')new_ticks= np.linspace(-1,2,5)# 设置坐标的粒度plt.xticks(new_ticks)# 用文字代替对应的数值plt.yticks([-2,-1,0,1,3], ['very bad','bad','normal','good','very good'])#显示plt.show() 输出结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习2之figure]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A02%E4%B9%8Bfigure%2F</url>
    <content type="text"><![CDATA[代码：123456789101112131415161718192021222324# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-3,3,50)#绘制直线y1 = x + 1#绘制曲线y2 = x**2# figure 3，指定figure的编号并指定figure的大小plt.figure(num=3,figsize=(8,5))plt.plot(x,y1)plt.figure(&quot;f2&quot;)plt.plot(x,y2)# 指定线的颜色, 宽度和类型plt.plot(x,y1,color=&apos;red&apos;,linewidth=5.0,linestyle=&apos;--&apos;)#显示plt.show() 结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习1之直线曲线]]></title>
    <url>%2F2017%2F12%2F24%2Fmatplotlib%E5%AD%A6%E4%B9%A01%E4%B9%8B%E7%9B%B4%E7%BA%BF%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[代码： 1234567891011121314151617# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport numpy as np# 产生数据x = np.linspace(-1,1,50)#绘制直线y = x + 1plt.plot(x,y)#绘制曲线y = x**2plt.plot(x,y)#显示plt.show() 显示结果：]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow学习之二次曲线]]></title>
    <url>%2F2017%2F12%2F17%2Ftensorflow%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#coding:utf-8import tensorflow as tfimport numpy as npimport matplotlib.pyplot as plt# 构造添加神经层的函数def add_layer(inputs,in_size,out_size,activation_function=None): # 权重，in_size*out_size随机变量矩阵 Weights = tf.Variable(tf.random_normal([in_size,out_size])) # 偏差，1*out_size数组。 # 在机器学习中，biases的推荐值不为0，这里是在0向量的基础上+0.1 biases = tf.Variable(tf.zeros([1,out_size])+0.1) # y = Weights*x+biases 。 tf.matmul()是矩阵的乘法 Wx_plus_b = tf.matmul(inputs,Weights)+biases # 如果没有定义激励函数就是线性函数 if activation_function is None: outputs = Wx_plus_b else: outputs = activation_function(Wx_plus_b) return outputs# 生成x的值,类似# [[-1. ]# [-0.5]# [ 0. ]# [ 0.5]# [ 1. ]]x_data = np.linspace(-1,1,300)[:,np.newaxis]# 加了一个noise,这样看起来会更像真实情况.类型与x_data一样noise = np.random.normal(0,0.05,x_data.shape)# y = x**2 - 0.5 + noisey_data = np.square(x_data)-0.5+noise# 利用占位符定义我们所需的神经网络的输入。# tf.placeholder()就是代表占位符，这里的None代表无论输入有多少都可以，# 因为输入只有一个特征，所以这里是1xs=tf.placeholder(tf.float32,[None,1])ys=tf.placeholder(tf.float32,[None,1])# inputLayer hideLayer outputLayer# 1 10 1# hideLayerl1 = add_layer(xs,1,10,activation_function=tf.nn.relu)# outputLayerpredition = add_layer(l1,10,1,activation_function=None)# 误差的平方和，再求平均loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys-predition),reduction_indices=[1]))train_step=tf.train.GradientDescentOptimizer(0.1).minimize(loss)init = tf.global_variables_initializer()sess = tf.Session()sess.run(init)# 绘图fig = plt.figure()ax = fig.add_subplot(1,1,1)ax.scatter(x_data,y_data)plt.ion()plt.show()for i in range(1000): sess.run(train_step,feed_dict=&#123;xs:x_data,ys:y_data&#125;) if i % 50 == 0: #print sess.run(loss,feed_dict=&#123;xs:x_data,ys:y_data&#125;) predition_value= sess.run(predition,feed_dict=&#123;xs:x_data&#125;) lines =ax.plot(x_data,predition_value,'r-',lw=5) plt.pause(0.5) ax.lines.remove(lines[0])# input() 学习的结果：]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
</search>
